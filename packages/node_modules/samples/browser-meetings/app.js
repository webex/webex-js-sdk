/* eslint-env browser */

/* global ciscospark */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let spark, meeting, meetings;

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token'
  // 'invitee'
].forEach((id) => {
  const el = document.getElementById(id);
  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

function connect() {
  if (!spark) {
    spark = ciscospark.init({
      config: {
        // Any other sdk config we need
      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  if (!spark.internal.device.registered) {
    spark.internal.device
      .register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add('listening');
        document.getElementById('connection-status').innerHTML = 'connected';
        // return this.spark.internal.device.register()
        return spark.internal.mercury.connect();
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }
}

function disconnect() {
  if (!spark || !spark.internal || !spark.internal.device) {
    return Promise.reject(new Error('You must have a proper spark intstance to disconnect'));
  }
  if (spark.internal.device.registered) {
    return spark.internal.mercury.disconnect().then(() => spark.internal.device.unregister().then(() => {
      document.getElementById('connection-status').innerHTML = 'disconnected';
      return Promise.resolve();
    }));
  }
  return Promise.resolve();
}

function startMeeting(m) {
  meeting = m;
  meeting.on('media:ready', (media) => {
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = media.stream;
    }
    if (media.type === 'remote') {
      document.getElementById('remotevideo').srcObject = media.stream;
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = null;
    }

    if (media.type === 'remote') {
      document.getElementById('remotevideo').srcObject = null;
    }
  });
}

window.addEventListener('unload', disconnect, false);

// In order to simplify the state management needed to keep track of our button
// handlers, we'll rely on the current call global object and only hook up event
// handlers once.

document.getElementById('meetings-object').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
});

document.getElementById('leave').addEventListener('click', () => {
  if (meeting) {
    meeting.leave();
  }
});

document.getElementById('start-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteAudio()
      .then((res) => {
        console.log('audio unmute resolved', res);
      })
      .catch((rej) => {
        console.log('audio unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteAudio()
      .then((res) => {
        console.log('audio mute resolved', res);
      })
      .catch((rej) => {
        console.log('audio mute rejected', rej);
      });
  }
});

document.getElementById('start-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteVideo()
      .then((res) => {
        console.log('video unmute resolved', res);
      })
      .catch((rej) => {
        console.log('video unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteVideo()
      .then((res) => {
        console.log('video mute resolved', res);
      })
      .catch((rej) => {
        console.log('video mute rejected', rej);
      });
  }
});
document.getElementById('start-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingAudio();
  }
});

document.getElementById('stop-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingAudio();
  }
});

document.getElementById('start-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingVideo();
  }
});

document.getElementById('stop-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingVideo();
  }
});

document.getElementById('getStatsRaw').addEventListener('click', () => {
  if (meeting) {
    meeting
      .getStats()
      .withId()
      .withMedia()
      .build()
      .getMedia()
      .withId()
      .withStream(meeting.mediaPeerConnection)
      .build()
      .getStream()
      .on('data', (raw) => {
        console.log(raw);
      });
  }
});

document.getElementById('getStatsFilter').addEventListener('click', () => {
  if (meeting) {
    // meeting
    //   .getStats()
    //   .withMedia()
    //   .build()
    //   .getMedia()
    //   .withId()
    //   .withEvents()
    //   .withHistory()
    //   .withAggregator()
    //   .withInterval()
    //   .withFilter(meeting.mediaPeerConnection)
    //   .build()
    //   .onData((filtered) => {
    //     console.log(filtered);
    //   });
    // OR
    // const stats = meeting.getStats().withId().withMedia().build();
    // const media = stats.getMedia()...
    // media.doData((filtered) => {
    //  do stuff
    // })
    // OR
    meeting.getStats({
      media: {
        id: true,
        history: true,
        interval: true,
        aggregator: true,
        filter: meeting.mediaPeerConnection,
        events: true
      }
    });
    meeting
      .getStats()
      .getMedia()
      .onData((filtered) => {
        console.log(filtered);
      });
    meeting
      .getStats()
      .getMedia()
      .getEvents()
      .on('stats:update', (stats) => {
        console.log(stats);
      });
  }
});

document.getElementById('getAggregation').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getAggregator()
        .get()
    );
  }
});

document.getElementById('getHistory').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getHistory()
        .get()
    );
  }
});

document.getElementById('getInterval').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getInterval()
        .get()
    );
  }
});

// Now, let's set up incoming call handling
document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();
  connect();
});

document.getElementById('disconnect').addEventListener('submit', (event) => {
  event.preventDefault();
  disconnect();
});

document.getElementById('scheduled-meetings').addEventListener('submit', (event) => {
  document.getElementById('scheduled-meetings-div').innerHTML = '';
  event.preventDefault();
  return spark.meetings.scheduledMeetings.get().then((meetings) => {
    Object.keys(meetings).forEach((key) => {
      const entry = meetings[key];
      document.getElementById('scheduled-meetings-div').innerHTML += `-- ${entry.encryptedSubject} < | > ${entry.start} --`;
    });
  });
});

document.getElementById('scheduled-meetings-events').addEventListener('submit', (event) => {
  spark.meetings.getScheduledMeetings().registerCalendarEvents();
  document.getElementById('scheduled-meetings-events-p').innerHTML = '';
  event.preventDefault();
  spark.meetings.getScheduledMeetings().on('calendar:update', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting0events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.meetings.getScheduledMeetings().on('calendar:create', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting0events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.meetings.getScheduledMeetings().on('calendar:delete', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting0events-p').innerHTML += `--DELETED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
});

document.getElementById('PMR').addEventListener('submit', (event) => {
  event.preventDefault();
  return spark.meetings.personalMeetingRoom.get().then((pmr) => {
    console.log(pmr);
    document.getElementById('pmr-sip').value = spark.meetings.personalMeetingRoom.sipUri;
    return spark.meetings.create(document.getElementById('pmr-sip').value).then((m) => {
      startMeeting(m);
    });
  });
});

// And finally, let's wire up dialing
document.getElementById('dialer').addEventListener('submit', (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();
  return spark.meetings.create(document.getElementById('invitee').value).then((m) => {
    startMeeting(m);
  });
});

// And finally, let's wire up dialing
// document.getElementById('getmedia').addEventListener('click', () => {
//   // again, we don't want to reload when we try to dial
//   // const streams = media.getUserMedia();
//   return media.getUser();
// });
// And finally, let's wire up dialing
document.getElementById('join').addEventListener('click', () => meeting.join());
