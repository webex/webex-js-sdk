/* eslint-env browser */
/* global ciscospark */
/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let spark;

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page

[
  `access-token`,
  `invitee`
].forEach((id) => {
  const el = document.getElementById(id);
  el.value = localStorage.getItem(id);
  el.addEventListener(`change`, (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

// There's a few different events that'll let us know we should initialize
// CiscoSpark and start listening for incoming calls, so we'll wrap a few things
// up in a function.
function connect() {
  if (!spark) {
    spark = ciscospark.init({
      credentials: {
        access_token: document.getElementById(`access-token`).value
      }
    });
  }

  if (!spark.phone.registered) {
    // we want to start listening for incoming calls *before* registering with
    // the cloud so that we can join any calls that may already be in progress.
    spark.phone.on(`call:incoming`, (call) => {
      // Let's get the name of the person calling us; in production, you'd
      // probably want to cache this so that you're not adding latency on
      // incoming calls
      spark.people.get(call.from.personId)
        .catch((err) => {
          // Fallback to the person id if we can't look up the person object.
          // This can happen if the call is coming from a telephone number
          // instead of a spark account.
          console.warn(err);
          return call.from.personId;
        })
        .then((person) => {
          if (confirm(`Answer incoming call from ${person.displayName || person}`)) {
            call.answer({
              constraints: {
                audio: true,
                video: true,
                // add a query string parameter for controlling use of fake
                // media or the default camera (note, this is firefox-only)
                fake: location.search.toLowerCase().includes(`usefakemedia`)
              }
            });
            bindCallEvents(call);
          }
          else {
            call.decline();
          }
        });
    });

    return spark.phone.register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add(`listening`);
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        alert(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }

  return Promise.resolve();
}

// Similarly, there are a few different ways we'll get a call Object, so let's
// put call handling inside its own function.
function bindCallEvents(call) {
  // call is a call instance, not a promise, so to know if things break,
  // we'll need to listen for the error event. Again, this is a rather naive
  // handler.
  call.on(`error`, (err) => {
    console.error(err);
    alert(err);
  });

  // We can start rendering local and remote video before the call is
  // officially connected but not right when it's dialed, so we'll need to
  // listen for the streams to become available. We'll use `.once` instead
  // of `.on` because those streams will not change for the duration of
  // the call and it's one less event handler to worry about later.

  call.once(`localMediaStream:change`, () => {
    document.getElementById(`self-view`).srcObject = call.localMediaStream;
  });

  call.once(`remoteMediaStream:change`, () => {
    document.getElementById(`remote-view`).srcObject = call.remoteMediaStream;
  });

  // Once the call ends, we'll want to clean up our UI a bit
  call.on(`disconnected`, () => {
    // Remove the streams from the UI elements
    document.getElementById(`self-view`).srcObject = document.getElementById(`remote-view`).srcObject = undefined;
    // And unset the call object
    call = undefined;
  });

  // Of course, we'd also like to be able to end the call:
  document.getElementById(`hangup`).addEventListener(`click`, () => {
    call.hangup();
  });
}

// Now, let's set up incoming call handling
document.getElementById(`credentials`).addEventListener(`submit`, (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();

  // The rest of the incoming call setup happens in connect();
  connect();
});

// And finally, let's wire up dialing
document.getElementById(`dialer`).addEventListener(`submit`, (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();

  // we'll use `connect()` (even though we might already be connected or
  // connecting) to make sure we've got a functional spark instance.

  connect()
    .then(() => {
      const call = spark.phone.dial(document.getElementById(`invitee`).value, {
        constraints: {
          audio: true,
          video: true,
          // add a query string parameter for controlling use of fake media or
          // the default camera (note, this is firefox-only)
          fake: location.search.toLowerCase().includes(`usefakemedia`)
        }
      });

      // Call our helper function for binding events to calls
      bindCallEvents(call);
    });
    // ignore the catch case since we reported the error above and practical
    // error handling is out of the scope this sample
});
