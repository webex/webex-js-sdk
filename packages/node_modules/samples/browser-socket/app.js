/* eslint-env browser */

/* global ciscospark */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let webex;

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token'
].forEach((id) => {
  const el = document.getElementById(id);
  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

// There's a few different events that'll let us know we should initialize
// CiscoSpark and start listening for incoming calls, so we'll wrap a few things
// up in a function.
function connect() {
  if (!webex) {
    webex = ciscospark.init({
      config: {

      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  // Update the UI.
  const status = document.getElementById('connection-status');
  status.innerHTML = 'initialized';
  status.classList.remove('label-warning');
  status.classList.add('label-success');

  document.getElementById('connect').disabled = true;

  // Listen for events.
  webex.messages.on('messages:created', (message) => {
    console.log(message);
  });

  return Promise.resolve();
}

// Now, let's set up incoming call handling
document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();

  // The rest of the incoming call setup happens in connect();
  connect();
});
