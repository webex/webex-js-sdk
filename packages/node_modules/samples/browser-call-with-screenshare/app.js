/* eslint-env browser */

/* global Webex */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */
/* eslint-disable arrow-body-style */
/* eslint-disable max-len */

// Declare some globals that we'll need throughout
let activeMeeting, webex;

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token',
  'invitee'
].forEach((id) => {
  const el = document.getElementById(id);

  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

// There's a few different events that'll let us know we should initialize
// Webex and start listening for incoming calls, so we'll wrap a few things
// up in a function.
function connect() {
  if (!webex) {
    // eslint-disable-next-line no-multi-assign
    webex = window.webex = Webex.init({
      config: {
        meetings: {
          deviceType: 'WEB'
        }
        // Any other sdk config we need
      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  // Register our device with Webex cloud
  if (!webex.internal.device.registered) {
    webex.internal.device
      .register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add('listening');
        document.getElementById('connection-status').innerHTML = 'connected';

        return webex.internal.mercury.connect();
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }

  // Listen for added meetings
  webex.meetings.on('meeting:added', (addedMeetingEvent) => {
    if (addedMeetingEvent.type === 'INCOMING') {
      const addedMeeting = addedMeetingEvent.meeting;

      // Acknowledge to the server that we received the call on our device
      return addedMeeting.acknowledge(addedMeetingEvent.type)
        .then(() => {
          if (confirm('Answer incoming call')) {
            joinMeeting(addedMeeting)
              .then(() => {
                activeMeeting = addedMeeting;
              });
            bindMeetingEvents(addedMeeting);
          }
          else {
            addedMeeting.decline();
          }
        });
    }

    return Promise.resolve();
  });

  return Promise.resolve();
}

// Similarly, there are a few different ways we'll get a meeting Object, so let's
// put meeting handling inside its own function.
function bindMeetingEvents(meeting) {
  // call is a call instance, not a promise, so to know if things break,
  // we'll need to listen for the error event. Again, this is a rather naive
  // handler.
  meeting.on('error', (err) => {
    console.error(err);
  });

  // Handle media streams changes to ready state
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      document.getElementById('self-view').srcObject = media.stream;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remote-view-video').srcObject = media.stream;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remote-view-audio').srcObject = media.stream;
    }
  });

  // Handle media streams stopping
  meeting.on('media:stopped', (media) => {
    // Remove media streams
    if (media.type === 'local') {
      document.getElementById('self-view').srcObject = null;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remote-view-video').srcObject = null;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remote-view-audio').srcObject = null;
    }
  });

  // Of course, we'd also like to be able to end the call:
  document.getElementById('hangup').addEventListener('click', () => {
    meeting.leave();
  });

  meeting.on('all', (event) => {
    console.log(event);
  });
}

// Join the meeting and add media
function joinMeeting(meeting) {
  return meeting.join().then(() => {
    const mediaSettings = {
      receiveVideo: true,
      receiveAudio: true,
      receiveShare: false,
      sendVideo: true,
      sendAudio: true,
      sendShare: false
    };

    return meeting.getMediaStreams(mediaSettings).then((mediaStreams) => {
      const [localStream, localShare] = mediaStreams;

      meeting.addMedia({
        localShare,
        localStream,
        mediaSettings
      });
    });
  });
}

// In order to simplify the state management needed to keep track of our button
// handlers, we'll rely on the current meeting global object and only hook up event
// handlers once.

document.getElementById('share-screen').addEventListener('click', () => {
  if (activeMeeting) {
    const mediaSettings = {
      receiveShare: false,
      sendShare: true
    };

    activeMeeting.getMediaStreams(mediaSettings)
      // `[, localShare]` is grabbing index 1 from the mediaSettingsResultsArray
      // and storing it in a variable called localShare.
      .then((mediaSettingsResultsArray) => {
        const [, localShare] = mediaSettingsResultsArray;

        return activeMeeting.updateShare({
          sendShare: true,
          receiveShare: false,
          stream: localShare
        });
      })
      .then(() => {
        document.getElementById('screenshare-tracks').innerHTML = '1';
      });
  }
});

document.getElementById('stop-screen-share').addEventListener('click', () => {
  if (activeMeeting) {
    activeMeeting.updateShare({
      sendShare: false,
      receiveShare: false
    })
      .then(() => {
        document.getElementById('screenshare-tracks').innerHTML = '0';
      });
  }
});


document.getElementById('hangup').addEventListener('click', () => {
  if (activeMeeting) {
    activeMeeting.leave();
  }
});

// Now, let's set up incoming call handling
document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();

  // The rest of the incoming call setup happens in connect();
  connect();
});

// And finally, let's wire up dialing
document.getElementById('dialer').addEventListener('submit', (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();

  const destination = document.getElementById('invitee').value;

  // we'll use `connect()` (even though we might already be connected or
  // connecting) to make sure we've got a functional webex instance.
  connect()
    .then(() => {
      // Create the meeting
      return webex.meetings.create(destination).then((meeting) => {
        // Save meeting
        activeMeeting = meeting;

        // Call our helper function for binding events to meetings
        bindMeetingEvents(meeting);

        // Pass the meeting to our join meeting helper
        return joinMeeting(meeting);
      });
    })
    .catch((error) => {
      // Report the error
      console.error(error);

      // Implement error handling here
    });
});
