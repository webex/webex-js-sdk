import testUsers from '@webex/test-helper-test-users';
import {flaky} from '@webex/test-helper-mocha';
import {expect} from 'chai';

describe('samples', () => {
  describe('browser-auth-implicit', () => {
    describe('authenticate using implicit grant flow', () => {
      let spock;

      before('creates spock', () => testUsers.create({count: 1, config: {displayName: 'Spock'}})
        .then((users) => {
          [spock] = users;
        }));

      before('reload browser', () => {
        browser.refresh();
      });

      it('browses to sample app and verifies the user is not authenticated', () => {
        browser.url('/browser-auth-implicit');

        expect(browser.select('browserFirefox').getText('#authentication-status')).to.equal('Not Authenticated');
        expect(browser.select('browserChrome').getText('#authentication-status')).to.equal('Not Authenticated');
      });

      it('initiates implicit grant authentication flow', () => {
        browser.click('[title="authenticate"]');
      });

      it('enters user login information', () => {
        // Wait upto 2s to redirect to idbroker and wait for form to render
        browser.waitForExist('#IDToken1', 2000);

        // the login pages aren't known for their consistency, so we'll break with
        // out pattern of using accessibility labels for test selectors in favor
        // of using the well known (if not a11y helpful) ids.
        browser.setValue('#IDToken1', spock.email);
        browser.click('#IDButton2');

        browser.waitForExist('#IDToken2');
        browser.setValue('#IDToken2', spock.password);
        browser.click('#Button1');

        // I feel like there's a better way to do this...
        // if (browser.isVisible('#generic-error')) {
        //   throw new Error('Failed to login after several attempts');
        // }
      });

      it('accepts the permissions grant if it appears', () => {
        // Wait upto 2s for grant page to render
        // Optionally handle the grant page, but don't fail if this is an app that
        // doesn't show the grant page.
        browser.waitForExist('button[name="accept"]', 2000);
        browser.click('button[name="accept"]');
      });

      it('verifies authentication was successful', () => {
        // Wait upto 2s to redirect back from idbroker and wait for logout button to render
        browser.waitForExist('[title="logout"]', 2000);

        expect(browser.select('browserFirefox').getTitle()).to.equal('Authentication - Implicit Grant Flow');
        expect(browser.select('browserChrome').getTitle()).to.equal('Authentication - Implicit Grant Flow');

        expect(browser.select('browserFirefox').getText('#authentication-status')).to.equal('Authenticated');
        expect(browser.select('browserChrome').getText('#authentication-status')).to.equal('Authenticated');

        expect(browser.select('browserFirefox').getValue('[title="logout"]')).to.equal('logout');
        expect(browser.select('browserChrome').getValue('[title="logout"]')).to.equal('logout');
      });

      // Flaky return from idbroker logout either browser fails with `returnURL not allowed`
      flaky(it, process.env.SKIP_FLAKY_TESTS)('logs out', () => {
        browser.click('[title="logout"]');
        // Wait 1s for idbroker
        browser.pause(1000);

        // idbroker spits out returnURL is not defined error
        // check if one of the browsers return correctly
        if (
          expect(browser.select('browserFirefox').getText('#authentication-status')).to.equal('Not Authenticated') ||
          expect(browser.select('browserChrome').getText('#authentication-status')).to.equal('Not Authenticated')
        ) return true;

        return false;
      });
    });
  });
});
