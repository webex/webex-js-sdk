/* eslint-env browser */

/* global Webex */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let webex, meeting, meetings, newMeeting, callTime;
const mediaSettings = [];
const audioInputSelect = document.querySelector('select#audioSource');
const audioOutputSelect = document.querySelector('select#audioOutput');
const videoSelect = document.querySelector('select#videoSource');

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token'
  // 'invitee'
].forEach((id) => {
  const el = document.getElementById(id);

  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

function connect() {
  if (!window.webex) {
    // eslint-disable-next-line no-multi-assign
    webex = window.webex = Webex.init({
      config: {
        meetings: {
          deviceType: 'WEB'
        }
        // Any other sdk config we need
      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  // Register our device with Webex cloud
  if (!webex.meetings.registered) {
    webex.meetings.register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add('listening');
        document.getElementById('connection-status').innerHTML = 'connected';
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }

  webex.meetings.on('meeting:added', (m) => {
    const {type} = m;

    if (type === 'INCOMING') {
      newMeeting = m.meeting;
      toggleDisplay('incomingsection', true);
      newMeeting.acknowledge(type);
      newMeeting.on('meeting:alerted', () => {
        document.getElementById('alerted-call').innerHTML = 'locus notified that user received call';
      });
    }

    m.meeting.on('meeting:ringing', (e) => {
      if (e.ringing) {
        console.log(`meeting id: ${m.meeting.id} ringing with type ${e.type}`);
        document.getElementById('ringing-call').innerHTML = `meeting ringing type: ${e.type}`;
      }
      else if (!e.ringing) {
        console.log(`meeting id: ${m.meeting.id} stopped ringing`);
        document.getElementById('ringing-call').innerHTML = '';
      }
    });

    const ul = document.getElementById('meeting-list');


    while (ul.firstChild) {
      ul.removeChild(ul.firstChild);
    }
    const allMeeting = webex.meetings.getAllMeetings();

    Object.keys(allMeeting).forEach((key) => {
      const li = document.createElement('li');
      const button = document.createElement('button');
      const button2 = document.createElement('button');

      li.appendChild(document.createTextNode(allMeeting[key].sipUri || allMeeting[key].id));
      li.appendChild(document.createTextNode(`${allMeeting[key].type}`));
      button2.appendChild(document.createTextNode('JOIN WITHOUT MEDIA'));
      button.appendChild(document.createTextNode('JOIN WITH MEDIA'));
      button2.value = allMeeting[key].locusUrl;
      button.value = allMeeting[key].sipUri;
      button2.onclick = () => {
        joinObtpWithoutMedia(allMeeting[key]);
      };
      button.onclick = () => {
        joinWithObtp(allMeeting[key]);
      };
      li.appendChild(button2);
      li.appendChild(button);
      ul.appendChild(li);
    });
    console.log('Meeting added ', m);
  });

  webex.meetings.on('meeting:removed', (m) => {
    newMeeting = undefined;
    if (meeting && m.meetingId === meeting.id) {
      meeting = undefined;
    }
    toggleDisplay('incomingsection', false);
    console.log('Meeting removed ', m);
  });
}

function attachMeetingListeners(meeting) {
  meeting.on('move-update-media', (payload) => {
    console.log('move update media event triggered', payload);
  });
  meeting.on('meeting:locked', () => {
    document.getElementById('meeting-lock').innerHTML = 'Meeting is Locked';
  });

  meeting.on('meeting:unlocked', () => {
    document.getElementById('meeting-lock').innerHTML = 'Meeting is Unlocked';
  });

  meeting.on('meeting:actionsUpdate', (payload) => {
    document.getElementById('userCanLock').innerHTML = `User can lock: ${payload.canLock}`;
    document.getElementById('userCanUnlock').innerHTML = `User can unlock: ${payload.canUnlock}`;
    document.getElementById('userCanTransfer').innerHTML = `User can transfer: ${payload.canAssignHost}`;
  });

  meeting.on('meeting:self:lobbyWaiting', () => {
    document.getElementById('lobby-space').innerHTML = 'User is guest to space, waiting to be admitted, wait to use addMedia';
  });

  meeting.on('meeting:self:guestAdmitted', () => {
    document.getElementById('lobby-space').innerHTML = 'Admitted to meeting as guest to call.';
  });

  meeting.on('meeting:reconnectionStarting', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnecting in progress';
  });

  meeting.on('meeting:reconnectionSuccess', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection success';
    setTimeout(() => { document.getElementById('reconnection-status').innerHTML = ''; }, 5000);
  });

  meeting.on('meeting:reconnectionFailure', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection failure';
  });

  meeting.on('meeting:self:mutedByOthers', () => {
    document.getElementById('muted-by-others').innerHTML = 'muted by others';
    setTimeout(() => {
      document.getElementById('muted-by-others').innerHTML = '';
    }, 10000);
  });

  const lastFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;

  callTime = Date.now();
  let safteyTimeout = null;
  const videoRenderInterval = setInterval(() => {
    const currentFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;

    if (currentFrameCount > 0 && currentFrameCount !== lastFrameCount) {
      const current = Date.now();

      console.log('Received remote stream');
      if (callTime) {
        callTime = current - callTime;
        document.getElementById('time').innerHTML = callTime / 1000;
        callTime = null;
        clearInterval(videoRenderInterval);
        clearTimeout(safteyTimeout);
      }
    }
  }, 500);

  safteyTimeout = setTimeout(() => {
    clearInterval(videoRenderInterval);
  }, 15000);
}

function joinObtpWithoutMedia(obtpMeeting) {
  // Clean Previous meeting and end
  // Meeting already created we just need to do join and add Media
  console.log(obtpMeeting.locusUrl);
  startMeeting(obtpMeeting);
  obtpMeeting.join();
  attachMeetingListeners(obtpMeeting);
}

function joinWithObtp(obtpMeeting) {
  // Clean Previous meeting and end
  // Meeting already created we just need to do join and add Media
  console.log(obtpMeeting.sipUri);
  startMeeting(obtpMeeting);
  obtpMeeting.join()
    .then(() => {
      addMedia(obtpMeeting);
    });
  attachMeetingListeners(obtpMeeting);
}

function cleanUp() {
  if (meeting && meeting.mediaProperties.localStream) {
    meeting.mediaProperties.localStream.getTracks().forEach((track) => {
      track.stop();
    });
  }

  document.getElementById('time').innerHTML = 0;
  document.getElementById('remotevideo').srcObject = null;
}

function addMedia(meeting) {
  document.getElementsByName('mediadirection').forEach((options) => {
    mediaSettings[options.value] = options.checked;
  });

  // use meeting proxy wrapper to media util

  if (mediaSettings.sendAudio || mediaSettings.sendVideo || mediaSettings.sendShare) {
    return meeting.getMediaStreams(mediaSettings)
      .then(([localStream, localShare]) => meeting.addMedia({
        mediaSettings,
        localStream,
        localShare
      }).catch((err) => {
        console.error(err);
      }));
  }

  return meeting.addMedia({
    mediaSettings
  }).catch((err) => {
    console.error(err);
  });
}

function disconnect() {
  if (!webex || !webex.internal || !webex.internal.device) {
    return Promise.reject(new Error('You must have a proper webex instance to disconnect'));
  }
  if (webex.internal.device.registered) {
    return webex.internal.mercury.disconnect().then(() => webex.internal.device.unregister().then(() => {
      document.getElementById('connection-status').innerHTML = 'disconnected';

      return Promise.resolve();
    }));
  }

  return Promise.resolve();
}

function getMemberNameString(participant) {
  if (participant) {
    if (participant.person) {
      return `${participant.person.email}`;
    }
  }

  return 'emptyEmail';
}

function getMemberValueString(member) {
  return `
  self: ${member.isSelf},
  host: ${member.isHost},
  guest: ${member.isGuest},
  audioMuted: ${member.isAudioMuted},
  videoMuted: ${member.isVideoMuted},
  recording: ${member.isRecording},
  meeting: ${member.isInMeeting},
  not: ${!member.isInMeeting},
  waitingAdmit: ${member.isNotAdmitted},
  screen: ${member.isContentSharing},
  status: ${member.status},
  device: ${member.isDevice},
  user: ${member.isUser},
  mutable: ${member.isMutable},
  removable: ${member.isRemovable},
  moderator: ${member.isModerator},
  assignable: ${!member.isModeratorAssignmentNotAllowed}
  id: ${member.id}
  `;
}

// Attach audio output device to video element using device/sink ID.
function attachSinkId(element, sinkId) {
  if (typeof element.sinkId !== 'undefined') {
    element.setSinkId(sinkId)
      .then(() => {
        console.log(`Success, audio output device attached: ${sinkId}`);
      })
      .catch((error) => {
        let errorMessage = error;

        if (error.name === 'SecurityError') {
          errorMessage = `You need to use HTTPS for selecting audio output device: ${error}`;
        }
        console.error(errorMessage);
        // Jump back to first output device in the list as it's the default.
        audioOutputSelect.selectedIndex = 0;
      });
  }
  else {
    console.warn('Browser does not support output device selection.');
  }
}

function startMeeting(m) {
  meeting = m;
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = media.stream;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remotevideo').srcObject = media.stream;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remoteaudio').srcObject = media.stream;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = media.stream;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = media.stream;
    }
  });

  meeting.on('meeting:stoppedSharingLocal', () => {
    console.log('meeting:stoppedSharingLocal');
  });
  meeting.on('meeting:startedSharingLocal', () => {
    console.log('meeting:startedSharingLocal');
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = null;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remotevideo').srcObject = null;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remoteaudio').srcObject = null;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = null;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = null;
    }
  });

  meeting.members.on('members:update', (delta) => {
    let updateString = '';
    let addedString = '';
    let memberString = '';
    const things = delta.delta;
    const {full} = delta;

    // if kitchen sink was more sophistciated we would re render participants only, or render new as necessary
    Object.keys(full).forEach((key) => {
      const member = full[key];

      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
    const {updated} = things;
    const {added} = things;

    Object.keys(updated).forEach((key) => {
      const member = updated[key];

      updateString += `Member Updated: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    Object.keys(added).forEach((key) => {
      const member = added[key];

      addedString += `Member Added: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participant-updates').innerHTML = `LAST MEMBERS DELTA: -- MEMBERS UPDATES: ${updateString} -- MEMBERS ADDED: ${addedString}`;
  });

  meeting.members.on('members:content:update', (payload) => {
    console.log(`who started sharing: ${payload.activeContentSharingId};`);
    console.log(`who stopped sharing: ${payload.endedContentSharingId};`);
    const members = meeting.members.membersCollection.getAll();
    let memberString = '';

    if (payload.activeContentSharingId && !payload.endedContentSharingId) {
      document.getElementById('sharevideo').srcObject = null;
    }
    document.getElementById('sharevideo').srcObject = meeting.mediaProperties.remoteShare;


    Object.keys(members).forEach((key) => {
      const member = members[key];

      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
  });
}

function addData(chart, dataSet, data) {
  chart.data.datasets[dataSet].data.push(data);
  chart.update();
}

function removeData(chart) {
  chart.data.labels.splice(0, 1);
  chart.data.datasets.forEach((dataset) => {
    dataset.data.splice(0, 1);
  });
  chart.update();
}

window.addEventListener('unload', disconnect, false);

// In order to simplify the state management needed to keep track of our button
// handlers, we'll rely on the current call global object and only hook up event
// handlers once.

audioOutputSelect.onchange = function () {
  attachSinkId(document.getElementById('remoteaudio'), audioOutputSelect.value);
};

document.getElementById('getDevices').addEventListener('click', () => {
  const selectors = [audioInputSelect, audioOutputSelect, videoSelect];

  meeting.getDevices().then((deviceInfos) => {
    const values = selectors.map((select) => select.value);

    selectors.forEach((select) => {
      while (select.firstChild) {
        select.removeChild(select.firstChild);
      }
    });
    for (let i = 0; i !== deviceInfos.length; i += 1) {
      const deviceInfo = deviceInfos[i];
      const option = document.createElement('option');

      option.value = deviceInfo.deviceId;
      if (deviceInfo.kind === 'audioinput') {
        option.text = deviceInfo.label || `microphone ${audioInputSelect.length + 1}`;
        audioInputSelect.appendChild(option);
      }
      else if (deviceInfo.kind === 'audiooutput') {
        option.text = deviceInfo.label || `speaker ${audioOutputSelect.length + 1}`;
        audioOutputSelect.appendChild(option);
      }
      else if (deviceInfo.kind === 'videoinput') {
        option.text = deviceInfo.label || `camera ${videoSelect.length + 1}`;
        videoSelect.appendChild(option);
      }
      else {
        console.log('Some other kind of source/device: ', deviceInfo);
      }
    }
    selectors.forEach((select, selectorIndex) => {
      if (Array.prototype.slice.call(select.childNodes).some((n) => n.value === values[selectorIndex])) {
        select.value = values[selectorIndex];
      }
    });
  });
});


document.getElementById('updateVideo').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    if (options.value === 'receiveVideo' || options.value === 'sendVideo') {
      media[options.value] = options.checked;
    }
  });

  meeting.getSupportedDevices({sendVideo: media.sendVideo})
    .then(({sendVideo}) => {
      if (sendVideo) {
        // Sending a boolean to `getMediaStreams` lets the browser decide which device to use.
        let video = true;

        // If we have a device specified, tell `getMediaStreams` to use it specifically.
        if (videoSelect.value) {
          video = {
            deviceId: {
              exact: videoSelect.value
            }
          };
        }

        meeting.getMediaStreams({sendVideo}, {video})
          .then(([localStream]) => meeting.updateVideo({
            stream: localStream,
            receiveVideo: media.receiveVideo,
            sendVideo
          }));
      }
      else {
        meeting.updateVideo({
          receiveVideo: media.receiveVideo,
          sendVideo
        });
      }
    });
});

document.getElementById('updateAudio').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    if (options.value === 'receiveAudio' || options.value === 'sendAudio') {
      media[options.value] = options.checked;
    }
  });

  meeting.getSupportedDevices({sendAudio: media.sendAudio})
    .then(({sendAudio}) => {
      if (sendAudio) {
        // Sending a boolean to `getMediaStreams` lets the browser decide which device to use.
        let audio = true;

        // If we have a device specified, tell `getMediaStreams` to use it specifically.
        if (audioInputSelect.value) {
          audio = {
            deviceId: {
              exact: audioInputSelect.value
            }
          };
        }

        meeting.getMediaStreams(media, {audio})
          .then(([localStream]) => {
            meeting.updateAudio({
              stream: localStream,
              receiveAudio: media.receiveAudio,
              sendAudio
            });
          });
      }
      else {
        meeting.updateAudio({
          receiveAudio: media.receiveAudio,
          sendAudio
        });
      }
    });
});

document.getElementById('updateShare').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });

  if (media.sendShare) {
    meeting.getMediaStreams({sendShare: media.sendShare})
      .then((response) => meeting.updateShare({
        stream: response[1],
        sendShare: media.sendShare,
        receiveShare: media.receiveShare
      }));
  }
  else {
    meeting.updateShare({
      sendShare: media.sendShare,
      receiveShare: media.receiveShare
    });
  }
});


document.getElementById('updateMedia').addEventListener('click', () => {
  const audio = {};
  const video = {};
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  audio.deviceId = {exact: audioInputSelect.value};
  video.deviceId = {exact: videoSelect.value};
  console.log(`audioDeviceId: ${audio.deviceId.exact}`);
  console.log(`videoDeviceId ${video.deviceId.exact}`);
  meeting.getMediaStreams(media, {audio, video})
    .then(([localStream, localShare]) => meeting.updateMedia({
      mediaSettings: media,
      localStream,
      localShare
    }));
});

document.getElementById('check-in-meeting-actions-anytime').addEventListener('click', () => {
  if (meeting) {
    document.getElementById('userCanLock').innerHTML = `User can lock: ${meeting.inMeetingActions.getCanLock()}`;
    document.getElementById('userCanUnlock').innerHTML = `User can unlock: ${meeting.inMeetingActions.getCanUnlock()}`;
    document.getElementById('userCanTransfer').innerHTML = `User can transfer: ${meeting.inMeetingActions.getCanAssignHost()}`;
  }
});

document.getElementById('lock-meeting').addEventListener('click', () => {
  if (meeting) {
    meeting.lockMeeting();
  }
});

document.getElementById('unlock-meeting').addEventListener('click', () => {
  if (meeting) {
    meeting.unlockMeeting();
  }
});

document.getElementById('addDevicesMedia').addEventListener('click', () => {
  const audio = {};
  const video = {};
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  audio.deviceId = {exact: audioInputSelect.value};
  video.deviceId = {exact: videoSelect.value};
  console.log(`audioDeviceId: ${audio.deviceId.exact}`);
  console.log(`videoDeviceId ${video.deviceId.exact}`);
  meeting.getMediaStreams(media, {audio, video})
    .then(([localStream, localShare]) => meeting.addMedia({
      mediaSettings: media,
      localStream,
      localShare
    }));
});

document.getElementById('meetings-object').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
});

document.getElementById('reachability').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
  webex.meetings.setReachability();
  webex.meetings.startReachability();
});

document.getElementById('syncMeeting').addEventListener('click', () => {
  const el = document.querySelector('#meeting-list');

  const newEl = document.createElement('ul');

  newEl.id = 'meeting-list';

  el.parentNode.replaceChild(newEl, el);
  webex.meetings.syncMeetings();
});

document.getElementById('leave').addEventListener('click', () => {
  cleanUp();
  if (meeting) {
    meeting.leave();
  }
  toggleDisplay('incomingsection', false);
});

document.getElementById('start-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteAudio()
      .then((res) => {
        console.log('audio unmute resolved', res);
      })
      .catch((rej) => {
        console.log('audio unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteAudio()
      .then((res) => {
        console.log('audio mute resolved', res);
      })
      .catch((rej) => {
        console.log('audio mute rejected', rej);
      });
  }
});

document.getElementById('start-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteVideo()
      .then((res) => {
        console.log('video unmute resolved', res);
      })
      .catch((rej) => {
        console.log('video unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteVideo()
      .then((res) => {
        console.log('video mute resolved', res);
      })
      .catch((rej) => {
        console.log('video mute rejected', rej);
      });
  }
});

document.getElementById('start-recording').addEventListener('click', () => {
  if (meeting) {
    meeting.startRecording();
  }
});

document.getElementById('stop-recording').addEventListener('click', () => {
  if (meeting) {
    meeting.stopRecording();
  }
});

document.getElementById('pause-recording').addEventListener('click', () => {
  if (meeting) {
    meeting.pauseRecording();
  }
});

document.getElementById('resume-recording').addEventListener('click', () => {
  if (meeting) {
    meeting.resumeRecording();
  }
});

document.getElementById('charting').addEventListener('click', () => {
  const ctx = document.getElementById('myChart').getContext('2d');
  const chart = new Chart(ctx, { // eslint-disable-line
    // The type of chart we want to create
    type: 'line',
    options: {
      title: {
        display: true,
        text: 'Time Series'
      },
      elements: {
        line: {
          tension: 0 // disables bezier curves
        }
      },
      scales: {
        yAxes: [{
          id: 'left-y-axis',
          type: 'linear',
          position: 'left'
        }, {
          id: 'right-y-axis',
          type: 'linear',
          position: 'right'
        }]
      }
    },
    // The data for our dataset
    data: {
      datasets: [
        {
          label: 'bytesSent',
          backgroundColor: 'rgb(255, 99, 132)',
          borderColor: 'rgb(255, 99, 132)',
          fill: false,
          yAxisID: 'left-y-axis'
        },
        {
          label: 'bytesSentDifference',
          backgroundColor: 'rgb(0, 0, 255)',
          borderColor: 'rgb(0, 0, 255)',
          fill: false,
          yAxisID: 'right-y-axis'
        }
      ]
    }
  });

  const analyzer = webex.meetings.getAnalyzer();

  document.getElementById('addChartData').addEventListener('click', () => {
    const thirtySecondsData = meeting.getStats().getSender('0').getHistory().getSlice(30);
    const analysis = analyzer.analyze(thirtySecondsData, {analysisKeys: [{key: 'bytesSent', check: 'increasing'}, {key: 'packetsSent', check: 'increasing'}]});
    const wholeData0 = [];
    const wholeData1 = [];
    const wholeDataLabel = [];

    analysis.data.bytesSent.reports.forEach((report) => {
      wholeDataLabel.push(report.index);
      wholeData0.push(report.value);
      wholeData1.push(report.difference);
    });

    chart.data.datasets[0].data = wholeData0;
    chart.data.datasets[1].data = wholeData1;
    chart.data.labels = wholeDataLabel;
    chart.update();
  });
});

document.getElementById('getStats').addEventListener('click', () => {
  const ctx = document.getElementById('myChart2').getContext('2d');
  const chart = new Chart(ctx, { // eslint-disable-line
    // The type of chart we want to create
    type: 'line',
    options: {
      title: {
        display: true,
        text: 'Time Series'
      },
      elements: {
        line: {
          tension: 0 // disables bezier curves
        }
      },
      scales: {
        yAxes: [{
          id: 'left-y-axis',
          type: 'linear',
          position: 'left'
        }]
      }
    },
    // The data for our dataset
    data: {
      datasets: [
        {
          label: 'bytesReceived',
          backgroundColor: 'rgb(255, 99, 132)',
          borderColor: 'rgb(255, 99, 132)',
          fill: false,
          yAxisID: 'left-y-axis'
        }
      ]
    }
  });
  let i = 0;

  if (meeting) {
    const audioSenderId = '0';
    const audioReceiverId = '1';
    const videoSenderId = '2';
    const videoReceiverId = '3';
    const shareSenderId = '4';
    const shareReceiverId = '5';
    const options = {
      useConfig: true,
      senders: [
        {
          id: audioSenderId,
          correlate: 'audio', // NECESSARY KEY
          history: true,
          onData: (data) => {
            console.log('audioSender->', data);
          },
          onClose: (error) => {
            console.warn('audioSender->', error);
          },
          onEvent: (event) => {
            console.error('audioSender->', event);
          }
        }
      ],
      receivers: [
        {
          id: audioReceiverId,
          correlate: 'audio', // NECESSARY KEY
          history: true,
          onData: (data) => {
            console.log('audioReceiver->', data);
            const k = data.data.getData();

            if (k && k.rtpInAudio && k.rtpInAudio.bytesReceived) {
              chart.data.labels.push(i);
              addData(chart, 0, k.rtpInAudio.bytesReceived);
              i += 1;
            }

            if (i > 30) {
              removeData(chart);
            }
          },
          onClose: (error) => { console.warn('audioReceiver->', error); },
          onEvent: (event) => { console.error('audioReceiver->', event); }
        }
      ]
    };

    meeting.getStats(options, true);

    // notice no meeting is needed, and no correlate key is required, this is the manual builder method
    meeting
      .getStats()
      .addSenderStats(shareSenderId)
      .withHistory()
      .withId(shareSenderId)
      .withFilter(meeting.mediaProperties.peerConnection.shareTransceiver.sender, meeting.mediaProperties.peerConnection)
      .withEvents()
      .onData((data) => {
        console.log('shareSender->', data);
      })
      .onClose((error) => { console.warn('shareSender->', error); })
      .onEvent((event) => { console.error('shareSender->', event); })
      .build();

    meeting.getStats().associateMeeting(meeting); // NECESSARY for adding senders dynamically

    meeting.getStats().addSenders(
      [
        {
          id: videoSenderId,
          correlate: 'video', // NECESSARY KEY
          history: true,
          onData: (data) => { console.log('videoSender->', data); },
          onClose: (error) => { console.warn('videoSender->', error); },
          onEvent: (event) => { console.error('videoSender->', event); }
        }
      ],
      true
    );

    meeting.getStats().addReceivers(
      [
        {
          id: videoReceiverId,
          correlate: 'video', // NECESSARY KEY
          history: true,
          onData: (data) => { console.log('videoReceiver->', data); },
          onClose: (error) => { console.warn('videoReceiver->', error); },
          onEvent: (event) => { console.error('videoReceiver->', event); }
        }
      ],
      true
    );

    meeting.getStats().addReceiver({
      id: shareReceiverId,
      correlate: 'share', // NECESSARY KEY
      history: true,
      onData: (data) => { console.log('shareReceiver->', data); },
      onClose: (error) => { console.warn('shareReceiver->', error); },
      onEvent: (event) => { console.error('shareReceiver->', event); }
    }, true);
  }
});

document.getElementById('destroyStats').addEventListener('click', () => {
  if (meeting) {
    meeting.stopStats();
  }
});

document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();
  connect();
});

document.getElementById('disconnect').addEventListener('submit', (event) => {
  event.preventDefault();
  disconnect();
});

document.getElementById('scheduled-meetings').addEventListener('submit', (event) => {
  document.getElementById('scheduled-meetings-div').innerHTML = '';
  event.preventDefault();

  return webex.internal.calendar.list({max: 200}).then((meetings) => {
    Object.keys(meetings).forEach((key) => {
      const entry = meetings[key];

      document.getElementById('scheduled-meetings-div').innerHTML += `-- ${entry.encryptedSubject} < | > ${entry.start} --`;
    });
  });
});

document.getElementById('scheduled-meetings-events').addEventListener('submit', (event) => {
  event.preventDefault();
  webex.internal.mercury.on('event:calendar.meeting.create', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  webex.internal.mercury.on('event:calendar.meeting.create.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  webex.internal.mercury.on('event:calendar.meeting.update', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  webex.internal.mercury.on('event:calendar.meeting.update.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  webex.internal.mercury.on('event:calendar.meeting.delete', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--DELETED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
});

document.getElementById('transfer-host-to').addEventListener('submit', (event) => {
  event.preventDefault();

  const hostToGo = document.getElementById('transfer-host').value;

  if (meeting) {
    meeting.transfer(hostToGo);
  }
});

document.getElementById('PMR').addEventListener('submit', (event) => {
  event.preventDefault();

  return webex.meetings.personalMeetingRoom.get().then((pmr) => {
    console.log(pmr);
    document.getElementById('pmr-info').innerHTML = `PMR INFO:
      link-${webex.meetings.personalMeetingRoom.meetingLink}-
      uri-${webex.meetings.personalMeetingRoom.sipUri}-
      tollFree-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
      toll-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
      accessCode-${webex.meetings.personalMeetingRoom.pmr.meetingNumber}
      `;
  });
});

document.getElementById('PMR-edit').addEventListener('submit', (event) => {
  event.preventDefault();
  const pmrLink = document.getElementById('wbx-pmr-link').value;
  const hostPin = document.getElementById('wbx-pmr-host-pin').value;

  if (!pmrLink && !hostPin) {
    return;
  }
  webex.meetings.personalMeetingRoom.claim(pmrLink, hostPin).then((claimed) => {
    console.log(claimed);
    document.getElementById('pmr-edit-info').innerHTML = `PMR INFO:
    link-${webex.meetings.personalMeetingRoom.meetingLink}-
    uri-${webex.meetings.personalMeetingRoom.sipUri}-
    tollFree-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
    toll-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
    accessCode-${webex.meetings.personalMeetingRoom.pmr.meetingNumber}
    `;
  }).catch((err) => {
    console.error(err);
  });
});

document.getElementById('invite-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.invite({emailAddress: document.getElementById('invite-invitee').value}).then((res) => {
    console.log(res);
  });
});

document.getElementById('admit-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.admit([document.getElementById('admit-invitee').value]).then((res) => {
    console.log(res);
  });
});

document.getElementById('remove-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.remove(document.getElementById('remote-remove').value).then((res) => {
    console.log(res);
  });
});

document.getElementById('mute-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.mute(document.getElementById('remote-mute').value, document.getElementById('mute-audio-remote-check').checked).then((res) => {
    console.log(res);
  });
});

document.getElementById('mute-room-device').addEventListener('submit', (event) => {
  event.preventDefault();
  console.error('TODO mute room device using devices plugin');
  // TODO:
});

// And finally, let's wire up dialing
document.getElementById('dialer').addEventListener('submit', (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();
  webex.meetings.create(document.getElementById('invitee').value)
    .then((m) => {
      console.log(m);
      startMeeting(m);
    });
});

document.getElementById('reconnect-button').addEventListener('click', () => {
  meeting.reconnect();
});

document.getElementById('move-meeting-leave').addEventListener('click', () => {
  if (meeting) {
    let resourceId;

    if (webex.devicemanager && webex.devicemanager._pairedDevice) {
      resourceId = webex.devicemanager._pairedDevice.identity.id;
    }

    meeting.leave({resourceId}).then((res) => {
      console.log(`successful leave with device, ${res}`);
    });
  }
});

document.getElementById('move-meeting-leave-web').addEventListener('click', () => {
  if (meeting) {
    meeting.leave().then((res) => {
      console.log(`successful leave, ${res}`);
    });
  }
});

document.getElementById('move-meeting-to-resource').addEventListener('click', () => {
  if (meeting) {
    let resourceId;

    if (webex.devicemanager && webex.devicemanager._pairedDevice) {
      resourceId = webex.devicemanager._pairedDevice.identity.id;
    }

    meeting.moveTo(resourceId).then((res) => {
      console.log(`successful move to ${res}`);
    });
  }
});

document.getElementById('move-meeting-from-resource').addEventListener('click', () => {
  if (meeting) {
    let resourceId;

    if (webex.devicemanager && webex.devicemanager._pairedDevice) {
      resourceId = webex.devicemanager._pairedDevice.identity.id;
    }

    meeting.moveFrom(resourceId).then((res) => {
      console.log(`successful move from ${res}`);
    });
  }
});

// And finally, let's wire up dialing
// document.getElementById('getmedia').addEventListener('click', () => {
//   // again, we don't want to reload when we try to dial
//   // const streams = media.getUserMedia();
//   return media.getUser();
// });
// And finally, let's wire up dialing
document.getElementById('join').addEventListener('click', () => {
  // TODO: add resource id if paired
  let deviceId;

  if (webex.devicemanager && webex.devicemanager._pairedDevice) {
    deviceId = webex.devicemanager._pairedDevice.identity.id;
  }
  const pin = document.getElementById('hostPin-join').value;
  let hostPin;

  if (pin) {
    hostPin = Number(pin);
  }
  const moveToResource = false;
  const moderator = document.getElementById('moderator-join').checked;

  meeting.join({
    resourceId: deviceId,
    hostPin,
    moderator,
    moveToResource
  })
    .then((res) => {
      console.log('Succesful join, res: ', res);
    }).catch((err) => {
      handleJoinIntent(err, meeting, deviceId);
    });

  attachMeetingListeners(meeting);
});

document.getElementById('addMedia').addEventListener('click', () => {
  addMedia(meeting);
});

document.getElementById('wirelessShare').addEventListener('click', () => {
  event.preventDefault();
  const deviceId = webex.devicemanager._pairedDevice.identity.id;

  // deviceId is the destination to do the share
  // Need to be more specific if we are calling a device
  return webex.meetings.create(deviceId, 'SIP_URI').then((m) => {
    console.log(m);
    startMeeting(m);

    return meeting.join({
      resourceId: deviceId
    })
      .then(() => meeting.getMediaStreams({
        sendAudio: false,
        sendVideo: false,
        sendShare: true
      }))
      .then(([localStream, localShare]) =>
        meeting.addMedia({
          mediaSettings: {
            sendAudio: false,
            sendVideo: false,
            sendShare: true,
            receiveShare: false,
            receiveAudio: false,
            receiveVideo: false
          },
          localShare,
          localStream
        }))
      .catch((e) => {
        meeting.leave();
        console.error('Error wiresless screen sharing', e);
      });
  });
});

document.getElementById('stopWirelessShare').addEventListener('click', () => {
  meeting.leave();
});

document.getElementById('answer').addEventListener('click', () => {
  meeting = newMeeting;
  startMeeting(meeting);
  newMeeting.join().then(() => {
    newMeeting.acknowledge('ANSWER', false);
  });
  attachMeetingListeners(newMeeting);
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
  toggleDisplay('incomingsection', false);
});

document.getElementById('reject').addEventListener('click', () => {
  meeting = newMeeting;
  meeting.decline('BUSY');
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
  toggleDisplay('incomingsection', false);
});

document.getElementById('stop-sending-share').addEventListener('click', () => {
  if (meeting) {
    meeting.stopShare();
  }
});

document.getElementById('sendDtmf').addEventListener('click', () => {
  if (meeting) {
    const tones = document.getElementById('sendDtmfInput').value;

    if (!tones) {
      window.alert('No tones to send');

      return;
    }

    meeting.sendDTMF(tones);
  }
});

document.getElementById('setMeetingQuality')
  .addEventListener('click', () => {
    if (meeting) {
      const level = document.getElementById('setMeetingQualityLevel').value;

      meeting.setMeetingQuality(level);
    }
  });

document.getElementById('setLocalVideoQuality')
  .addEventListener('click', () => {
    if (meeting) {
      const level = document.getElementById('setLocalVideoQualityLevel').value;

      meeting.setLocalVideoQuality(level);
    }
  });

document.getElementById('setRemoteMeetingQuality')
  .addEventListener('click', () => {
    if (meeting) {
      const level =
        document.getElementById('setRemoteMeetingQualityLevel').value;

      meeting.setRemoteQualityLevel(level);
    }
  });

function handleJoinIntent(err, meeting, deviceId) {
  if (err.joinIntentRequired) {
    toggleDisplay('joinAsHostOrGuest', true);
    // memory/event leak, can also wait for triggered event
    // meeting.on('lobby:hostOrGuest'...
    document.getElementById('joinAsHost').addEventListener('click', () => {
      const pin = document.getElementById('hostPin-join').value;
      let hostPin;

      if (pin) {
        hostPin = Number(pin);
      }
      const moderator = document.getElementById('moderator-join').checked;

      meeting.join({resourceId: deviceId, hostPin, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
    document.getElementById('joinAsGuest').addEventListener('click', () => {
      const moderator = document.getElementById('moderator-join').checked;

      meeting.join({resourceId: deviceId, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
  }
}

function toggleDisplay(elementId, status, disable = false) {
  const element = document.getElementById(elementId);

  if (disable) {
    element.style.disabled = disable;
  }
  else if (status) {
    element.style.display = 'block';
  }
  else {
    element.style.display = 'none';
  }
}
