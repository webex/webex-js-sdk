# @webex/plugin-meetings

[![standard-readme compliant](https://img.shields.io/badge/readme%20style-standard-brightgreen.svg?style=flat-square)](https://github.com/RichardLitt/standard-readme)

> Meetings plugin for the Cisco Webex JS SDK.

- [Install](#install)
- [Usage](#usage)
- [Development](#development)
- [Contribute](#contribute)
- [Maintainers](#maintainers)
- [License](#license)

# WARNING: This plugin is currently under active development, is not stable, and breaking changes can and will happen!

---

To create supported meetings and calls using Webex Teams, use [@webex/plugin-phone](https://www.npmjs.com/package/@webex/plugin-phone).

## Install

```bash
npm install --save @webex/plugin-meetings
```

## Usage

This is a plugin for the Cisco Webex JS SDK . Please see our [developer portal](https://developer.webex.com/sdks-and-widgets.html) and the [API docs](https://webex.github.io/webex-js-sdk/api/) for full details.

Examples

#### Creating a basic meeting

##### By conversation ID

```javascript
let convoId = `ObiwanAnnouncementsConversationUUID`;
return webex.meetings.create(convoId).then((meeting) ==> {...});
```

##### By SIP URI

```javascript
let sipUri = `obiwan@example.com`;
return webex.meetings.create(sipUri).then((meeting) ==> {...});
```

#### Joining a meeting

##### Default

```javascript
// TODO: list out the specific packages needed to just pull in plugin meetings instead of the full
// webex package?
import Webex as webex from 'webex';

let destination = `obiwan@example.com`;
let activeMeeting;

function setMedia(media){
  if (media.type === 'local') {
    document.getElementById('local-media').srcObject = media.stream;
  } else if (media.type === 'remote') {
    document.getElementById('remote-media').srcObject = media.stream;
  }
}

function handleAudioChange(audio){
  // perform some actions after audio has been muted/unmuted
}

function handleVideoChange(video) {
  // perform some action after video has been muted/unmuted
}

return webex.meetings
  .create(destination)
  .then((meeting) => {
    activeMeeting = meeting;

    activeMeeting.on('media:ready', () => setMedia));
    activeMeeting.on('media:audioChanged', handleAudioChange);
    activeMeeting.on('media:videoChanged', handleVideoChange);

    activeMeeting.join({resourceId: <DeviceId>});
  });
```

##### Joining a PMR

from above, we build off of the join...

###### joining your own claimed PMR

```javascript
...
meeting.join({resourceId: <DeviceId>}).then((res) => {
  // backend services determine you are the owner, so no hostpin, or intent is required
  // now you are in the meeting
});
...
```

###### joining someone elses claimed PMR

```javascript
...
// join as host (in place of them)
meeting.join({resourceId: <DeviceId>, hostPin: <WebexHostPin>, moderator: true}).then((res) => {
  // now you are in the meeting
});
```

```javascript
...
// join as attendee
meeting.join({resourceId: <DeviceId>, moderator: false}).then((res) => {
  // if host hasn't started the meeting, now you are in the lobby, else if host has started the meeting, you are in the meeting
});
```

###### joining an unclaimed PMR

```javascript
// join as host automatically
meeting.join({resourceId: <DeviceId>, hostPin: <WebexHostPin>, moderator: true}).then((res) => {
  // now you are in the meeting
});
```

```javascript
// join as host with ask user option
// join as attendee
meeting.join({resourceId: <DeviceId>}).then((res) => {
}).catch((err) => {
  if (err.joinIntentRequired) {
    // at this point you can ask the user to join as host or join as guest
    // if join as host, requires a pin
    ...
    // join as host simply makes the join call again with the proper hostpin/moderator parameters
    meeting.join({resourceId: <DeviceId>, hostPin: <WebexHostPin>, moderator: true}).then(() => {
      // you are now in the meeting
    });
    ...
    // join as guest simply makes the call again with moderator parameter
    meeting.join(({resourceId: <DeviceId>, moderator: false})).then(() => {
      // if host hasn't started the meeting, now you are in the lobby, else if host has started the meeting, you are in the meeting
    });
  }
});
```

#### Personal Meeting Room

##### Editing

```javascript
const link = ...; // a valid pmr link
const pin = ...; // a valid host pin assoicated to the link
// claiming a pmr, and updating the cached values for the stored PMR
webex.meetings.personalMeetingRoom.claim(link, pin).then((pmr) => {
  console.log(pmr); // do something else with the pmr
});
```

##### Getting

```javascript
webex.meetings.personalMeetingRoom.get().then((pmr) => {
  // do some stuff with the pmr values
  console.log(`PMR INFO:
      link-${webex.meetings.personalMeetingRoom.meetingLink}-
      uri-${webex.meetings.personalMeetingRoom.sipUri}-
      tollFree-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
      toll-${webex.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
      accessCode-${webex.meetings.personalMeetingRoom.pmr.meetingNumber}
      `);
});
```

#### Member

##### Properties
```javascript
member.participant ... // Object server participant object, advanced use only
member.id ... // String key for storing
member.name ... // String plain text name
member.isAudioMuted ... // Boolean
member.isVideoMuted ... // Boolean
member.isSelf ... // Boolean is this member YOUR user?
member.isHost ... // Boolean
member.isGuest ... // Boolean
member.isInLobby ... // Boolean
member.isInMeeting ... // Boolean
member.isNotAdmitted ... // Boolean -- waiting to be admitted to the meeting, will also have isInLobby true
member.isContentSharing ... // Boolean
member.status ... // String -- advanced use only
member.isDevice ... // Boolean
member.isUser ... // Boolean
member.associatedUser ... // String -- member.id if isDevice is true
member.isRecording ... // Boolean
// more coming...
```

#### Members
 You can access the members object on each individual meeting instance, it has some key events to listen to, and maintains what happens for members of a meeting with some key properties.

##### Properties
```javascript
meeting.members ...
meeting.members.membersCollection ... // the members collection, object {id0: member0, ... idN: memberN}
meeting.members.locusUrl ... // current locusUrl being used
meeting.members.hostId ... // active host id for the meeting
meeting.members.selfId ... // active self id for the meeting
meeting.members.mediaShareContentId ... // active content sharer id for the meeting
```

##### Functions
```javascript
// You can add a guest to the meeting by inviting them, this is proxied by meeting.invite
// use an emailAddress and a boolean value alertIfActive to notify server side (usually true)
meeting.members.addMember(emailAddress, alertIfActive)

// You can admit the guest to the meeting once they are waiting in the lobby, you can do this in bulk, proxied by meeting.admit
// use member ids, can be singular, but has to be put into an array
meeting.members.admitMembers([memberIds])
```

##### Events
```javascript
// members collection updated
meeting.members.on('members:update', (payload) => {
  const delta = payload.delta; // the changes to the members list
  const full = payload.full; // the full members collection
  const updated = delta.updated; // only the updates, includes removals, as they will have updated status and member properties
  const added = delta.added; // added members to the meeting
  Object.keys(full).forEach((key) => {
    const member = full[key];
    console.log(`Member: ... ${member.x}`);
  });
  Object.keys(updated).forEach((key) => {
    const member = updated[key];
    console.log(`Member Updated: ... ${member.x}`);
  });
  Object.keys(added).forEach((key) => {
    const member = added[key];
    console.log(`Member Added: ... ${member.x}`);
  });
});
// content updates
meeting.members.on('members:content:update', (payload) => {
  console.log(`who started sharing: ${payload.activeContentSharingId};`);
  console.log(`who stopped sharing: ${payload.endedContentSharingId};`);
});
// host updates
meeting.members.on('members:host:update', (payload) => {
  console.log(`who started hosting: ${payload.activeHostId};`);
  console.log(`who stopped hosting: ${payload.endedHostId};`);
})
// self updates, not typically used
meeting.members.on('members:self:update', (payload) => {
  console.log(`active self id: ${payload.activeSelfId};`);
  console.log(`ended self Id: ${payload.endedSelfId};`);
})
```

#### getStats

Note: accessor methods get are simply helpers, one can always use dot notation to work on the objects in the same way
Note: correlate values will be either 'audio', 'video', or 'share' for use with the default config (plugin-meeting's media)

##### Default configuration
```javascript
    // generate some IDs to use with the default configs
    const audioSenderId = '0';
    const audioReceiverId = '1';
    // for default configuration (using plugin-meetings media)
    const options = {
      useConfig: true, // inform to create using config
      senders: [
        { // audio sender object config option
          id: audioSenderId, // associate an id for later lookup
          correlate: 'audio', // NECESSARY KEY, see Note
          history: true, // optional extra, to track history on this sender's stats
          aggregator: true, // optional extra, to collect a summary of relevant data
          interval: true, // optional extra, to calculate the difference between this interval's data and last interval's data
          onData: (data) => { // callback for when filtered data comes through
            console.log('audioSender->', data);
          },
          onClose: (error) => { console.warn('audioSender->', error); }, // callback for when the stream closes for any reason
          onEvent: (event) => { console.log('audioSender->', event); } // callback for when triggered events come through the stream such as firstBytesSent
        }
      ],
      receivers: [
        { // audio receiver object config option
          id: audioReceiverId,
          correlate: 'audio',
          onData: (data) => { console.log('audioReceiver->', data); },
          onClose: (error) => { console.warn('audioReceiver->', error); },
          onEvent: (event) => { console.log('audioReceiver->', event); }
        }
      ]
    };

    // create the stats object using the options config, merged with the default config
    // pass true as the second option to override the previous stats object
    meeting.getStats(options, true);
```

##### Creating Without Configuration
```javascript
    const shareSenderId = '4';
    // notice no meeting is needed, and no correlate key is required, this is the manual builder method
    meeting
      .getStats()
      .addSenderStats(shareSenderId)
      .withHistory()
      .withAggregator()
      .withInterval()
      .withId(shareSenderId)
      .withName('shareSender')
      .withFilter(meeting.mediaProperties.peerConnection.shareTransceiver.sender, meeting.mediaProperties.peerConnection)
      .withEvents()
      .onData((data) => {
        console.log('shareSender->', data);
      })
      .onClose((error) => { console.warn('shareSender->', error); })
      .onEvent((event) => { console.log('shareSender->', event); })
      .build();
```

##### Creating Configurations On The Fly
```javascript
    const videoSenderId = '2';
    const videoReceiverId = '3';
    const shareReceiverId = '5';

    meeting.getStats().associateMeeting(meeting); // NECESSARY for adding senders/receivers dynamically AFTER getStats was previously created

    meeting.getStats().addSenders(
      [
        { // video receiver config object, using default config
          id: videoSenderId, // associate the ID
          correlate: 'video', // NECESSARY KEY
          onData: (data) => { console.log('videoSender->', data); },
          onClose: (error) => { console.warn('videoSender->', error); },
          onEvent: (event) => { console.log('videoSender->', event); }
        }
      ],
      true // using the default configuration afterwards when adding new stats
    );

    meeting.getStats().addReceivers(
      [
        {
          id: videoReceiverId,
          correlate: 'video', // NECESSARY KEY
          history: true,
          aggregator: true,
          interval: true,
          onData: (data) => { console.log('videoReceiver->', data); },
          onClose: (error) => { console.warn('videoReceiver->', error); },
          onEvent: (event) => { console.log('videoReceiver->', event); }
        }
      ],
      true
    );

    meeting.getStats().addReceiver({
      id: shareReceiverId,
      correlate: 'share', // NECESSARY KEY
      // history: true, // could add this
      // aggregator: true, // could add this
      // interval: true, // could add this
      onData: (data) => { console.log('shareReceiver->', data); },
      onClose: (error) => { console.warn('shareReceiver->', error); },
      onEvent: (event) => { console.log('shareReceiver->', event); }
    }, true);
```

##### Adding Configurations On The Fly

```javascript
// you can always add additional configurations later on based on events, or some timing, using the builder above
// say you created the object above with the options method, and you decided you wanted to add an aggregator to it
meeting
.getStats()
.getSender('0')
.withAggregator();
// and now you have an aggregator instance to work with on that sender stats object
```

##### Aggregator

```javascript
// note: using the aggregator is probably not necessary unless the WebRTC spec changes, or browsers change behavior and no longer automatically
// summarize their data
meeting
  .getStats() // get the stats instance on the meeting
  .getSender('0') // get the sender stats instance
  .getAggregator() // get the aggregator instance on that media stats
  // call any aggregator function
```

##### History

```javascript
meeting
  .getStats() // get the stats instance on the meeting
  .getSender('0') // get the sender stats instance
  .getHistory() // get the history instance on that media stats
  // call any history function
```

##### Interval

```javascript
meeting
  .getStats() // get the stats instance on the meeting
  .getSender('0') // get the sender stats instance
  .getInterval() // get the interval instance on that media stats
  // call any interval function
```

## Events

There are several events submitted by this package that you can subscribe to.
| Event Name | Description |
|---|---|
| `media:ready` | Fired when remote or local media has been acquired |
| `media:audioChanged` | Fired whenever local audio streams are muted and unmuted |
| `media:videoChanged` | Fired whenever local video streams are muted and unmuted |
| `media:stopped` | Fired when remote or local media has been torn down |
|---|---|
`media:ready` has the following format

```javascript
{
  type, // local or remote
    stream; // the MediaStream
}
```

`media:audioChanged` and `media:videoChanged` has the following format

```javascript
{
  type, // local or error
    status, // string representation of state
    muted, // boolean true or false for muted or not
    result; // the promise error or resolution value
}
```

`media:stopped` has the following format

```javascript
{
  type; // local or remote
}
```

`stats:update` has the following format

```javascript
{
  type, // local or remote
    key, // which key it matched, i.e., rtpOutAudio, etc, defined by DEFAULT_EVENT_VIDEO|AUDIO_RECEIVE|SEND_KEYS
    data, // the data at the point that the event was fired
    stat, // the accessor for the stat itself, i.e, bytesSent, bytesReceived
    id, // the id specified when creating the events instance
    kind; // audio or video
}
```

## Development

To use `webpack-dev-server` to load this package, run `npm run samples:serve`.

Files placed in the `packages/node_modules/samples/browser-plugin-meetings` folder will be served statically.

Files in the `src` folder will be compiled, bundled, and served as a static asset at `bundle.js` inside that directory.

## Maintainers

This package is maintained by [Cisco Webex for Developers](https://developer.webex.com/).

## Contribute

Pull requests welcome. Please see [CONTRIBUTING.md](https://github.com/webex/webex-js-sdk/blob/master/CONTRIBUTING.md) for more details.

## License

© 2016-2018 Cisco and/or its affiliates. All Rights Reserved.
