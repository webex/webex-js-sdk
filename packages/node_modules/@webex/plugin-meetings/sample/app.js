
/* eslint-env browser */

/* global window, ciscospark, spark */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let meeting, meetings, newMeeting, callTime;
const mediaSettings = [];
const audioInputSelect = document.querySelector('select#audioSource');
const audioOutputSelect = document.querySelector('select#audioOutput');
const videoSelect = document.querySelector('select#videoSource');

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token'
  // 'invitee'
].forEach((id) => {
  const el = document.getElementById(id);

  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

function connect() {
  if (!window.spark) {
    window.spark = ciscospark.init({
      config: {
        // Any other sdk config we need
      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  if (!spark.internal.device.registered) {
    spark.internal.device
      .register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add('listening');
        document.getElementById('connection-status').innerHTML = 'connected';

        // return this.spark.internal.device.register()
        return spark.internal.mercury.connect();
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }

  spark.meetings.on('meeting:added', (m) => {
    const {type} = m;

    if (type === 'INCOMING') {
      newMeeting = m.meeting;
      toggleDisplay('incomingsection', true);
      newMeeting.acknowledge(type);
      newMeeting.on('meeting:alerted', () => {
        document.getElementById('alerted-call').innerHTML = 'locus notified that user received call';
      });
      newMeeting.on('meeting:ringing', (e) => {
        if (e.ringing) {
          document.getElementById('ringing-call').innerHTML = 'incoming call';
        }
        else if (!e.ringing) {
          document.getElementById('ringing-call').innerHTML = '';
        }
      });
    }

    const ul = document.getElementById('meeting-list');


    while (ul.firstChild) {
      ul.removeChild(ul.firstChild);
    }
    const allMeeting = spark.meetings.getAllMeetings();

    Object.keys(allMeeting).forEach((key) => {
      const li = document.createElement('li');
      const button = document.createElement('button');

      li.appendChild(document.createTextNode(allMeeting[key].sipUri));
      li.appendChild(document.createTextNode(`${allMeeting[key].type}`));
      button.appendChild(document.createTextNode('JOIN'));
      button.value = allMeeting[key].sipUri;
      button.onclick = () => {
        joinWithObtp(allMeeting[key]);
      };
      li.appendChild(button);
      ul.appendChild(li);
    });
    console.log('Meeting added ', m);
  });

  spark.meetings.on('meeting:removed', (m) => {
    newMeeting = undefined;
    if (meeting && m.meetingId === meeting.id) {
      meeting = undefined;
    }
    toggleDisplay('incomingsection', false);
    console.log('Meeting removed ', m);
  });
}

function joinWithObtp(obtpMeeting) {
  // Clean Previous meeting and end
  // Meeting already created we just need to do join and add Media
  console.log(obtpMeeting.sipUri);
  startMeeting(obtpMeeting);
  obtpMeeting.join()
    .then(() => {
      addMedia(obtpMeeting);
    });
}

function cleanUp() {
  if (meeting && meeting.mediaProperties.localStream) {
    meeting.mediaProperties.localStream.getTracks().forEach((track) => {
      track.stop();
    });
  }

  document.getElementById('time').innerHTML = 0;
  document.getElementById('remotevideo').srcObject = null;
}

function addMedia(meeting) {
  document.getElementsByName('mediadirection').forEach((options) => {
    mediaSettings[options.value] = options.checked;
  });

  // use meeting proxy wrapper to media util
  return meeting.getMediaStreams(mediaSettings)
    .then(([localStream, localShare]) => meeting.addMedia({
      mediaSettings,
      localStream,
      localShare
    }));
}

function disconnect() {
  if (!spark || !spark.internal || !spark.internal.device) {
    return Promise.reject(new Error('You must have a proper spark intstance to disconnect'));
  }
  if (spark.internal.device.registered) {
    return spark.internal.mercury.disconnect().then(() => spark.internal.device.unregister().then(() => {
      document.getElementById('connection-status').innerHTML = 'disconnected';

      return Promise.resolve();
    }));
  }

  return Promise.resolve();
}

function getMemberNameString(participant) {
  if (participant) {
    if (participant.person) {
      return `${participant.person.email}`;
    }
  }

  return 'emptyEmail';
}

function getMemberValueString(member) {
  return `
  self: ${member.isSelf},
  host: ${member.isHost},
  guest: ${member.isGuest},
  audio: ${member.isAudioMuted},
  video: ${member.isVideoMuted},
  meeting: ${member.isInMeeting},
  not: ${!member.isInMeeting},
  waitingAdmit: ${member.isNotAdmitted},
  screen: ${member.isContentSharing},
  status: ${member.status},
  device: ${member.isDevice},
  user: ${member.isUser}
  id: ${member.id}
  `;
}

// Attach audio output device to video element using device/sink ID.
function attachSinkId(element, sinkId) {
  if (typeof element.sinkId !== 'undefined') {
    element.setSinkId(sinkId)
      .then(() => {
        console.log(`Success, audio output device attached: ${sinkId}`);
      })
      .catch((error) => {
        let errorMessage = error;

        if (error.name === 'SecurityError') {
          errorMessage = `You need to use HTTPS for selecting audio output device: ${error}`;
        }
        console.error(errorMessage);
        // Jump back to first output device in the list as it's the default.
        audioOutputSelect.selectedIndex = 0;
      });
  }
  else {
    console.warn('Browser does not support output device selection.');
  }
}

function startMeeting(m) {
  meeting = m;
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = media.stream;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remotevideo').srcObject = media.stream;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remoteaudio').srcObject = media.stream;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = media.stream;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = media.stream;
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = null;
    }
    if (media.type === 'remoteVideo') {
      document.getElementById('remotevideo').srcObject = null;
    }
    if (media.type === 'remoteAudio') {
      document.getElementById('remoteaudio').srcObject = null;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = null;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = null;
    }
  });
}

function addData(chart, dataSet, data) {
  chart.data.datasets[dataSet].data.push(data);
  chart.update();
}

function removeData(chart) {
  chart.data.labels.splice(0, 1);
  chart.data.datasets.forEach((dataset) => {
    dataset.data.splice(0, 1);
  });
  chart.update();
}

window.addEventListener('unload', disconnect, false);

// In order to simplify the state management needed to keep track of our button
// handlers, we'll rely on the current call global object and only hook up event
// handlers once.

audioOutputSelect.onchange = function () {
  attachSinkId(document.getElementById('remoteaudio'), audioOutputSelect.value);
};

document.getElementById('getDevices').addEventListener('click', () => {
  const selectors = [audioInputSelect, audioOutputSelect, videoSelect];

  meeting.getDevices().then((deviceInfos) => {
    const values = selectors.map((select) => select.value);

    selectors.forEach((select) => {
      while (select.firstChild) {
        select.removeChild(select.firstChild);
      }
    });
    for (let i = 0; i !== deviceInfos.length; i += 1) {
      const deviceInfo = deviceInfos[i];
      const option = document.createElement('option');

      option.value = deviceInfo.deviceId;
      if (deviceInfo.kind === 'audioinput') {
        option.text = deviceInfo.label || `microphone ${audioInputSelect.length + 1}`;
        audioInputSelect.appendChild(option);
      }
      else if (deviceInfo.kind === 'audiooutput') {
        option.text = deviceInfo.label || `speaker ${audioOutputSelect.length + 1}`;
        audioOutputSelect.appendChild(option);
      }
      else if (deviceInfo.kind === 'videoinput') {
        option.text = deviceInfo.label || `camera ${videoSelect.length + 1}`;
        videoSelect.appendChild(option);
      }
      else {
        console.log('Some other kind of source/device: ', deviceInfo);
      }
    }
    selectors.forEach((select, selectorIndex) => {
      if (Array.prototype.slice.call(select.childNodes).some((n) => n.value === values[selectorIndex])) {
        select.value = values[selectorIndex];
      }
    });
  });
});


document.getElementById('updateVideo').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  meeting.getMediaStreams({sendVideo: true}, {video: {deviceId: {exact: videoSelect.value}}})
    .then(([localStream]) => meeting.updateVideo({
      stream: localStream,
      sendVideo: media.sendVideo,
      receiveVideo: media.receiveAudio
    }));
});

document.getElementById('updateAudio').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  meeting.getMediaStreams(media, {audio: {deviceId: {exact: audioInputSelect.value}}})
    .then(([localStream]) => meeting.updateAudio({
      stream: localStream,
      sendAudio: media.sendAudio,
      receiveAudio: media.receiveAudio
    }));
});

document.getElementById('updateShare').addEventListener('click', () => {
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  meeting.getMediaStreams({sendShare: media.sendShare})
    .then((response) => meeting.updateShare({
      stream: response[1],
      sendShare: media.sendShare,
      receiveShare: media.receiveShare
    }));
});


document.getElementById('updateMedia').addEventListener('click', () => {
  const audio = {};
  const video = {};
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  audio.deviceId = {exact: audioInputSelect.value};
  video.deviceId = {exact: videoSelect.value};
  console.log(`audioDeviceId: ${audio.deviceId.exact}`);
  console.log(`videoDeviceId ${video.deviceId.exact}`);
  meeting.getMediaStreams(media, {audio, video})
    .then(([localStream, localShare]) => meeting.updateMedia({
      mediaSettings: media,
      localStream,
      localShare
    }));
});

document.getElementById('addDevicesMedia').addEventListener('click', () => {
  const audio = {};
  const video = {};
  const media = {};

  document.getElementsByName('mediadirection').forEach((options) => {
    media[options.value] = options.checked;
  });
  audio.deviceId = {exact: audioInputSelect.value};
  video.deviceId = {exact: videoSelect.value};
  console.log(`audioDeviceId: ${audio.deviceId.exact}`);
  console.log(`videoDeviceId ${video.deviceId.exact}`);
  meeting.getMediaStreams(media, {audio, video})
    .then(([localStream, localShare]) => meeting.addMedia({
      mediaSettings: media,
      localStream,
      localShare
    }));
});

document.getElementById('meetings-object').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
});

document.getElementById('reachability').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
  spark.meetings.setReachability();
  spark.meetings.startReachability();
});

document.getElementById('syncMeeting').addEventListener('click', () => {
  spark.meetings.syncMeetings();
});

document.getElementById('leave').addEventListener('click', () => {
  cleanUp();
  if (meeting) {
    meeting.leave();
  }
  toggleDisplay('incomingsection', false);
});

document.getElementById('start-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteAudio()
      .then((res) => {
        console.log('audio unmute resolved', res);
      })
      .catch((rej) => {
        console.log('audio unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteAudio()
      .then((res) => {
        console.log('audio mute resolved', res);
      })
      .catch((rej) => {
        console.log('audio mute rejected', rej);
      });
  }
});

document.getElementById('start-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteVideo()
      .then((res) => {
        console.log('video unmute resolved', res);
      })
      .catch((rej) => {
        console.log('video unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteVideo()
      .then((res) => {
        console.log('video mute resolved', res);
      })
      .catch((rej) => {
        console.log('video mute rejected', rej);
      });
  }
});
document.getElementById('start-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingAudio();
  }
});

document.getElementById('stop-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingAudio();
  }
});

document.getElementById('start-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingVideo();
  }
});

document.getElementById('stop-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingVideo();
  }
});

document.getElementById('charting').addEventListener('click', () => {
  const ctx = document.getElementById('myChart').getContext('2d');
  const chart = new Chart(ctx, { // eslint-disable-line
    // The type of chart we want to create
    type: 'line',
    options: {
      title: {
        display: true,
        text: 'Time Series'
      },
      elements: {
        line: {
          tension: 0 // disables bezier curves
        }
      },
      scales: {
        yAxes: [{
          id: 'left-y-axis',
          type: 'linear',
          position: 'left'
        }, {
          id: 'right-y-axis',
          type: 'linear',
          position: 'right'
        }]
      }
    },
    // The data for our dataset
    data: {
      datasets: [
        {
          label: 'bytesSent',
          backgroundColor: 'rgb(255, 99, 132)',
          borderColor: 'rgb(255, 99, 132)',
          fill: false,
          yAxisID: 'left-y-axis'
        },
        {
          label: 'packetsSent',
          backgroundColor: 'rgb(0, 0, 255)',
          borderColor: 'rgb(0, 0, 255)',
          fill: false,
          yAxisID: 'right-y-axis'
        }
      ]
    }
  });

  const ctx2 = document.getElementById('myChart2').getContext('2d');
  const chart2 = new Chart(ctx2, { // eslint-disable-line
    // The type of chart we want to create
    type: 'line',
    options: {
      title: {
        display: true,
        text: 'Time Series'
      },
      elements: {
        line: {
          tension: 0 // disables bezier curves
        }
      },
      scales: {
        yAxes: [{
          id: 'left-y-axis',
          type: 'linear',
          position: 'left'
        }]
      }
    },
    // The data for our dataset
    data: {
      datasets: [
        {
          label: 'bytesReceived',
          backgroundColor: 'rgb(255, 99, 132)',
          borderColor: 'rgb(255, 99, 132)',
          fill: false,
          yAxisID: 'left-y-axis'
        }
      ]
    }
  });

  let i = 0;
  let j = 0;

  document.getElementById('addChartData').addEventListener('click', () => {
    meeting.getStats().getSender('0').getAnalyzer().on('ANALYSIS_GRAPH', (data) => {
      chart.data.labels.push(i);
      addData(chart, 0, data.bytesSent);
      addData(chart, 1, data.packetsSent);
      if (i > 30) {
        removeData(chart);
      }
      i += 1;
    });
    meeting.getStats().getReceiver('1').getAnalyzer().on('ANALYSIS_GRAPH', (data) => {
      chart2.data.labels.push(j);
      addData(chart2, 0, data.bytesReceived);
      if (j > 30) {
        removeData(chart2);
      }
      j += 1;
    });
  });
});

document.getElementById('getStats').addEventListener('click', () => {
  if (meeting) {
    const audioSenderId = '0';
    const audioReceiverId = '1';
    const videoSenderId = '2';
    const videoReceiverId = '3';
    const shareSenderId = '4';
    const shareReceiverId = '5';

    const options = {
      useConfig: true,
      senders: [
        {
          id: audioSenderId,
          correlate: 'audio', // NECESSARY KEY
          history: true,
          aggregator: true,
          interval: true,
          analyzer: {properties: ['bytesSent', 'packetsSent'], interval: 3}, // override
          onData: (data) => {
            console.log('audioSender->', data);
          },
          onClose: (error) => {
            console.warn('audioSender->', error);
          },
          onEvent: (event) => {
            console.error('audioSender->', event);
          }
        }
      ],
      receivers: [
        {
          id: audioReceiverId,
          correlate: 'audio', // NECESSARY KEY
          analyzer: true, // default config
          onData: (data) => { console.log('audioReceiver->', data); },
          onClose: (error) => { console.warn('audioReceiver->', error); },
          onEvent: (event) => { console.error('audioReceiver->', event); }
        }
      ]
    };

    meeting.getStats(options, true);

    meeting.getStats().getSender('0').getAnalyzer().on('ANALYSIS_FAILURE', (payload) => {
      console.error('meeting analyzer failed', payload);
    });

    meeting.getStats().getReceiver('1').getAnalyzer().on('ANALYSIS_FAILURE', (payload) => {
      console.error('meeting analyzer failed', payload);
    });

    // notice no meeting is needed, and no correlate key is required, this is the manual builder method
    meeting
      .getStats()
      .addSenderStats(shareSenderId)
      .withHistory()
      .withAggregator()
      .withInterval()
      .withId(shareSenderId)
      .withName('shareSender')
      .withFilter(meeting.mediaProperties.peerConnection.shareTransceiver.sender, meeting.mediaProperties.peerConnection)
      .withEvents()
      .onData((data) => {
        console.log('shareSender->', data);
      })
      .onClose((error) => { console.warn('shareSender->', error); })
      .onEvent((event) => { console.error('shareSender->', event); })
      .build();

    meeting.getStats().associateMeeting(meeting); // NECESSARY for adding senders dynamically

    meeting.getStats().addSenders(
      [
        {
          id: videoSenderId,
          correlate: 'video', // NECESSARY KEY
          onData: (data) => { console.log('videoSender->', data); },
          onClose: (error) => { console.warn('videoSender->', error); },
          onEvent: (event) => { console.error('videoSender->', event); }
        }
      ],
      true
    );

    meeting.getStats().addReceivers(
      [
        {
          id: videoReceiverId,
          correlate: 'video', // NECESSARY KEY
          history: true,
          aggregator: true,
          interval: true,
          onData: (data) => { console.log('videoReceiver->', data); },
          onClose: (error) => { console.warn('videoReceiver->', error); },
          onEvent: (event) => { console.error('videoReceiver->', event); }
        }
      ],
      true
    );

    meeting.getStats().addReceiver({
      id: shareReceiverId,
      correlate: 'share', // NECESSARY KEY
      // history: true,
      // aggregator: true,
      // interval: true,
      onData: (data) => { console.log('shareReceiver->', data); },
      onClose: (error) => { console.warn('shareReceiver->', error); },
      onEvent: (event) => { console.error('shareReceiver->', event); }
    }, true);
  }
});

document.getElementById('destroyStats').addEventListener('click', () => {
  if (meeting) {
    meeting.stopStats();
  }
});

document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();
  connect();
});

document.getElementById('disconnect').addEventListener('submit', (event) => {
  event.preventDefault();
  disconnect();
});

document.getElementById('scheduled-meetings').addEventListener('submit', (event) => {
  document.getElementById('scheduled-meetings-div').innerHTML = '';
  event.preventDefault();

  return spark.internal.calendar.list({max: 200}).then((meetings) => {
    Object.keys(meetings).forEach((key) => {
      const entry = meetings[key];

      document.getElementById('scheduled-meetings-div').innerHTML += `-- ${entry.encryptedSubject} < | > ${entry.start} --`;
    });
  });
});

document.getElementById('scheduled-meetings-events').addEventListener('submit', (event) => {
  event.preventDefault();
  spark.internal.mercury.on('event:calendar.meeting.create', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.create.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.update', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.update.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.delete', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--DELETED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
});

document.getElementById('PMR').addEventListener('submit', (event) => {
  event.preventDefault();

  return spark.meetings.personalMeetingRoom.get().then((pmr) => {
    console.log(pmr);
    document.getElementById('pmr-info').innerHTML = `PMR INFO: 
      link-${spark.meetings.personalMeetingRoom.meetingLink}-
      uri-${spark.meetings.personalMeetingRoom.sipUri}-
      tollFree-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
      toll-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
      accessCode-${spark.meetings.personalMeetingRoom.pmr.meetingNumber}
      `;
  });
});

document.getElementById('PMR-edit').addEventListener('submit', (event) => {
  event.preventDefault();
  const pmrLink = document.getElementById('wbx-pmr-link').value;
  const hostPin = document.getElementById('wbx-pmr-host-pin').value;

  if (!pmrLink && !hostPin) {
    return;
  }
  spark.meetings.personalMeetingRoom.claim(pmrLink, hostPin).then((claimed) => {
    console.log(claimed);
    document.getElementById('pmr-edit-info').innerHTML = `PMR INFO: 
    link-${spark.meetings.personalMeetingRoom.meetingLink}-
    uri-${spark.meetings.personalMeetingRoom.sipUri}-
    tollFree-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
    toll-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
    accessCode-${spark.meetings.personalMeetingRoom.pmr.meetingNumber}
    `;
  }).catch((err) => {
    console.error(err);
  });
});

document.getElementById('invite-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.invite({emailAddress: document.getElementById('invite-invitee').value}).then((res) => {
    console.log(res);
  });
});

document.getElementById('admit-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.admit([document.getElementById('admit-invitee').value]).then((res) => {
    console.log(res);
  });
});

// And finally, let's wire up dialing
document.getElementById('dialer').addEventListener('submit', (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();
  spark.meetings.create(document.getElementById('invitee').value)
    .then((m) => {
      console.log(m);
      startMeeting(m);
    });
});

document.getElementById('reconnect-button').addEventListener('click', () => {
  meeting.reconnect();
});

// And finally, let's wire up dialing
// document.getElementById('getmedia').addEventListener('click', () => {
//   // again, we don't want to reload when we try to dial
//   // const streams = media.getUserMedia();
//   return media.getUser();
// });
// And finally, let's wire up dialing
document.getElementById('join').addEventListener('click', () => {
  // TODO: add resource id if paired
  let deviceId;

  if (spark.devicemanager && spark.devicemanager._pairedDevice) {
    deviceId = spark.devicemanager._pairedDevice.identity.id;
  }
  const pin = document.getElementById('hostPin-join').value;
  let hostPin;

  if (pin) {
    hostPin = Number(pin);
  }
  const moderator = document.getElementById('moderator-join').checked;

  meeting.join({resourceId: deviceId, hostPin, moderator})
    .then((res) => {
      console.log('Succesful join, res: ', res);
    }).catch((err) => {
      handleJoinIntent(err, meeting, deviceId);
    });

  meeting.on('meeting:self:lobbyWaiting', () => {
    document.getElementById('lobby-space').innerHTML = 'User is guest to space, waiting to be admitted, wait to use addMedia';
  });

  meeting.on('meeting:self:guestAdmitted', () => {
    document.getElementById('lobby-space').innerHTML = 'Admitted to meeting as guest to call.';
  });

  meeting.on('meeting:reconnectionStarting', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnecting in progress';
  });

  meeting.on('meeting:reconnectionSuccess', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection success';
    setTimeout(() => { document.getElementById('reconnection-status').innerHTML = ''; }, 5000);
  });

  meeting.on('meeting:reconnectionFailure', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection failure';
  });

  const lastFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;

  callTime = Date.now();
  let safteyTimeout = null;
  const videoRenderInterval = setInterval(() => {
    const currentFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;

    if (currentFrameCount > 0 && currentFrameCount !== lastFrameCount) {
      const current = Date.now();

      console.log('Received remote stream');
      if (callTime) {
        callTime = current - callTime;
        document.getElementById('time').innerHTML = callTime / 1000;
        callTime = null;
        clearInterval(videoRenderInterval);
        clearTimeout(safteyTimeout);
      }
    }
  }, 500);

  safteyTimeout = setTimeout(() => {
    clearInterval(videoRenderInterval);
  }, 15000);

  meeting.members.on('members:update', (delta) => {
    let updateString = '';
    let addedString = '';
    let memberString = '';
    const things = delta.delta;
    const {full} = delta;

    // if kitchen sink was more sophistciated we would re render participants only, or render new as necessary
    Object.keys(full).forEach((key) => {
      const member = full[key];

      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
    const {updated} = things;
    const {added} = things;

    Object.keys(updated).forEach((key) => {
      const member = updated[key];

      updateString += `Member Updated: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    Object.keys(added).forEach((key) => {
      const member = added[key];

      addedString += `Member Added: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participant-updates').innerHTML = `LAST MEMBERS DELTA: -- MEMBERS UPDATES: ${updateString} -- MEMBERS ADDED: ${addedString}`;
  });

  meeting.members.on('members:content:update', (payload) => {
    console.log(`who started sharing: ${payload.activeContentSharingId};`);
    console.log(`who stopped sharing: ${payload.endedContentSharingId};`);
    const members = meeting.members.membersCollection.getAll();
    let memberString = '';

    Object.keys(members).forEach((key) => {
      const member = members[key];

      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
  });
});

document.getElementById('addMedia').addEventListener('click', () => {
  addMedia(meeting);
});

document.getElementById('incoming-media').addEventListener('click', () => {
  addMedia(meeting);
  toggleDisplay('incomingsection', false);
});

document.getElementById('wirelessShare').addEventListener('click', () => {
  event.preventDefault();
  const deviceId = spark.devicemanager._pairedDevice.identity.id;

  // deviceId is the destination to do the share
  return spark.meetings.create(deviceId).then((m) => {
    console.log(m);
    startMeeting(m);

    return meeting.join({
      resourceId: deviceId
    })
      .then(() => meeting.getMediaStreams({
        sendAudio: false,
        sendVideo: false,
        sendShare: true
      }))
      .then(([localStream, localShare]) =>
        meeting.addMedia({
          mediaSettings: {
            sendAudio: false,
            sendVideo: false,
            sendShare: true,
            receiveShare: false,
            receiveAudio: false,
            receiveVideo: false
          },
          localShare,
          localStream
        }))
      .catch((e) => {
        meeting.leave();
        console.error('Error wiresless screen sharing', e);
      });
  });
});

document.getElementById('stopWirelessShare').addEventListener('click', () => {
  meeting.leave();
});

document.getElementById('answer').addEventListener('click', () => {
  meeting = newMeeting;
  startMeeting(meeting);
  newMeeting.join().then(() => {
    newMeeting.acknowledge('ANSWER', false);
  });
  toggleDisplay('answer', true, true);
  toggleDisplay('reject', true, true);
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
});

document.getElementById('reject').addEventListener('click', () => {
  meeting = newMeeting;
  meeting.decline('BUSY');
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
});

function handleJoinIntent(err, meeting, deviceId) {
  if (err.joinIntentRequired) {
    toggleDisplay('joinAsHostOrGuest', true);
    // memory/event leak, can also wait for triggered event
    // meeting.on('lobby:hostOrGuest'...
    document.getElementById('joinAsHost').addEventListener('click', () => {
      const pin = document.getElementById('hostPin-join').value;
      let hostPin;

      if (pin) {
        hostPin = Number(pin);
      }
      const moderator = document.getElementById('moderator-join').checked;

      meeting.join({resourceId: deviceId, hostPin, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
    document.getElementById('joinAsGuest').addEventListener('click', () => {
      const moderator = document.getElementById('moderator-join').checked;

      meeting.join({resourceId: deviceId, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
  }
}

function toggleDisplay(elementId, status, disable = false) {
  const element = document.getElementById(elementId);

  if (disable) {
    element.style.disabled = disable;
  }
  else if (status) {
    element.style.display = 'block';
  }
  else {
    element.style.display = 'none';
  }
}
