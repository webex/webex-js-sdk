
/* eslint-env browser */

/* global ciscospark, spark */

/* eslint-disable camelcase */
/* eslint-disable max-nested-callbacks */
/* eslint-disable no-alert */
/* eslint-disable no-console */
/* eslint-disable require-jsdoc */

// Declare some globals that we'll need throughout
let meeting, meetings, newMeeting, callTime;
const mediaSettings = [];

// First, let's wire our form fields up to localStorage so we don't have to
// retype things everytime we reload the page.

[
  'access-token'
  // 'invitee'
].forEach((id) => {
  const el = document.getElementById(id);
  el.value = localStorage.getItem(id);
  el.addEventListener('change', (event) => {
    localStorage.setItem(id, event.target.value);
  });
});

function connect() {
  if (!window.spark) {
    window.spark = ciscospark.init({
      config: {
        // Any other sdk config we need
      },
      credentials: {
        access_token: document.getElementById('access-token').value
      }
    });
  }

  if (!spark.internal.device.registered) {
    spark.internal.device
      .register()
      .then(() => {
        // This is just a little helper for our selenium tests and doesn't
        // really matter for the example
        document.body.classList.add('listening');
        document.getElementById('connection-status').innerHTML = 'connected';
        // return this.spark.internal.device.register()
        return spark.internal.mercury.connect();
      })
      // This is a terrible way to handle errors, but anything more specific is
      // going to depend a lot on your app
      .catch((err) => {
        console.error(err);
        // we'll rethrow here since we didn't really *handle* the error, we just
        // reported it
        throw err;
      });
  }

  spark.meetings.on('meeting:added', (m) => {
    const type = m.type;
    if (type === 'INCOMING') {
      newMeeting = m.meeting;
      toggleDisplay('incomingsection', true);
      newMeeting.acknowledge(type);
      newMeeting.on('meeting:alerted', () => {
        document.getElementById('alerted-call').innerHTML = 'locus notified that user received call';
      });
      newMeeting.on('meeting:ringing', (e) => {
        if (e.ringing) {
          document.getElementById('ringing-call').innerHTML = 'incoming call';
        }
        else if (!e.ringing) {
          document.getElementById('ringing-call').innerHTML = '';
        }
      });
    }

    const ul = document.getElementById('meeting-list');


    while (ul.firstChild) {
      ul.removeChild(ul.firstChild);
    }
    const allMeeting = spark.meetings.getAll();

    Object.keys(allMeeting).forEach((key) => {
      const li = document.createElement('li');
      const button = document.createElement('button');
      li.appendChild(document.createTextNode(allMeeting[key].sipUri));
      li.appendChild(document.createTextNode(`${allMeeting[key].type}`));
      button.appendChild(document.createTextNode('JOIN'));
      button.value = allMeeting[key].sipUri;
      button.onclick = () => {
        joinWithObtp(allMeeting[key]);
      };
      li.appendChild(button);
      ul.appendChild(li);
    });
    console.log('Meeting added ', m);
  });

  spark.meetings.on('meeting:removed', (m) => {
    newMeeting = undefined;
    toggleDisplay('incomingsection', false);
    console.log('Meeting removed ', m);
  });
}

function joinWithObtp(obtpMeeting) {
  // Clean Previous meeting and end
  // Meeting already created we just need to do join and add Media
  console.log(obtpMeeting.sipUri);
  startMeeting(obtpMeeting);
  obtpMeeting.join()
    .then(() => {
      addMedia(obtpMeeting);
    });
}

function cleanUp() {
  if (meeting.mediaProperties.localStream) {
    meeting.mediaProperties.localStream.getTracks().forEach((track) => {
      track.stop();
    });
  }

  document.getElementById('time').innerHTML = 0;
  document.getElementById('remotevideo').srcObject = null;
}

function addMedia(meeting) {
  document.getElementsByName('mediadirection').forEach((options) => {
    mediaSettings[options.value] = options.checked;
  });

  // use meeting proxy wrapper to media util
  return meeting.getMediaStreams(mediaSettings)
    .then(([localStream, localShare]) => meeting.addMedia({
      mediaSettings,
      localStream,
      localShare
    })
      .then(() => {
        if (mediaSettings.sendShare && localShare) {
          meeting.share();
        }
      }));
}

function disconnect() {
  if (!spark || !spark.internal || !spark.internal.device) {
    return Promise.reject(new Error('You must have a proper spark intstance to disconnect'));
  }
  if (spark.internal.device.registered) {
    return spark.internal.mercury.disconnect().then(() => spark.internal.device.unregister().then(() => {
      document.getElementById('connection-status').innerHTML = 'disconnected';
      return Promise.resolve();
    }));
  }
  return Promise.resolve();
}

function getMemberNameString(participant) {
  if (participant) {
    if (participant.person) {
      return `${participant.person.email}`;
    }
  }
  return 'emptyEmail';
}

function getMemberValueString(member) {
  return `
  self: ${member.isSelf},
  host: ${member.isHost},
  guest: ${member.isGuest},
  audio: ${member.isAudioMuted},
  video: ${member.isVideoMuted},
  meeting: ${member.isInMeeting},
  not: ${member.isNotInMeeting},
  waitingAdmit: ${member.isNotAdmitted},
  screen: ${member.isContentSharing},
  status: ${member.status},
  device: ${member.isDevice},
  user: ${member.isUser}
  id: ${member.id}
  `;
}

function startMeeting(m) {
  meeting = m;
  meeting.on('media:ready', (media) => {
    if (!media) {
      return;
    }
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = media.stream;
    }
    if (media.type === 'remote') {
      document.getElementById('remotevideo').srcObject = media.stream;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = media.stream;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = media.stream;
    }
  });
  meeting.on('media:stopped', (media) => {
    if (media.type === 'local') {
      document.getElementById('localvideo').srcObject = null;
    }
    if (media.type === 'remote') {
      document.getElementById('remotevideo').srcObject = null;
    }
    if (media.type === 'localShare') {
      document.getElementById('localshare').srcObject = null;
    }
    if (media.type === 'remoteShare') {
      document.getElementById('sharevideo').srcObject = null;
    }
  });
}

window.addEventListener('unload', disconnect, false);

// In order to simplify the state management needed to keep track of our button
// handlers, we'll rely on the current call global object and only hook up event
// handlers once.

document.getElementById('meetings-object').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
});

document.getElementById('reachability').addEventListener('click', () => {
  if (meetings) {
    console.info(meetings);
  }
  spark.meetings.getReachability();
});

document.getElementById('syncMeeting').addEventListener('click', () => {
  spark.meetings.syncMeetings();
});

document.getElementById('leave').addEventListener('click', () => {
  cleanUp();
  if (meeting) {
    meeting.leave();
  }
  toggleDisplay('incomingsection', false);
});

document.getElementById('start-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteAudio()
      .then((res) => {
        console.log('audio unmute resolved', res);
      })
      .catch((rej) => {
        console.log('audio unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-audio').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteAudio()
      .then((res) => {
        console.log('audio mute resolved', res);
      })
      .catch((rej) => {
        console.log('audio mute rejected', rej);
      });
  }
});

document.getElementById('start-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .unmuteVideo()
      .then((res) => {
        console.log('video unmute resolved', res);
      })
      .catch((rej) => {
        console.log('video unmute rejected', rej);
      });
  }
});

document.getElementById('stop-sending-video').addEventListener('click', () => {
  if (meeting) {
    meeting
      .muteVideo()
      .then((res) => {
        console.log('video mute resolved', res);
      })
      .catch((rej) => {
        console.log('video mute rejected', rej);
      });
  }
});
document.getElementById('start-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingAudio();
  }
});

document.getElementById('stop-receiving-audio').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingAudio();
  }
});

document.getElementById('start-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.startReceivingVideo();
  }
});

document.getElementById('stop-receiving-video').addEventListener('click', () => {
  if (meeting) {
    meeting.stopReceivingVideo();
  }
});

document.getElementById('getStatsRaw').addEventListener('click', () => {
  if (meeting) {
    meeting
      .getStats()
      .withId()
      .withMedia()
      .build()
      .getMedia()
      .withId()
      .withStream(meeting.mediaProperties.mediaPeerConnection)
      .build()
      .getStream()
      .on('data', (raw) => {
        console.log(raw);
      });
  }
});

document.getElementById('getStatsFilter').addEventListener('click', () => {
  if (meeting) {
    // meeting
    //   .getStats()
    //   .withMedia()
    //   .build()
    //   .getMedia()
    //   .withId()
    //   .withEvents()
    //   .withHistory()
    //   .withAggregator()
    //   .withInterval()
    //   .withFilter(meeting.mediaProperties.mediaPeerConnection)
    //   .build()
    //   .onData((filtered) => {
    //     console.log(filtered);
    //   });
    // OR
    // const stats = meeting.getStats().withId().withMedia().build();
    // const media = stats.getMedia()...
    // media.doData((filtered) => {
    //  do stuff
    // })
    // OR
    meeting.getStats({
      media: {
        id: true,
        history: true,
        interval: true,
        aggregator: true,
        filter: meeting.mediaProperties.mediaPeerConnection,
        events: true
      }
    });
    meeting
      .getStats()
      .getMedia()
      .onData((filtered) => {
        console.log(filtered);
      });
    meeting
      .getStats()
      .getMedia()
      .getEvents()
      .on('stats:update', (stats) => {
        console.log(stats);
      });
  }
});

document.getElementById('getAggregation').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getAggregator()
        .get()
    );
  }
});

document.getElementById('getHistory').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getHistory()
        .get()
    );
  }
});

document.getElementById('getInterval').addEventListener('click', () => {
  if (meeting) {
    console.log(
      meeting
        .getStats()
        .getMedia()
        .getInterval()
        .get()
    );
  }
});

document.getElementById('credentials').addEventListener('submit', (event) => {
  // let's make sure we don't reload the page when we submit the form
  event.preventDefault();
  connect();
});

document.getElementById('disconnect').addEventListener('submit', (event) => {
  event.preventDefault();
  disconnect();
});

document.getElementById('scheduled-meetings').addEventListener('submit', (event) => {
  document.getElementById('scheduled-meetings-div').innerHTML = '';
  event.preventDefault();
  return spark.internal.calendar.list({max: 200}).then((meetings) => {
    Object.keys(meetings).forEach((key) => {
      const entry = meetings[key];
      document.getElementById('scheduled-meetings-div').innerHTML += `-- ${entry.encryptedSubject} < | > ${entry.start} --`;
    });
  });
});

document.getElementById('scheduled-meetings-events').addEventListener('submit', (event) => {
  event.preventDefault();
  spark.internal.mercury.on('event:calendar.meeting.create', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.create.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--CREATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.update', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.update.minimal', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--UPDATED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | >  ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
  spark.internal.mercury.on('event:calendar.meeting.delete', (scheduledMeeting) => {
    document.getElementById('scheduled-meeting-events-p').innerHTML += `--DELETED: ${scheduledMeeting.data.calendarMeetingExternal.encryptedSubject} < | > ${scheduledMeeting.data.calendarMeetingExternal.start} --`;
  });
});

document.getElementById('PMR').addEventListener('submit', (event) => {
  event.preventDefault();
  return spark.meetings.personalMeetingRoom.get().then((pmr) => {
    console.log(pmr);
    document.getElementById('pmr-info').innerHTML = `PMR INFO: 
      link-${spark.meetings.personalMeetingRoom.meetingLink}-
      uri-${spark.meetings.personalMeetingRoom.sipUri}-
      tollFree-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
      toll-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
      accessCode-${spark.meetings.personalMeetingRoom.pmr.meetingNumber}
      `;
  });
});

document.getElementById('PMR-edit').addEventListener('submit', (event) => {
  event.preventDefault();
  const pmrLink = document.getElementById('wbx-pmr-link').value;
  const hostPin = document.getElementById('wbx-pmr-host-pin').value;
  if (!pmrLink && !hostPin) {
    return;
  }
  spark.meetings.personalMeetingRoom.claim(pmrLink, hostPin).then((claimed) => {
    console.log(claimed);
    document.getElementById('pmr-edit-info').innerHTML = `PMR INFO: 
    link-${spark.meetings.personalMeetingRoom.meetingLink}-
    uri-${spark.meetings.personalMeetingRoom.sipUri}-
    tollFree-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollFreeNumber.number}-
    toll-${spark.meetings.personalMeetingRoom.pmr.callInNumbersInfo.callInTollNumber.number}-
    accessCode-${spark.meetings.personalMeetingRoom.pmr.meetingNumber}
    `;
  }).catch((err) => {
    console.error(err);
  });
});

document.getElementById('invite-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.invite({emailAddress: document.getElementById('invite-invitee').value}).then((res) => {
    console.log(res);
  });
});

document.getElementById('admit-participant').addEventListener('submit', (event) => {
  event.preventDefault();
  meeting.admit([document.getElementById('admit-invitee').value]).then((res) => {
    console.log(res);
  });
});

// And finally, let's wire up dialing
document.getElementById('dialer').addEventListener('submit', (event) => {
  // again, we don't want to reload when we try to dial
  event.preventDefault();
  spark.meetings.create(document.getElementById('invitee').value)
    .then((m) => {
      console.log(m);
      startMeeting(m);
    });
});

document.getElementById('reconnect-button').addEventListener('click', () => {
  meeting.reconnect();
});

// And finally, let's wire up dialing
// document.getElementById('getmedia').addEventListener('click', () => {
//   // again, we don't want to reload when we try to dial
//   // const streams = media.getUserMedia();
//   return media.getUser();
// });
// And finally, let's wire up dialing
document.getElementById('join').addEventListener('click', () => {
  // TODO: add resource id if paired
  let deviceId;
  if (spark.devicemanager._pairedDevice) {
    deviceId = spark.devicemanager._pairedDevice.identity.id;
  }
  const pin = document.getElementById('hostPin-join').value;
  let hostPin;
  if (pin) {
    hostPin = Number(pin);
  }
  const moderator = document.getElementById('moderator-join').checked;
  meeting.join({resourceId: deviceId, hostPin, moderator})
    .then((res) => {
      console.log('Succesful join, res: ', res);
    }).catch((err) => {
      handleJoinIntent(err, meeting, deviceId);
    });

  meeting.on('meeting:self:lobbyWaiting', () => {
    document.getElementById('lobby-space').innerHTML = 'User is guest to space, waiting to be admitted, wait to use addMedia';
  });

  meeting.on('meeting:self:guestAdmitted', () => {
    document.getElementById('lobby-space').innerHTML = 'Admitted to meeting as guest to call.';
  });

  meeting.on('meeting:reconnectionStarting', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnecting in progress';
  });

  meeting.on('meeting:reconnectionSuccess', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection success';
    setTimeout(() => { document.getElementById('reconnection-status').innerHTML = ''; }, 5000);
  });

  meeting.on('meeting:reconnectionFailure', () => {
    document.getElementById('reconnection-status').innerHTML = 'reconnection failure';
  });

  const lastFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;

  callTime = Date.now();
  let safteyTimeout = null;
  const videoRenderInterval = setInterval(() => {
    const currentFrameCount = document.getElementById('remotevideo').webkitDecodedFrameCount;
    if (currentFrameCount > 0 && currentFrameCount !== lastFrameCount) {
      const current = Date.now();
      console.log('Received remote stream');
      if (callTime) {
        callTime = current - callTime;
        document.getElementById('time').innerHTML = callTime / 1000;
        callTime = null;
        clearInterval(videoRenderInterval);
        clearTimeout(safteyTimeout);
      }
    }
  }, 500);
  safteyTimeout = setTimeout(() => {
    clearInterval(videoRenderInterval);
  }, 15000);

  meeting.members.on('members:update', (delta) => {
    let updateString = '';
    let addedString = '';
    let memberString = '';
    const things = delta.delta;
    const full = delta.full;
    // if kitchen sink was more sophistciated we would re render participants only, or render new as necessary
    Object.keys(full).forEach((key) => {
      const member = full[key];
      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
    const updated = things.updated;
    const added = things.added;
    Object.keys(updated).forEach((key) => {
      const member = updated[key];
      updateString += `Member Updated: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    Object.keys(added).forEach((key) => {
      const member = added[key];
      addedString += `Member Added: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participant-updates').innerHTML = `LAST MEMBERS DELTA: -- MEMBERS UPDATES: ${updateString} -- MEMBERS ADDED: ${addedString}`;
  });

  meeting.members.on('members:content:update', (payload) => {
    console.log(`who started sharing: ${payload.activeContentSharingId};`);
    console.log(`who stopped sharing: ${payload.endedContentSharingId};`);
    const members = meeting.members.membersCollection.getAll();
    let memberString = '';
    Object.keys(members).forEach((key) => {
      const member = members[key];
      memberString += `Member: ${getMemberNameString(member.participant)}, Values: ${getMemberValueString(member)}\r\n`;
    });
    document.getElementById('participants-collection').innerHTML = `MEMBERS INFO:\n${memberString}`;
  });
});

document.getElementById('addMedia').addEventListener('click', () => {
  addMedia(meeting);
});

document.getElementById('incoming-media').addEventListener('click', () => {
  addMedia(meeting);
  toggleDisplay('incomingsection', false);
});

document.getElementById('wirelessShare').addEventListener('click', () => {
  event.preventDefault();
  const deviceId = spark.devicemanager._pairedDevice.identity.id;
  // deviceId is the destination to do the share
  return spark.meetings.create(deviceId).then((m) => {
    console.log(m);
    startMeeting(m);
    meeting.join({
      resourceId: deviceId
    })
      .then(() => meeting.getMediaStreams({
        sendAudio: false,
        sendVideo: false,
        sendShare: true
      })
        .then(([localStream, localShare]) => meeting.addMedia({
          mediaSettings: {
            receiveShare: false,
            receiveAudio: false,
            receiveVideo: false
          },
          localShare,
          localStream
        })))
      .then(() => {
        meeting.share();
        toggleDisplay('stopWirelessShare', true);
        toggleDisplay('wirelessShare', false);
      });
  });
});

document.getElementById('stopWirelessShare').addEventListener('click', () => {
  meeting.leave();
  toggleDisplay('stopWirelessShare', false);
  toggleDisplay('wirelessShare', true);
});

document.getElementById('answer').addEventListener('click', () => {
  meeting = newMeeting;
  startMeeting(meeting);
  newMeeting.join().then(() => {
    newMeeting.acknowledge('ANSWER', false);
  });
  toggleDisplay('answer', true, true);
  toggleDisplay('reject', true, true);
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
});

document.getElementById('reject').addEventListener('click', () => {
  meeting = newMeeting;
  meeting.decline('BUSY');
  document.getElementById('ringing-call').innerHTML = '';
  document.getElementById('alerted-call').innerHTML = '';
});

function handleJoinIntent(err, meeting, deviceId) {
  if (err.joinIntentRequired) {
    toggleDisplay('joinAsHostOrGuest', true);
    // memory/event leak, can also wait for triggered event
    // meeting.on('lobby:hostOrGuest'...
    document.getElementById('joinAsHost').addEventListener('click', () => {
      const pin = document.getElementById('hostPin-join').value;
      let hostPin;
      if (pin) {
        hostPin = Number(pin);
      }
      const moderator = document.getElementById('moderator-join').checked;
      meeting.join({resourceId: deviceId, hostPin, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
    document.getElementById('joinAsGuest').addEventListener('click', () => {
      const moderator = document.getElementById('moderator-join').checked;
      meeting.join({resourceId: deviceId, moderator})
        .then((res) => {
          console.log(res);
        })
        .catch((err) => {
          console.error(err);
        }).finally(() => {
          toggleDisplay('joinAsHostOrGuest', false);
        });
    });
  }
}

function toggleDisplay(elementId, status, disable = false) {
  const element = document.getElementById(elementId);
  if (disable) {
    element.style.disabled = disable;
  }
  else if (status) {
    element.style.display = 'block';
  }
  else {
    element.style.display = 'none';
  }
}
