
/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/* globals window */
import {StatelessWebexPlugin} from '@webex/webex-core';

import LoggerProxy from '../common/logs/logger-proxy';
import peerConnectionManager from '../peer-connection-manager';
import MediaUtil from '../media/util';
import {ICE_STATE, MEETINGS, REACHABILITY, ANSWER} from '../constants';

import ReachabilityRequest from './request';

/**
 * @class Reachability
 * @export
 */
export default class Reachability extends StatelessWebexPlugin {
  namespace = MEETINGS;

  constructor(attrs, options) {
    super({}, options);
    /**
     * internal request object for the server
     * @instance
     * @type {Array}
     * @private
     * @memberof Reachability
     */
    this.reachabilityRequest = new ReachabilityRequest({}, options);
  }

  /**
   * utility function
   * @returns {undefined}
   * @private
   * @memberof Reachability
   */
  setup = () => {
    this.processedClusterResults = [];
    this.peerConnectionMap = {};
  }

  /**
   * fetches reachability data
   * @returns {Object} reachability data
   * @public
   * @memberof Reachability
   */
  gatherReachability = () => {
    this.setup();
    // Reset reachability result to empty to ensure no stale data
    try {
      window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify({}));

      // Get clusters from Orpheus
      return this.reachabilityRequest.getClusters()
        .then((clusters) =>
          // Perform Reachability Check
          this.performReachabilityCheck(clusters)
            .then((response) => {
              window.localStorage.setItem(REACHABILITY.localStorage, JSON.stringify(response));

              return response;
            }))
        .catch((error) => {
          LoggerProxy.logger.error(`Reachability->gatherReachability#Error in calling getClusters(): ${error}`);

          return {};
        });
    }
    catch (error) {
      LoggerProxy.logger.error(`Reachability->gatherReachability#Error in accessing LocalStorage: ${error}`);

      return {};
    }
  };

  /**
   * fetches reachability data
   * @param {object} clusterList
   * @returns {object} reachability check results
   * @private
   * @memberof Reachability
   */
  performReachabilityCheck = (clusterList) => {
    if (!clusterList || !clusterList.length) {
      return Promise.resolve({});
    }

    let localSDPList = [];

    return new Promise(((resolve) => {
      this.getLocalSDPForClusters(clusterList)
        .then((localSDPData) => {
          if (!localSDPData || !Object.keys(localSDPData).length || !localSDPData.localSDPList || !localSDPData.peerConnection) {
            // TODO: handle the error condition properly and try retry
            LoggerProxy.logger.info('Reachability->performReachabilityCheck#Local SDP is empty or has missing elements..returning');
            resolve({});
          }

          this.peerConnectionMap = localSDPData.peerConnection;
          ({localSDPList} = localSDPData);
          this.setRemoteOfferForEachCluster(localSDPList)
            .then((response) => {
              resolve(response);
            });
        })
        .catch((error) => {
          LoggerProxy.logger.error(`Reachability->performReachabilityCheck#Error in getLocalSDPForClusters: ${error}`);
          resolve({});
        });
    }));
  };

  /**
   * sets remote offer for each clusters
   * @param {object} localSDPList local SDP generated
   * @returns {object} reachability check results
   * @private
   * @memberof Reachability
   */
  setRemoteOfferForEachCluster = (localSDPList) => {
    const iceResult = {};

    return new Promise((resolve) => {
      this.reachabilityRequest.remoteSDPForClusters(localSDPList)
        .then((remoteSDPResponse) => {
          const remoteSDPList = remoteSDPResponse.answers;

          if (!remoteSDPList || !remoteSDPList.length) {
            LoggerProxy.logger.info('Reachability->setRemoteOfferForEachCluster#Remote SDP is empty.');
            this.cleanUpPeerConnections(this.peerConnectionMap);
            resolve({});
          }
          remoteSDPList.forEach((remoteSdp) => {
            const jsonObj = remoteSdp;
            const {clusterId} = jsonObj;

            if (jsonObj && jsonObj.sdp) {
              const pc = this.peerConnectionMap[clusterId];

              this.setIceCallBackHandlers(pc)
                .then((iceStatsResult) => {
                  iceStatsResult.clusterId = clusterId;
                  this.processedClusterResults.push(iceStatsResult.clusterId);
                  iceResult[iceStatsResult.clusterId] = {
                    start: iceStatsResult.iceStats.start,
                    stop: iceStatsResult.iceStats.stop
                  };
                  if (this.processedClusterResults.length === remoteSDPList.length) {
                    const reachabilityResult = this.parseIceResultToReachabilityResult(iceResult);

                    LoggerProxy.logger.info(`Reachability->setRemoteOfferForEachCluster#Returning reachability result${JSON.stringify(reachabilityResult)}`);
                    resolve(reachabilityResult);
                  }
                })
                .catch((error) => {
                  LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in setIceCallBackHandlers(): ${error}`);
                  this.cleanUpPeerConnections(this.peerConnectionMap);
                  resolve({});
                });
              peerConnectionManager.setRemoteSessionDetails(pc, ANSWER, jsonObj.sdp);
            }
            else {
              LoggerProxy.logger.error('Reachability->setRemoteOfferForEachCluster# Error in getting remote sdp.');
              this.processedClusterResults.push(clusterId);
              if (this.processedClusterResults.length === remoteSDPList.length) {
                this.cleanUpPeerConnections(this.peerConnectionMap);
                resolve({});
              }
            }
          });
        })
        .catch((error) => {
          LoggerProxy.logger.error(`Reachability->setRemoteOfferForEachCluster#Error in remoteSDPForClusters!:${error}`);
          this.cleanUpPeerConnections(this.peerConnectionMap);
          resolve({});
        });
    });
  }

  /**
   * creates offer and generates localSDP
   * @param {object} clusterList cluster List
   * @returns {object} localSDPData
   * @private
   * @memberof Reachability
   */
  getLocalSDPForClusters = (clusterList) => {
    const localSDPData = {};
    const localSDPList = [];
    const peerConnectionMap = {};

    return new Promise(((resolve, reject) => {
      clusterList.forEach((cluster) => {
        const clusterId = cluster;

        peerConnectionManager.createOffer(MediaUtil.createPeerConnection())
          .then((peerConnection) => {
            peerConnectionMap[clusterId] = peerConnection;

            const localSDP = {
              sdp: peerConnection.sdp,
              clusterId
            };

            localSDPList.push(localSDP);

            if (localSDPList.length === clusterList.length) {
              localSDPData.peerConnection = peerConnectionMap;
              localSDPData.localSDPList = localSDPList;
              resolve(localSDPData);
            }
          })
          .catch((error) => {
            LoggerProxy.logger.error(`Reachability->getLocalSDPForClusters#Error in getLocalSDP : ${error}`);
            reject(error);
          });
      });
    }));
  };

  /**
   * Calculates time to establish connection
   * @param {object} iceResult iceResults
   * @returns {object} result
   * @private
   * @memberof Reachability
   */
  parseIceResultToReachabilityResult = (iceResult) => {
    if (!iceResult || !Object.keys(iceResult).length) {
      return {};
    }
    const result = {};

    for (const clusterId of Object.keys(iceResult)) {
      let reachability = {};

      if (iceResult[clusterId].start > 0 && iceResult[clusterId].stop > 0) {
        const latency = iceResult[clusterId].stop - iceResult[clusterId].start;

        reachability = {
          reachable: true,
          latencyInMilliseconds: latency
        };
      }
      else {
        reachability = {reachable: false};
      }
      result[clusterId] = {udp: reachability};
    }

    return result;
  };

  /**
   * cleans all the peerconnection
   * @param {object} peerConnectionMap peerconnectionList
   * @returns {object} localSDPData
   * @private
   * @memberof Reachability
   */
  cleanUpPeerConnections = (peerConnectionMap) => {
    for (const key of Object.keys(peerConnectionMap)) {
      const pc = peerConnectionMap[key];

      if (pc) {
        LoggerProxy.logger.info(`Reachability->cleanUpPeerConnections#Cleaning up peer connection created for cluster : ${key}`);
        pc.close();
      }
    }
  };

  /**
   * sets the success callback for peerconnection
   * @param {object} pc peerconnection
   * @returns {object} iceState
   * @private
   * @memberof Reachability
   */
  setIceCallBackHandlers = (pc) => {
    let timeout = null;
    const iceStats = {start: 0, stop: 0};

    return new Promise(((resolve) => {
      function iceComplete(isSuccessful, timeout, iceStats) {
        if (isSuccessful) {
          if (timeout) {
            window.clearTimeout(timeout);
            timeout = undefined;
          }
        }
        pc.close();
        resolve({iceStats});
      }

      timeout = window.setTimeout(() => {
        LoggerProxy.logger.warn(`Reachability->iceCallBackHandler#${this.clusterId} ice handler timed out.`);
        iceComplete(false, timeout, iceStats);
      }, 5000);

      pc.oniceconnectionstatechange = () => {
        if (pc) {
          if (pc.iceConnectionState === ICE_STATE.CHECKING) {
            iceStats.start = Date.now();
          }
          if (pc.iceConnectionState === ICE_STATE.CONNECTED) {
            iceStats.stop = Date.now();
            iceComplete(true, timeout, iceStats);
          }
          if (pc.iceConnectionState === ICE_STATE.FAILED) {
            iceComplete(false, timeout, iceStats);
          }
        }
      };
    }));
  };

  /**
   * proxy to the server request for clusters
   * @returns {Promise}
   * @private
   * @memberof Reachability
   */
  getClusters = () => this.reachabilityRequest.getClusters()
}
