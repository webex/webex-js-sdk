import {isEqual} from 'lodash';

import LoggerProxy from '../common/logs/logger-proxy';
import EventsScope from '../common/events/events-scope';
import {
  EVENTS,
  LOCUSEVENT,
  _USER_,
  _CALL_,
  MEETING_STATE,
  _MEETING_,
  LOCUSINFO,
  LOCUS,
  _LEFT_,
  MEETING_REMOVED_REASON,
  CALL_REMOVED_REASON,
  AUDIO_STATUS,
  VIDEO_STATUS,
  _RECEIVE_ONLY_,
  _SEND_RECEIVE_,
  _INACTIVE_,
  PARTICIPANT_DELTAS,
  METRICS_OPERATIONAL_MEASURES
} from '../constants';
import Metrics from '../metrics';
import {eventType} from '../metrics/config';
import InfoUtils from '../locus-info/infoUtils';
import FullState from '../locus-info/fullState';
import SelfUtils from '../locus-info/selfUtils';
import HostUtils from '../locus-info/hostUtils';
import ControlsUtils from '../locus-info/controlsUtils';
import MediaSharesUtils from '../locus-info/mediaSharesUtils';
import Parser from '../locus-info/parser';


/**
 * @description LocusInfo extends ChildEmitter to convert locusInfo info a private emitter to parent object
 * @export
 * @private
 * @class LocusInfo
 */
export default class LocusInfo extends EventsScope {
  constructor(updateMeeting, locus = {}, webex, meetingId) {
    super();
    this.parsedLocus = {
      states: []
    };
    this.webex = webex;
    this.emitChange = false;
    this.compareAndUpdateFlags = {};
    this.meetingId = meetingId;
    this.updateMeeting = updateMeeting;
    this.created = locus.created || null;
    this.mediaShares = locus.mediaShares || null;
    this.scheduledMeeting = locus.meeting || null;
    this.participantsUrl = locus.participantsUrl || null;
    this.replaces = locus.replaces || null;
    this.aclUrl = locus.aclUrl || null;
    this.baseSequence = locus.baseSequence || null;
    this.sequence = locus.sequence || null;
    this.membership = locus.membership || null;
    this.identities = locus.identities || null;
    this.participants = locus.participants || null;

    /**
     * Stores the delta values for a changed participant.
     *
     * @typedef {Object} DeltaParticipant
     * @property {Record<string, boolean>} delta - Contains changed streams.
     * @property {Object} person - Contains person data.
     */

    /**
     * Stored participant changes between the last event and the current event.
     * All previously stored events are overwritten between events.
     *
     * @instance
     * @type {Array<DeltaParticipant>}
     * @private
     * @member LocusInfo
     */
    this.deltaParticipants = [];

    // above section only updates the locusInfo object
    // The below section makes sure it updates the locusInfo as well as updates the meeting object
    this.updateParticipants(locus.participants);
    // For 1:1 space meeting the conversation Url does not exist in locus.conversation
    this.updateConversationUrl(locus.conversationUrl, locus.info);
    this.updateControls(locus.controls);
    this.updateLocusUrl(locus.url);
    this.updateFullState(locus.fullState);
    this.updateMeetingInfo(locus.info);
    // self and participants generate sipUrl for 1:1 meeting
    this.updateSelf(locus.self, locus.participants);
    this.updateHostInfo(locus.host);
  }

  /**
   * @param {Object} locus
   * @param {Meeting} meeting
   * @returns {undefined}
   * @memberof LocusInfo
   */
  initialSetup(locus, meeting) {
    // meeting already exisits just do an update
    if (meeting) {
      // Its a new delta event fetch the whole meeting object
      Parser.updateWithDeltaLocus(locus, meeting);
    }
    else {
      this.onFullLocus(locus);
    }

    // Change it to true after it recives it first locus object
    this.emitChange = true;
  }

  /**
   * @param {Meeting} meeting
   * @param {Object} data
   * @returns {undefined}
   * @memberof LocusInfo
   */
  parse(meeting, data) {
    const {eventType} = data;

    LoggerProxy.logger.info(`Locus-info:index#parse --> received locus data: ${eventType}`);

    switch (eventType) {
      case LOCUSEVENT.PARTICIPANT_JOIN:
      case LOCUSEVENT.PARTICIPANT_LEFT:
      case LOCUSEVENT.CONTROLS_UPDATED:
      case LOCUSEVENT.PARTICIPANT_AUDIO_MUTED:
      case LOCUSEVENT.PARTICIPANT_AUDIO_UNMUTED:
      case LOCUSEVENT.PARTICIPANT_VIDEO_MUTED:
      case LOCUSEVENT.PARTICIPANT_VIDEO_UNMUTED:
      case LOCUSEVENT.SELF_CHANGED:
      case LOCUSEVENT.PARTICIPANT_UPDATED:
      case LOCUSEVENT.PARTICIPANT_CONTROLS_UPDATED:
      case LOCUSEVENT.PARTICIPANT_ROLES_UPDATED:
      case LOCUSEVENT.PARTICIPANT_DECLINED:
      case LOCUSEVENT.FLOOR_GRANTED:
      case LOCUSEVENT.FLOOR_RELEASED:
        this.onFullLocus(data.locus, eventType);
        break;
      case LOCUSEVENT.DIFFERENCE:
        Parser.updateWithDeltaLocus(data.locus, meeting);
        break;

      default:
        // Why will there be a event with no eventType ????
        // we may not need this, we can get full locus
        Parser.updateWithDeltaLocus(data.locus, meeting);
    }
  }

  /**
   * @param {String} scope
   * @param {String} eventName
   * @param {Array} args
   * @returns {undefined}
   * @memberof LocusInfo
   */
  emitScoped(scope, eventName, args) {
    return this.emit(scope, eventName, args);
  }

  /**
   * updates the locus with full locus object
   * @param {object} locus locus object
   * @param {sting} eventType particulat locus event
   * @returns {object} null
   * @memberof LocusInfo
   */
  onFullLocus(locus, eventType) {
    if (!locus) {
      LoggerProxy.logger.error('Locus-info:index#onFullLocus --> object passed as argument was invalid, continuing.');
    }
    this.updateParticipantDeltas(locus.participants);
    this.participants = locus.participants;
    this.reportParticipantChanges();
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants);
    this.isMeetingActive();
    this.handleOneOnOneEvent(eventType);
  }

  // used for ringing stops on one on one
  /**
   * @param {String} eventType
   * @returns {undefined}
   * @memberof LocusInfo
   */
  handleOneOnOneEvent(eventType) {
    if (this.parsedLocus.info.type === _CALL_) {
    // for 1:1 bob calls alice and alice declines, notify the meeting state
      if (eventType === LOCUSEVENT.PARTICIPANT_DECLINED) {
      // trigger the event for stop ringing
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          },
          EVENTS.REMOTE_ANSWERED_DECLINED,
          {
            remoteDeclined: true,
            remoteAnswered: false
          }
        );
      }
      // for 1:1 bob calls alice and alice answers, notify the meeting state
      if (eventType === LOCUSEVENT.PARTICIPANT_JOIN) {
      // trigger the event for stop ringing
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'handleOneonOneEvent'
          },
          EVENTS.REMOTE_ANSWERED_DECLINED,
          {
            remoteDeclined: false,
            remoteAnswered: true
          }
        );
      }
    }
  }

  /**
   * @param {Object} locus
   * @returns {undefined}
   * @memberof LocusInfo
   */
  onDeltaLocus(locus) {
    this.updateLocusInfo(locus);
    this.updateParticipants(locus.participants);
    this.isMeetingActive();
  }

  /**
   * @param {Object} locus
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateLocusInfo(locus) {
    this.updateControls(locus.controls);
    this.updateConversationUrl(locus.conversationUrl, locus.info);
    this.updateCreated(locus.created);
    this.updateFullState(locus.fullState);
    this.updateHostInfo(locus.host);
    this.updateMeetingInfo(locus.info, locus.self);
    this.updateMediaShares(locus.mediaShares);
    this.updateParticipantsUrl(locus.participantsUrl);
    this.updateReplace(locus.replace);
    this.updateSelf(locus.self, locus.participants);
    this.updateLocusUrl(locus.url);
    this.updateAclUrl(locus.aclUrl);
    this.updateBasequence(locus.baseSequence);
    this.updateSequence(locus.sequence);
    this.updateMemberShip(locus.membership);
    this.updateIdentifiers(locus.identities);
    this.compareAndUpdate();
    // update which required to compare different objects from locus
  }

  /**
   * @param {Array} participants
   * @param {Object} self
   * @returns {Array}
   * @memberof LocusInfo
   */
  getLocusPartner(participants, self) {
    if (!participants || participants.length === 0) {
      return null;
    }

    return participants.find((participant) =>
      (self && participant.identity !== self.identity) &&
  (participants.length <= 2 || (participant.type === _USER_ && !participant.removed))) || this.partner;
  }

  // TODO: all the leave states need to be checked
  /**
   * @returns {undefined}
   * @memberof LocusInfo
   */
  isMeetingActive() {
    if (this.parsedLocus.fullState.type === _CALL_) {
      const partner = this.getLocusPartner(this.participants, this.self);

      this.updateMeeting({partner});

      // Check if guest user needs to be checked here

      // 1) when bob declines call from bob, (bob='DECLINED')
      // 2) When alice rejects call to bob , (bob='NOTIFIED')

      // When we dont add MEDIA for condition 2. The state of bob='IDLE'

      if (this.fullState && this.fullState.state === LOCUS.STATE.INACTIVE) {
        // TODO: update the meeting state
        LoggerProxy.logger.warn('Locus-info:index#isMeetingActive --> Call Ended, locus state is inactive.');
        Metrics.postEvent({
          event: eventType.REMOTE_ENDED,
          meetingId: this.meetingId
        });
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: CALL_REMOVED_REASON.CALL_INACTIVE,
            shouldLeave: false
          }
        );
      }
      else
      if (partner.state === MEETING_STATE.STATES.LEFT &&
        this.parsedLocus.self &&
        (this.parsedLocus.self.state === MEETING_STATE.STATES.DECLINED ||
        this.parsedLocus.self.state === MEETING_STATE.STATES.NOTIFIED ||
        this.parsedLocus.self.state === MEETING_STATE.STATES.JOINED)) {
        Metrics.postEvent({
          event: eventType.REMOTE_ENDED,
          meetingId: this.meetingId
        });
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: CALL_REMOVED_REASON.PARTNER_LEFT,
            shouldLeave: this.parsedLocus.self.joinedWith && this.parsedLocus.self.joinedWith.state !== _LEFT_
          }
        );
      }
      else
      if (this.parsedLocus.self &&
        this.parsedLocus.self.state === MEETING_STATE.STATES.LEFT &&
      (partner.state === MEETING_STATE.STATES.LEFT ||
      partner.state === MEETING_STATE.STATES.DECLINED ||
      partner.state === MEETING_STATE.STATES.NOTIFIED ||
      partner.state === MEETING_STATE.STATES.IDLE) // Happens when user just joins and adds no Media
      ) {
        Metrics.postEvent({
          event: eventType.REMOTE_ENDED,
          meetingId: this.meetingId
        });
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: CALL_REMOVED_REASON.SELF_LEFT,
            shouldLeave: false
          }
        );
      }
    }
    else if (this.parsedLocus.fullState.type === _MEETING_) {
      if (this.fullState && (this.fullState.state === LOCUS.STATE.INACTIVE || this.fullState.state === LOCUS.STATE.TERMINATING)) {
        Metrics.postEvent({
          event: eventType.REMOTE_ENDED,
          meetingId: this.meetingId
        });
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: MEETING_REMOVED_REASON.MEETING_INACTIVE_TERMINATING,
            shouldLeave: false
          }
        );
      }
      else if (this.fullState && this.fullState.removed) {
        // user has been dropped from a meeting
        Metrics.postEvent({
          event: eventType.REMOTE_ENDED,
          meetingId: this.meetingId
        });
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: MEETING_REMOVED_REASON.FULLSTATE_REMOVED,
            shouldLeave: false
          }
        );
      }
      // If you are  guest and you are removed from the meeting
      // You wont get any further events
      else if (this.parsedLocus.self && this.parsedLocus.self.removed) {
        // Check if we need to send an event
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'isMeetingActive'
          },
          EVENTS.DESTROY_MEETING,
          {
            reason: MEETING_REMOVED_REASON.SELF_REMOVED,
            shouldLeave: false
          }
        );
      }
    }
    else {
      LoggerProxy.logger.warn('Locus-info:index#isMeetingActive --> Meeting Type is unknown.');
    }
  }

  /**
   * @returns {undefined}
   * @memberof LocusInfo
   */
  compareAndUpdate() {
    if (this.compareAndUpdateFlags.compareSelfAndHost || this.compareAndUpdateFlags.compareHostAndSelf) {
      this.compareSelfAndHost();
    }
  }

  /**
   * @returns {undefined}
   * @memberof LocusInfo
   */
  compareSelfAndHost() {
    if ((this.parsedLocus.self.selfIdentity === this.parsedLocus.host.hostId) && this.parsedLocus.self.moderator) {
      this.emitScoped(
        {
          file: 'locus-info',
          function: 'compareSelfAndHost'
        },
        EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST,
        {
          canAssignHost: true
        }
      );
    }
    else {
      this.emitScoped(
        {
          file: 'locus-info',
          function: 'compareSelfAndHost'
        },
        EVENTS.LOCUS_INFO_CAN_ASSIGN_HOST,
        {
          canAssignHost: false
        }
      );
    }
  }

  /**
   * Report any participant changes via metrics requests.
   *
   * @returns {void}
   */
  reportParticipantChanges() {
    // Used to find a participant from a given collection.
    const findParticipant = (person = {}, collection = []) =>
      collection.find((participant) => participant.person.id === person.id) ||
      {};

    // Used to setup a changes object for metrics.
    const determineChanges = (participant, deltas) =>
      Object.keys(deltas).reduce((states, key) => {
        const changes = {
          target: undefined,
          state: undefined
        };

        switch (key) {
          case AUDIO_STATUS:
            changes.target = PARTICIPANT_DELTAS.TARGETS.AUDIO;
            break;

          case VIDEO_STATUS:
            changes.target = PARTICIPANT_DELTAS.TARGETS.VIDEO;
            break;

          default:
        }

        switch (participant.status[key]) {
          case _INACTIVE_:
            changes.state = PARTICIPANT_DELTAS.STATES.DISABLED;
            break;

          case _RECEIVE_ONLY_:
            changes.state = PARTICIPANT_DELTAS.STATES.MUTED;
            break;

          case _SEND_RECEIVE_:
            changes.state = PARTICIPANT_DELTAS.STATES.UNMUTED;
            break;

          default:
            changes.state = PARTICIPANT_DELTAS.STATES.UNKNOWN;
        }

        if (changes.target) {
          states.push(changes);
        }

        return states;
      }, []);

    this.deltaParticipants.forEach(
      (changedParticipant) => {
        const participant = findParticipant(
          changedParticipant.person,
          this.participants
        );

        const changes = determineChanges(participant, changedParticipant.delta);

        if (
          changes.every(
            (change) => (change.state === PARTICIPANT_DELTAS.STATES.DISABLED)
          )
        ) {
          const meeting = this.webex.meetings.meetingCollection.get(
            this.meetingId
          );

          Metrics.sendOperationalMetric(
            METRICS_OPERATIONAL_MEASURES.MEETING_MEDIA_RELEASE,
            {
              correlation_id: meeting.correlationId,
              locus_id: meeting.locusId,
              reason: `${participant.person.id} left the meeting`
            }
          );
        }
      }
    );
  }

  /**
   * Update the deltaParticipants property of this object based on a list of
   * provided participants.
   *
   * @param {Array} [participants] - The participants to update against.
   * @returns {void}
   */
  updateParticipantDeltas(participants = []) {
    // Used to find a participant within a participants collection.
    const findParticipant = (participant, collection) =>
      collection.find((item) => item.person.id === participant.person.id);

    // Generates an object that indicates which state properties have changed.
    const generateDelta = (prevState = {}, newState = {}) => {
      // Setup deltas.
      const deltas = {
        audioStatus: prevState.audioStatus !== newState.audioStatus,
        videoSlidesStatus: prevState.videoSlidesStatus !== newState.videoSlidesStatus,
        videoStatus: prevState.videoStatus !== newState.videoStatus
      };

      // Clean the object
      Object.keys(deltas).forEach(
        (key) => {
          if (deltas[key] !== true) {
            delete deltas[key];
          }
        }
      );

      return deltas;
    };

    this.deltaParticipants = participants.reduce(
      (collection, participant) => {
        const existingParticipant = findParticipant(
          participant,
          this.participants || []
        ) || {};

        const delta = generateDelta(existingParticipant.status, participant.status);

        const changed = (Object.keys(delta).length > 0);

        if (changed) {
          collection.push({
            person: participant.person,
            delta
          });
        }

        return collection;
      }, []
    );
  }

  /**
   *
   * @param {Object} participants new participants object
   * @param {boolen} deltaParticpantFlag  delta event
   * @returns {Array} updatedParticipants
   * @memberof LocusInfo
   */
  updateParticipants(participants) {
    this.emitScoped(
      {
        file: 'locus-info',
        function: 'updateParticipants'
      },
      EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS,
      {
        participants,
        recordingId: this.parsedLocus.controls && this.parsedLocus.controls.recordingId,
        selfIdentity: this.parsedLocus.self && this.parsedLocus.self.selfIdentity,
        selfId: this.parsedLocus.self && this.parsedLocus.self.selfId,
        hostId: this.parsedLocus.host && this.parsedLocus.host.hostId
      }
    );
  }

  /**
   * @param {Object} controls
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateControls(controls) {
    if (controls && !isEqual(this.controls, controls)) {
      this.controls = controls;
      this.parsedLocus.controls = ControlsUtils.parse(controls);
    }
  }

  /**
   * @param {String} conversationUrl
   * @param {Object} info
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateConversationUrl(conversationUrl, info) {
    if (conversationUrl && !isEqual(this.conversationUrl, conversationUrl)) {
      this.conversationUrl = conversationUrl;
      this.updateMeeting({convoUrl: conversationUrl});
    }
    else if (info && info.conversationUrl && !isEqual(this.conversationUrl, info.conversationUrl)) {
      this.conversationUrl = info.conversationUrl;
      this.updateMeeting({convoUrl: info.conversationUrl});
    }
  }

  /**
   * @param {Object} created
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateCreated(created) {
    if (created && !isEqual(this.created, created)) {
      this.created = created;
    }
  }


  /**
   * @param {Object} fullState
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateFullState(fullState) {
    if (fullState && !isEqual(this.fullState, fullState)) {
      const result = FullState.getFullState(this.fullState, fullState);

      this.updateMeeting(result.current);

      if (result.updates.meetingStateChangedTo) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateFullState'
          },
          LOCUSINFO.EVENTS.FULL_STATE_MEETING_STATE_CHANGE,
          {
            previousState: result.previous && result.previous.meetingState,
            currentState: result.current.meetingState
          }
        );
      }

      if (result.updates.meetingTypeChangedTo) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateFullState'
          },
          LOCUSINFO.EVENTS.FULL_STATE_TYPE_UPDATE,
          {
            type: result.current.type
          }
        );
      }
      this.parsedLocus.fullState = result.current;
      this.fullState = fullState;
    }
  }

  /**
   * handles when the locus.host is updated
   * @param {Object} host the locus.host property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal event locus_info_update_host
   */
  updateHostInfo(host) {
    if (host && !isEqual(this.host, host)) {
      const parsedHosts = HostUtils.getHosts(this.host, host);

      this.updateMeeting(parsedHosts.current);
      this.parsedLocus.host = parsedHosts.current;
      if (parsedHosts.updates.isNewHost) {
        this.compareAndUpdateFlags.compareSelfAndHost = true;
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateHostInfo'
          },
          EVENTS.LOCUS_INFO_UPDATE_HOST,
          {
            newHost: parsedHosts.current,
            oldHost: parsedHosts.previous
          }
        );
      }
      this.host = host;
    }
    else {
      this.compareAndUpdateFlags.compareSelfAndHost = false;
    }
  }

  /**
   * @param {Object} info
   * @param {Object} self
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateMeetingInfo(info, self) {
    if (info && (!isEqual(this.info, info) ||
    !isEqual(InfoUtils.parsePolicy(info), InfoUtils.parsePolicy(this.info)) ||
    !isEqual(InfoUtils.parseModerator(info) || InfoUtils.parseModerator(info)))) {
      const parsedInfo = InfoUtils.getInfos(this.parsedLocus.info, info);

      this.emitScoped(
        {
          file: 'locus-info',
          function: 'updateMeetingInfo'
        },
        LOCUSINFO.EVENTS.MEETING_INFO_UPDATED,
        {info: parsedInfo.current, self}
      );

      if (parsedInfo.updates.isLocked) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateMeetingInfo'
          },
          LOCUSINFO.EVENTS.MEETING_LOCKED,
          info
        );
      }
      if (parsedInfo.updates.isUnlocked) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateMeetingInfo'
          },
          LOCUSINFO.EVENTS.MEETING_UNLOCKED,
          info
        );
      }

      this.info = info;
      this.parsedLocus.info = parsedInfo.current;
      // Parses the info and adds necessary values
      this.updateMeeting(parsedInfo.current);
    }
  }

  /**
   * handles when the locus.mediaShares is updated
   * @param {Object} mediaShares the locus.mediaShares property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal event locus_info_update_media_shares
   */
  updateMediaShares(mediaShares) {
    if (mediaShares && !isEqual(this.mediaShares, mediaShares)) {
      const parsedMediaShares = MediaSharesUtils.getMediaShares(this.mediaShares, mediaShares);

      this.updateMeeting(parsedMediaShares.current);
      this.emitScoped(
        {
          file: 'locus-info',
          function: 'updateMediaShares'
        },
        EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES,
        {
          current: parsedMediaShares.current,
          previous: parsedMediaShares.previous
        }
      );
      this.parsedLocus.mediaShares = parsedMediaShares.current;
      this.mediaShares = mediaShares;
    }
  }

  /**
   * @param {String} participantsUrl
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateParticipantsUrl(participantsUrl) {
    if (participantsUrl && !isEqual(this.participantsUrl, participantsUrl)) {
      this.participantsUrl = participantsUrl;
    }
  }

  /**
   * @param {Object} replace
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateReplace(replace) {
    if (replace && !isEqual(this.replace, replace)) {
      this.replace = replace;
    }
  }

  /**
   * handles when the locus.self is updated
   * @param {Object} self the locus.mediaShares property
   * @param {Array} participants the locus.participants property
   * @returns {undefined}
   * @memberof LocusInfo
   * emits internal events self_admitted_guest, self_unadmitted_guest, locus_info_update_self
   */
  updateSelf(self, participants) {
    if (self && !isEqual(this.self, self)) {
      const parsedSelves = SelfUtils.getSelves(this.self, self, this.webex.internal.device.url);

      this.updateMeeting(parsedSelves.current);
      this.parsedLocus.self = parsedSelves.current;

      const element = this.parsedLocus.states[this.parsedLocus.states.length - 1];

      if (element !== parsedSelves.current.state) {
        this.parsedLocus.states.push(parsedSelves.current.state);
      }

      // TODO: check if we need to save the sipUri here as well
      // this.emit(LOCUSINFO.EVENTS.MEETING_UPDATE, SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri));
      const result = SelfUtils.getSipUrl(this.getLocusPartner(participants, self), this.parsedLocus.fullState.type, this.parsedLocus.info.sipUri);

      if (result.sipUri) {
        this.updateMeeting(result);
      }
      if (parsedSelves.updates.moderatorChanged) {
        this.compareAndUpdateFlags.compareHostAndSelf = true;
      }
      else {
        this.compareAndUpdateFlags.compareHostAndSelf = false;
      }

      if (parsedSelves.updates.isMediaInactiveOrReleased) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.DISCONNECT_DUE_TO_INACTIVITY,
          {reason: self.reason}
        );
      }

      if (parsedSelves.updates.moderatorChanged) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.SELF_MODERATOR_CHANGED,
          self
        );
      }
      if (parsedSelves.updates.isMutedByOthers) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.SELF_MUTED_BY_OTHERS,
          self
        );
      }
      if (parsedSelves.updates.isUnadmittedGuest) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST,
          self
        );
      }
      if (parsedSelves.updates.isAdmittedGuest) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST,
          self
        );
      }

      if (parsedSelves.updates.isMediaInactive) {
        this.emitScoped(
          {
            file: 'locus-info',
            function: 'updateSelf'
          },
          LOCUSINFO.EVENTS.MEDIA_INACTIVITY,
          SelfUtils.getMediaStatus(self.mediaSessions)
        );
      }


      this.emitScoped(
        {
          file: 'locus-info',
          function: 'updateSelf'
        },
        EVENTS.LOCUS_INFO_UPDATE_SELF,
        {
          oldSelf: parsedSelves.previous,
          newSelf: parsedSelves.current
        }
      );
      this.parsedLocus.self = parsedSelves.current;
      this.self = self;
    }
    else {
      this.compareAndUpdateFlags.compareHostAndSelf = false;
    }
  }

  /**
   * handles when the locus.url is updated
   * @param {String} url
   * @returns {undefined}
   * emits internal event locus_info_update_url
   */
  updateLocusUrl(url) {
    if (url && this.url !== url) {
      this.url = url;
      this.updateMeeting({locusUrl: url});
      this.emitScoped(
        {
          file: 'locus-info',
          function: 'updateLocusUrl'
        },
        EVENTS.LOCUS_INFO_UPDATE_URL,
        url
      );
    }
  }

  /**
   * @param {String} aclUrl
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateAclUrl(aclUrl) {
    if (aclUrl && !isEqual(this.aclUrl, aclUrl)) {
      this.aclUrl = aclUrl;
    }
  }

  /**
   * @param {Number} baseSequence
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateBasequence(baseSequence) {
    if (baseSequence && !isEqual(this.baseSequence, baseSequence)) {
      this.baseSequence = baseSequence;
    }
  }

  /**
   * @param {Number} sequence
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateSequence(sequence) {
    if (sequence && !isEqual(this.sequence, sequence)) {
      this.sequence = sequence;
    }
  }

  /**
   * @param {Object} membership
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateMemberShip(membership) {
    if (membership && !isEqual(this.membership, membership)) {
      this.membership = membership;
    }
  }

  /**
   * @param {Array} identities
   * @returns {undefined}
   * @memberof LocusInfo
   */
  updateIdentifiers(identities) {
    if (identities && !isEqual(this.identities, identities)) {
      this.identities = identities;
    }
  }
}
