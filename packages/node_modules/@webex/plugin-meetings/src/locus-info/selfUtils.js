/* globals spark */
import {IDLE, JOINED, SELF, OTHER, USER, ONE_ON_ONE} from '../constants';

const selfUtils = {};

/**
 * parses the relevant values for self: muted, guest, moderator, mediaStatus, state, joinedWith, creator, id
 * @param {Object} self
 * @returns {undefined}
 */
selfUtils.parse = (self) => {
  if (self) {
    return {
      muted: selfUtils.getMuted(self),
      guest: self.guest,
      moderator: self.moderator,
      mediaStatus: selfUtils.getStatus(self.status),
      state: self.state,
      // TODO: give a proper name . With same device as login or different login`
      // Some times we might have joined with both mobile and web
      joinedWith: selfUtils.checkJoinedStatus(self) ? SELF : OTHER,
      creator: self.isCreator, // check if its used,
      id: selfUtils.getId(self)
    };
  }
  return null;
};

/**
 * get the previous and current self values parsed, as well as the boolean updates: isUnadmittedGuest, isAdmittedGuest
 * @param {Object} oldSelf
 * @param {Object} newSelf
 * @returns {Object}
 * previous: {Object} old share, current: {Object} new share, updates: {isUnadmittedGuest: {Boolean}, isAdmittedGuest: {Boolean}}
 */
selfUtils.getSelves = (oldSelf, newSelf) => {
  const previous = oldSelf && selfUtils.parse(oldSelf);
  const current = newSelf && selfUtils.parse(newSelf);
  return {
    previous,
    current,
    updates: {
      isUnadmittedGuest: selfUtils.isUnadmittedGuest(current),
      isAdmittedGuest: selfUtils.isAdmittedGuest(previous, current)
    }
  };
};

/**
 * get the id from the self object
 * @param {Object} self
 * @returns {String}
 */
selfUtils.getId = (self) => {
  if (!self || !self.person) {
    return null;
  }
  return self.person.id;
};

/**
 * get the muted property from the self object
 * @param {Object} self
 * @returns {Boolean}
 */
selfUtils.getMuted = (self) => {
  if (!self || !self.controls || !self.controls.audio) {
    return null;
  }
  return self.controls.audio.muted;
};

/**
 * returns true of false if this device has joined the meeting
 * @param {boolen} self  true
 * @returns {boolen} return true if you have joined the meeting
 */
selfUtils.checkJoinedStatus = (self) => {
  // Device you logged in with
  const selfDeviceUrl = spark.internal.device.url;
  return self.devices.some((device) => selfDeviceUrl === device.Url);
};

/**
 * read the status of audio/video/slides
 * @param {Object} status
 * @returns {Object} audio, video, slides
 */
selfUtils.getStatus = (status) => ({
  audio: status.audioStatus,
  video: status.videoStatus,
  slides: status.videoSlidesStatus
});

/**
 * @param {Object} check
 * @returns {Boolean}
 */
selfUtils.isLocusGuestUnadmitted = (check) => check && check.guest && check.state === IDLE;

/**
 * @param {Object} check
 * @returns {Boolean}
 */
selfUtils.isLocusGuestAdmitted = (check) => check && check.guest && check.state === JOINED;

/**
 * @param {Object} self
 * @returns {Boolean}
 * @throws {Error} when self is undefined
 */
selfUtils.isUnadmittedGuest = (self) => {
  if (!self) {
    throw new TypeError('self must be defined to determine if self is unadmitted as guest.');
  }
  return selfUtils.isLocusGuestUnadmitted(self);
};

/**
 * @param {Object} oldSelf
 * @param {Object} changedSelf
 * @returns {Boolean}
 * @throws {Error} if changed self was undefined
 */
selfUtils.isAdmittedGuest = (oldSelf, changedSelf) => {
  if (!oldSelf) {
    // if there was no previous locus, it couldn't have been admitted yet
    return false;
  }
  if (!changedSelf) {
    throw new TypeError('New self must be defined to determine if self transitioned to admitted as guest.');
  }
  return selfUtils.isLocusGuestUnadmitted(oldSelf) && selfUtils.isLocusGuestAdmitted(changedSelf);
};

/**
 * extract the sipUrl from the partner
 * @param {Object} self
 * @param {Array} participants
 * @param {Object} info
 * @returns {Object}
 */
selfUtils.getSipUrl = (self, participants, info) => {
  const partner = participants.find((participant) =>
    (self && participant.identity !== self.identity)
    && (participants.length <= 2 || (participant.type === USER && !participant.removed)));

  // For webex meeting the sipUrl gets updated in info parser
  if (partner && info.type === ONE_ON_ONE) {
    return {sipUri: partner.person.sipUrl || partner.person.emailAddress || partner.person.email};
  }
  return {sipUri: info.sipUri};
};


export default selfUtils;
