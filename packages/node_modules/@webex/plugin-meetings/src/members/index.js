/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */
import {isEmpty} from 'lodash';
import {StatelessWebexPlugin} from '@webex/webex-core';

import {MEETINGS, EVENT_TRIGGERS, FLOOR_ACTION, CONTENT} from '../constants';
import Trigger from '../common/events/trigger-proxy';
import Member from '../member';
import LoggerProxy from '../common/logs/logger-proxy';
import ParameterError from '../common/errors/parameter';

import MembersCollection from './collection';
import MembersRequest from './request';
import MembersUtil from './util';


/**
 * @class Members
 */
export default class Members extends StatelessWebexPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   * @memberof Members
   */
  constructor(attrs, options) {
    super({}, options);
    this.membersRequest = new MembersRequest({}, options);
    this.membersCollection = new MembersCollection();
    this.locusUrl = null;
    this.hostId = null;
    this.type = null;
    // locus has a self object, sent individually to the client
    // i.e., each person in the call gets their own self object from locus
    // we need to maintain that self object, because we also get information about all the participants
    // and differentiate those participants from self
    // the self id shouldnt ever change, but it does have properties in that will change
    // and we use values in locus-info, such as to determine if i am admitted to the meeting or not as guest
    this.selfId = null;
    this.mediaShareContentId = null;
  }

  locusSelfUpdate(payload) {
    let newSelfId = null;
    let oldSelfId = null;

    if (payload) {
      if (payload.newSelf) {
        newSelfId = payload.newSelf.id;
      }
      if (payload.oldSelf) {
        oldSelfId = payload.oldSelf.id;
      }
    }
    if (newSelfId) {
      const theSelf = this.membersCollection.get(newSelfId);

      if (theSelf) {
        theSelf.setIsSelf(true);
      }
    }
    if (oldSelfId) {
      const notSelf = this.membersCollection.get(oldSelfId);

      if (notSelf) {
        notSelf.setIsSelf(false);
      }
    }
    this.selfId = newSelfId;
    Trigger.trigger(
      this,
      {
        file: 'members',
        function: 'locusSelfUpdate'
      },
      EVENT_TRIGGERS.MEMBERS_SELF_UPDATE,
      {
        activeSelfId: newSelfId,
        endedSelfId: oldSelfId
      }
    );
  }

  locusHostUpdate(payload) {
    let newHostId = null;
    let oldHostId = null;

    if (payload) {
      if (payload.newHost) {
        newHostId = payload.newHost.id;
      }
      if (payload.oldHost) {
        oldHostId = payload.oldHost.id;
      }
    }
    if (newHostId) {
      const theHost = this.membersCollection.get(newHostId);

      if (theHost) {
        theHost.setIsHost(true);
      }
    }
    if (oldHostId) {
      const notHost = this.membersCollection.get(oldHostId);

      if (notHost) {
        notHost.setIsHost(false);
      }
    }
    this.hostId = newHostId;
    Trigger.trigger(
      this,
      {
        file: 'members',
        function: 'locusHostUpdate'
      },
      EVENT_TRIGGERS.MEMBERS_HOST_UPDATE,
      {
        activeHostId: newHostId,
        endedHostId: oldHostId
      }
    );
  }

  /**
   * when new participant updates come in, both delta and full participants, update them in members collection
   * delta object in the event will have {updated, added} and full will be the full membersCollection
   * @param {Object} payload
   * @event members:update {delta, full}
   * @returns {undefined}
   * @memberof Members
   */
  locusParticipantsUpdate(payload) {
    if (payload) {
      const delta = this.handleLocusInfoUpdatedParticipants(payload);
      const full = this.handleMembersUpdate(delta); // SDK should propagate the full list for both delta and non delta updates

      Trigger.trigger(
        this,
        {
          file: 'members',
          function: 'locusParticipantsUpdate'
        },
        EVENT_TRIGGERS.MEMBERS_UPDATE,
        {
          delta,
          full
        }
      );
    }
  }

  locusMediaSharesUpdate(payload) {
    const currentContent = payload.current;
    const previousContent = payload.previous;
    let whoSharing = null;
    let whoStopped = null;

    if (currentContent && currentContent.contentId) {
      if (currentContent.disposition === FLOOR_ACTION.GRANTED) {
        whoSharing = currentContent.contentId;
        whoStopped = previousContent && previousContent.contentId;
      }
      else if (currentContent.disposition === FLOOR_ACTION.RELEASED) {
        whoStopped = currentContent.contentId;
      }
    }
    if (whoSharing) {
      const shareMember = this.membersCollection.get(whoSharing);

      if (shareMember) {
        shareMember.setIsContentSharing(true);
      }
    }
    if (whoStopped) {
      const stopMember = this.membersCollection.get(whoStopped);

      if (stopMember) {
        stopMember.setIsContentSharing(false);
      }
    }
    this.mediaShareContentId = whoSharing;
    Trigger.trigger(
      this,
      {
        file: 'members',
        function: 'locusMediaSharesUpdate'
      },
      EVENT_TRIGGERS.MEMBERS_CONTENT_UPDATE,
      {
        activeContentSharingId: whoSharing,
        endedContentSharingId: whoStopped
      }
    );
  }

  locusUrlUpdate(payload) {
    if (payload) {
      this.setLocusUrl(null, payload);
    }
  }

  locusFullStateTypeUpdate(payload) {
    // TODO: at some point there could be a timing issue here, for updating each member
    // ie., if the type changes AND there is no locus update, then each member will not know the type of call
    // which means they cannot determine isMutable && isRemovable
    // for now this scenario is impossible to occur since we always get a locus update when the type changes
    // except for in delta locus meetings, but in that case, the type will always have been set differently
    // from the outset anyway
    if (payload) {
      this.setType(payload);
    }
  }

  /**
   * sets values in the members collection for updated and added properties from delta
   * @param {Object} membersUpdate {updated: [], added: []}
   * @returns {Object} membersCollection
   * @memberof Members
   */
  handleMembersUpdate(membersUpdate) {
    if (membersUpdate) {
      if (membersUpdate.updated) {
        this.constructMembers(membersUpdate.updated);
      }
      if (membersUpdate.added) {
        this.constructMembers(membersUpdate.added);
      }
    }

    return this.membersCollection.getAll();
  }

  /**
   * set members to the member collection from each updated/added lists as passed in
   * @param {Array} list
   * @returns {undefined}
   * @memberof Members
   */
  constructMembers(list) {
    list.forEach((member) => {
      this.membersCollection.set(member.id, member);
    });
  }

  /**
   * @param {Object} payload
   * @returns {Object}
   * @memberof Members
   */
  handleLocusInfoUpdatedParticipants(payload) {
    this.hostId = payload.hostId || this.hostId;
    this.selfId = payload.selfId || this.selfId;
    if (!payload.participants) {
      LoggerProxy.logger.warn('members/index->handleLocusInfoUpdatedParticipants#participants payload is missing.');
    }
    const memberUpdate = this.update(payload.participants);

    return memberUpdate;
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} locusUrl optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setLocusUrl(locus, locusUrl = null) {
    if (locusUrl) {
      this.locusUrl = locusUrl;
    }
    else if (locus && (locus.locusUrl || locus.url)) {
      this.locusUrl = locus.locusUrl || locus.url;
    }
    else {
      throw new ParameterError(new Error('Setting locusUrl for the Members module should be done with a locus object or locusUrl'));
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} hostId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setHostId(locus, hostId = null) {
    if (hostId) {
      this.hostId = hostId;
    }
    else if (locus) {
      this.hostId = locus && locus.owner && locus.owner.info ? locus.owner.info : null;
    }
    else {
      throw new ParameterError(new Error('Setting hostid for the Members module should be done with a locus object or hostId'));
    }
  }

  setType(fullState, type = null) {
    if (type) {
      this.type = type;
    }
    else if (fullState) {
      this.type = (fullState && fullState.type) || null;
    }
    else {
      throw new ParameterError(new Error('Setting type for the Members module should be done with a fullstate object or type string'));
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} selfId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setSelfId(locus, selfId = null) {
    if (selfId) {
      this.selfId = selfId;
    }
    else if (locus) {
      this.selfId = locus && locus.self && locus.self.person && locus.self.person.id ? locus.self.person.id : null;
    }
    else {
      throw new ParameterError(new Error('Setting selfid for the Members module should be done with a locus object or selfId'));
    }
  }

  /**
   * update the locus Url
   * @param {Object} locus
   * @param {String} contentId optional, takes precedence
   * @throws {Error}
   * @returns {undefined}
   * @memberof Members
   */
  setMediaShareContentId(locus, contentId) {
    if (contentId) {
      this.mediaShareContentId = contentId;
    }
    else if (locus) {
      const contentMediaShare =
        locus.mediaShares &&
        locus.mediaShares.length &&
        locus.mediaShares.find((mediaShare) => mediaShare.name === CONTENT);

      this.mediaShareContentId =
        (contentMediaShare &&
          contentMediaShare.floor &&
          contentMediaShare.floor.beneficiary &&
          contentMediaShare.floor.beneficiary.id) ||
        null;
    }
    else {
      throw new ParameterError(new Error('Setting hostid for the Members module should be done with a locus object or hostId'));
    }
  }

  /**
   * find all the updates, and added members
   * removed/left members will end up in updates
   * each array contains only members
   * @param {Array} participants the locus participants
   * @returns {Object} {added: {Array}, updated: {Array}}
   * @memberof Members
   */
  update(participants) {
    const membersUpdate = {added: [], updated: []};

    if (participants) {
      participants.forEach((participant) => {
        if (participant.hideInRoster) {
          return;
        }
        const existing = this.membersCollection.get(participant.id);

        if (existing) {
          // TODO: compare existing member to new participant coming in properties and determine if updated (this helps for non delta events)
          // on client re renders, but we will have to determine what values to compare to determine difference, premature optimization
          membersUpdate.updated.push(
            new Member(participant, {
              selfId: this.selfId,
              hostId: this.hostId,
              contentSharingId: this.mediaShareContentId,
              type: this.type
            })
          );
        }
        else {
          membersUpdate.added.push(
            new Member(participant, {
              selfId: this.selfId,
              hostId: this.hostId,
              contentSharingId: this.mediaShareContentId,
              type: this.type
            })
          );
        }
      });
    }

    return membersUpdate;
  }

  /**
   * adds a guest Member to the associated meeting
   * @param {String} invitee
   * @param {Boolean} alertIfActive optional parameter
   * @returns {Promise}
   * @memberof Members
   */
  addMember(invitee, alertIfActive) {
    if (!this.locusUrl) {
      return Promise.reject(new ParameterError(new Error('The associated locus url for this meeting object must be defined.')));
    }
    if (MembersUtil.isInvalidInvitee(invitee)) {
      return Promise.reject(
        new ParameterError(new Error('The invitee must be defined with either a valid email, or emailAddress property.'))
      );
    }
    const options = MembersUtil.generateAddMemberOptions(invitee, this.locusUrl, alertIfActive);

    return this.membersRequest.addMembers(options);
  }

  /**
   * admits waiting members (invited guests to meeting)
   * @param {Array} memberIds
   * @returns {Promise}
   * @memberof Members
   */
  admitMembers(memberIds) {
    if (isEmpty(memberIds)) {
      return Promise.reject(new ParameterError(new Error('No member ids provided to admit.')));
    }
    const options = MembersUtil.generateAdmitMemberOptions(memberIds, this.locusUrl);

    return this.membersRequest.admitMember(options);
  }

  removeMember(memberId) {
    if (!this.locusUrl) {
      return Promise.reject(new ParameterError(new Error('The associated locus url for this meeting object must be defined.')));
    }
    if (!memberId) {
      return Promise.reject(new ParameterError(new Error('The member id must be defined to remove the member.')));
    }
    const options = MembersUtil.generateRemoveMemberOptions(memberId, this.locusUrl);

    return this.membersRequest.removeMember(options);
  }

  muteMember(memberId, mute) {
    if (!this.locusUrl) {
      return Promise.reject(new ParameterError(new Error('The associated locus url for this meetings members object must be defined.')));
    }
    if (!memberId) {
      return Promise.reject(new ParameterError(new Error('The member id must be defined to mute the member.')));
    }
    const options = MembersUtil.generateMuteMemberOptions(memberId, mute, this.locusUrl);

    return this.membersRequest.muteMember(options);
  }

  transferHostToMember(memberId, moderator) {
    if (!this.locusUrl) {
      return Promise.reject(new ParameterError(new Error('The associated locus url for this meetings members object must be defined.')));
    }
    if (!memberId) {
      return Promise.reject(new ParameterError(new Error('The member id must be defined to transfer host to the member.')));
    }
    const options = MembersUtil.generateTransferHostMemberOptions(memberId, moderator, this.locusUrl);

    return this.membersRequest.transferHostToMember(options);
  }
}
