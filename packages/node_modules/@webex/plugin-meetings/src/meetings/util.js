import {
  deconstructHydraId
} from '@webex/common';

import {
  _LOCUS_ID_,
  _INCOMING_,
  _CREATED_,
  LOCUSEVENT,
  CORRELATION_ID,
  UUID_REG
} from '../constants';
import ParameterError from '../common/errors/parameter';

const MeetingsUtil = {};

MeetingsUtil.extractDestination = (destination, type) => {
  let dest = destination;

  if (type === _LOCUS_ID_) {
    if (!(destination && destination.url)) {
      throw new ParameterError('You cannot create a meeting by locus without a locus.url defined');
    }
    const temp = destination.url.split('/');

    dest = temp[temp.length - 1];
  }

  // If the destination is a UUID, assume it is an internal conversation ID.
  if (UUID_REG.test(dest)) {
    return dest;
  }

  // Next, assume it is a valid Hydra room ID.
  // If decoding fails, it is a SIP or other destination.
  // if the id is not present we will use the default destination
  return deconstructHydraId(dest).id || dest;
};

MeetingsUtil.getMeetingAddedType = (type) => (type === _LOCUS_ID_ ? _INCOMING_ : _CREATED_);

MeetingsUtil.handleRoapMercury = (envelope, meetingCollection) => {
  const {data} = envelope;
  const {eventType} = data;

  if (eventType === LOCUSEVENT.MESSAGE_ROAP) {
    const meeting = meetingCollection.getByKey(CORRELATION_ID, data.correlationId);

    if (meeting) {
      meeting.roap.roapEvent(data);
    }
  }
};

MeetingsUtil.checkForCorrelationId = (deviceUrl, locus) => {
  let devices = [];

  if (locus) {
    if (locus && locus.self && locus.self.devices) {
      devices = locus.self.devices;
    }

    const foundDevice = devices.find((device) => device.url === deviceUrl);

    if (foundDevice && foundDevice.correlationId) {
      return foundDevice.correlationId;
    }
  }

  return false;
};

export default MeetingsUtil;
