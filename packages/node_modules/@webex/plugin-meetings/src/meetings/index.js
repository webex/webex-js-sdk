/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
import '@ciscospark/internal-plugin-mercury';

import {SparkPlugin} from '@ciscospark/spark-core';

import LoggerProxy from '../common/logs/logger-proxy';
import Trigger from '../common/events/trigger-proxy';
import Events from '../common/events/events-proxy';
import {
  MEETINGS,
  EVENTS,
  EVENT_TRIGGERS,
  READY,
  LOCUSEVENT,
  LOCUS_URL,
  ROAP,
  _LOCUS_ID_,
  _INCOMING_
} from '../constants';
import MeetingInfo from '../meeting-info';
import Meeting from '../meeting';
import PersonalMeetingRoom from '../personal-meeting-room';
import Reachability from '../reachability';
import Request from '../meetings/request';

import MeetingCollection from './collection';
import MeetingsUtil from './util';

/**
 * Meetings Ready Event
 * Emitted when the meetings instance on spark is ready
 * @event meetings:ready
 * @instance
 * @memberof Meetings
 */

/**
  * Meeting Removed Event
  * Emitted when a meeting was removed from the cache of meetings
  * @event meeting:removed
  * @instance
  * @type {Object}
  * @property {Meeting} meeting the removed meeting
  * @property {Object} response the server response
  * @property {String} type what type of meeting it was
  * @memberof Meetings
  */

/**
 * Maintain a cache of meetings and sync with services.
 * @class
 */
export default class Meetings extends SparkPlugin {
  namespace = MEETINGS;

  /**
   * Initializes the Meetings Plugin
   * @constructor
   * @public
   * @memberof Meetings
   */
  constructor(...args) {
    super(...args);
    /**
     * The MeetingInfo object to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    this.meetingInfo = new MeetingInfo({}, {parent: this.spark});
    /**
     * The Meetings request to interact with server
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    this.request = new Request({}, {parent: this.spark});
    this.meetingCollection = new MeetingCollection();
    /**
     * The PersonalMeetingRoom object to interact with server
     * @instance
     * @type {Object}
     * @public
     * @memberof Meetings
     */
    this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.spark});
    /**
     * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
     * starts as null
     * @instance
     * @type {Object}
     * @private
     * @memberof Meetings
     */
    this.reachability = null;
    this.onReady();
  }

  /**
   * handle locus events and takes meeting actions with them as they come in
   * @param {Object} data a locus event
   * @param {String} data.locusUrl
   * @param {Object} data.locus
   * @param {String} data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */
  handleLocusEvent(data) {
    let meeting = null;
    meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locusUrl);
    if (!meeting) {
      // TODO: create meeting when we get a meeting object
      // const checkForEnded = (locus) => {
      // TODO: you already ended the meeting but you got an event later
      // Mainly for 1:1 Callsor meeting
      // Happens mainly after refresh

      // 1:1 Meeting
      // 1)  You ended a call before but you got a mercury event
      // Make sure end the call and cleanup the meeting only if the mercury
      // event says so
      // 2) Maintain lastSync time in the meetings object which helps to compare
      // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid

      // For space Meeting
      // Check the locus object and see who has joined

      // };

      // rather then locus object change to locus url
      this.create(data.locus, _LOCUS_ID_).then((newMeeting) => {
        meeting = newMeeting;
        if (data.eventType === LOCUSEVENT.DIFFERENCE) {
          // its a delta object and we have a new meeting
          newMeeting.locusInfo.initialSetup(data.locus, meeting);
        }
        else {
          // Its a new meeting and have a fresh locus object
          newMeeting.locusInfo.initialSetup(data.locus);
        }
      })
        .finally(() => {
          // Had to put `meeting:added here as the parsing of the locus object is done here
          Trigger.trigger(this, EVENT_TRIGGERS.MEETING_ADDED, {
            meeting,
            type: _INCOMING_
          });
        });
    }
    else {
      meeting.locusInfo.parse(meeting, data);
    }
  }

  /**
   * handles locus events through mercury that are not roap
   * @param {Object} envelope
   * @param {Object} envelope.data
   * @param {String} envelope.data.eventType
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */
  handleLocusMercury(envelope) {
    const {data} = envelope;
    const {eventType} = data;
    if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {
      this.handleLocusEvent(data);
    }
  }

  /**
   * registers for locus and roap mercury events
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */
  listenForEvents() {
    this.spark.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {
      this.handleLocusMercury(envelope);
    });
    this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {
      MeetingsUtil.handleRoapMercury(envelope, this.meetingCollection);
    });
  }

  /**
   * listens for internal events and triggers correct top level function
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */
  listenInternal() {
    Events.on(EVENTS.DESTROY_MEETING, (payload) => {
      this.destroy(payload.meeting, payload.response, payload.type);
    });
  }

  /**
   * @returns {undefined}
   * @private
   * @memberof Meetings
   */
  onReady() {
    this.spark.once(READY, () => {
      LoggerProxy.setLogger(this.spark.logger);
      if (this.spark.canAuthorize) {
        this.listenForEvents();
        this.listenInternal();
        Trigger.trigger(this, EVENT_TRIGGERS.MEETINGS_READY);
      }
    });
  }

  /**
   * initializes the reachability instance for Meetings
   * @returns {undefined}
   * @public
   * @memberof Meetings
   */
  setReachability() {
    this.reachability = new Reachability({}, {parent: this.spark});
  }

  /**
   * gets the reachability instance for Meetings
   * @returns {Reachability}
   * @public
   * @memberof Meetings
   */
  getReachability() {
    return this.reachability;
  }

  /**
   * initializes and starts gathering reachability for Meetings
   * @returns {undefined}
   * @public
   * @memberof Meetings
   */
  startReachability() {
    if (!this.reachability) {
      this.setReachability();
    }
    this.getReachability().gatherReachability();
  }

  /**
   * gets the personal meeting room instance, for saved PMR values for this user
   * @returns {PersonalMeetingRoom}
   * @public
   * @memberof Meetings
   */
  getPersonalMeetingRoom() {
    return this.personalMeetingRoom;
  }

  /**
   * @param {Meeting} meeting
   * @param {Object} response
   * @param {String} type
   * @returns {Object}
   * @private
   * @memberof Meetings
   */
  destroy(meeting, response, type) {
    if (!meeting || !meeting.id) {
      throw new Error('Cannot remove a meeting without an id from the MeetingCollection.');
    }
    this.meetingCollection.delete(meeting.id);
    Trigger.trigger(this, EVENT_TRIGGERS.MEETING_REMOVED, {
      meeting,
      response,
      type
    });
    return response;
  }

  /**
   * Create a meeting.
   * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
   * @param {string} type - the optional specified type, such as locusId
   * @returns {Promise} A new Meeting.
   * @public
   * @memberof Meetings
   */
  create(destination, type = null) {
    // TODO: type should be from a dictionary
    // Check if there is already meeting
    const meeting = this.meetingCollection.getByKey('sipUri', destination);
    if (!meeting) {
      return this.createMeeting(destination, type);
    }
    return Promise.resolve(meeting);
  }

  /**
   * @param {String} destination see create()
   * @param {String} type see create()
   * @returns {Promise} a new meeting instance complete with meeting info and destination
   * @private
   * @memberof Meetings
   */
  createMeeting(destination, type = null) {
    const meeting = new Meeting(
      {
        userId: this.spark.internal.device.userId,
        deviceUrl: this.spark.internal.device.url,
        roapSeq: 0,
        locus: type === _LOCUS_ID_ ? destination : null // pass the locus object if present
      },
      {
        parent: this.spark
      }
    );

    this.meetingCollection.set(meeting);

    return this.meetingInfo
      .fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type)
      .then((info) => {
        meeting.parseMeetingInfo(info);
        meeting.meetingInfo = info;
        return meeting;
      })
      .catch((err) => {
        LoggerProxy.logger.error(`Meetings->createMeeting#Error ${err} fetching /meetingInfo for creation, continuing.`);

        return meeting;
      })
      .finally(() => {
        // For type LOCUS_ID we need to parse the locus object to get the information
        // about the caller and callee
        // TODO: check for a better solution
        if (type === _LOCUS_ID_) {
          return;
        }

        if (!meeting.sipUri) {
          meeting.setSipUri(destination);
        }
        // TODO: check if we have to move this to parser
        const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);

        // We typically shouldn't need to trigger both and event and return a promise.
        // Is this a special case? We want to make the public API usage as simple as possible.
        Trigger.trigger(this, EVENT_TRIGGERS.MEETING_ADDED, {
          meeting,
          type: meetingAddedType
        });
      });

    // Create the meeting calling the necessary service endpoints.

    // Internally, there are many more destinations:
    //
    // - locusID
    // - meetingURL
    // - globalMeetingID, e.g, *00*meetingID
    // - meetingID
    // - meetingURL
    // - PSTN
    // - phone number
    //
    // Our job is to determine the appropriate one
    // and its corresponding service so that developers
    // need only sipURL or spaceID to get a meeting
    // and its ID, but have the option to use createWithType()
    // and specify those types to get meetingInfo
  }

  /**
   * get a specifc meeting given it's type matched to the value, i.e., locus url
   * @param {String} type
   * @param {Object} value
   * @returns {Meeting}
   * @public
   * @memberof Meetings
   */
  getMeetingByType(type, value) {
    return this.meetingCollection.getByKey(type, value);
  }

  /**
   * Get all meetings.
   * @param {object} options
   * @param {object} options.startDate - get meetings after this start date
   * @param {object} options.endDate - get meetings before this end date
   * @returns {Object} All active and scheduled meetings.
   * @public
   * @memberof Meetings
   */
  getAllMeetings(options = {}) {
    // Options may include other parameters to filter this collection
    // of meetings.
    return this.meetingCollection.getAll(options);
  }

  /**
   * syncs all the meeting from server
   * @returns {undefined}
   * @public
   * @memberof Meetings
   */
  syncMeetings() {
    return this.request.getActiveMeetings().then((locus) => {
      if (locus.loci && locus.loci.length > 0) {
        locus.loci.forEach((locus) => {
          const meeting = this.meetingCollection.getByKey(LOCUS_URL, locus.url);
          if (meeting) {
            meeting.locusInfo.onFullLocus(locus);
          }
          else {
            this.create(locus, _LOCUS_ID_)
              .then((meeting) => {
                meeting.locusInfo.initialSetup(locus);
              });
          }
        });
      }
    });
  }

  /**
   * Get all scheduled meetings.
   * @param {object} options
   * @param {object} options.startDate - get meetings after this start date
   * @param {object} options.endDate - get meetings before this end date
   * @returns {Object} All scheduled meetings.
   * @memberof Meetings
   */
  getScheduledMeetings() {
    return this.meetingCollection.getAll({scheduled: true});
  }
}
