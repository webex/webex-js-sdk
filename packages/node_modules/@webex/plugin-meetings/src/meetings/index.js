/*!
  * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
*/

import '@webex/internal-plugin-mercury';
import {forEach} from 'lodash';
import {WebexPlugin} from '@webex/webex-core';

import Metrics from '../metrics';
import {trigger, eventType} from '../metrics/config';
import LoggerConfig from '../common/logs/logger-config';
import StaticConfig from '../common/config';
import LoggerProxy from '../common/logs/logger-proxy';
import LoggerRequest from '../common/logs/request';
import Trigger from '../common/events/trigger-proxy';
import Media from '../media';
import {
  MEETINGS,
  EVENTS,
  EVENT_TRIGGERS,
  READY,
  LOCUSEVENT,
  LOCUS_URL,
  ROAP,
  ONLINE,
  OFFLINE,
  _MEETING_,
  _JOIN_,
  _LOCUS_ID_,
  _INCOMING_,
  LOCUS,
  CORRELATION_ID,
  SIP_URI,
  _LEFT_,
  _ID_,
  MEETING_REMOVED_REASON,
  _CONVERSATION_URL_,
  CONVERSATION_URL
} from '../constants';
import MeetingInfo from '../meeting-info';
import Meeting from '../meeting';
import PersonalMeetingRoom from '../personal-meeting-room';
import Reachability from '../reachability';
import Request from '../meetings/request';
import StatsAnalyzer from '../analyzer/analyzer';
import StatsCalculator from '../analyzer/calculator';

import MeetingCollection from './collection';
import MeetingsUtil from './util';


/**
   * Meetings Ready Event
   * Emitted when the meetings instance on webex is ready
   * @event meetings:ready
   * @instance
   * @memberof Meetings
   */

/**
   * Meetings Network Disconnected Event
   * Emitted when the meetings instance is disconnected from
   * the internal mercury server
   * @event network:disconnected
   * @instance
   * @memberof Meetings
   */

/**
 * Meetings Registered Event
 * Emitted when the meetings instance has been registered and listening
 * @event meetings:registered
 * @instance
 * @memberof Meetings
 */

/**
    * Meeting Removed Event
    * Emitted when a meeting was removed from the cache of meetings
    * @event meeting:removed
    * @instance
    * @type {Object}
    * @property {String} meetingId the removed meeting
    * @property {Object} response the server response
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
    * Meeting Added Event
    * Emitted when a meeting was added to the cache of meetings
    * @event meeting:added
    * @instance
    * @type {Object}
    * @property {String} meetingId the added meeting
    * @property {String} type what type of meeting it was
    * @memberof Meetings
    */

/**
   * Maintain a cache of meetings and sync with services.
   * @class
   */
export default class Meetings extends WebexPlugin {
    namespace = MEETINGS;

    /**
     * Initializes the Meetings Plugin
     * @constructor
     * @public
     * @memberof Meetings
     */
    constructor(...args) {
      super(...args);
      /**
       * The MeetingInfo object to interact with server
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */
      this.meetingInfo = new MeetingInfo({}, {parent: this.webex});
      /**
       * The Meetings request to interact with server
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */
      this.request = new Request({}, {parent: this.webex});
      /**
       * Log upload request helper
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */
      this.loggerRequest = new LoggerRequest({webex: this.webex});
      this.meetingCollection = new MeetingCollection();
      /**
       * The PersonalMeetingRoom object to interact with server
       * @instance
       * @type {Object}
       * @public
       * @memberof Meetings
       */
      this.personalMeetingRoom = new PersonalMeetingRoom({}, {parent: this.webex});
      /**
       * The Reachability object to interact with server, starts as null until {@link Meeting#setReachability} is called
       * starts as null
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */
      this.reachability = null;

      /**
       * If the meetings plugin has been registered and listening via {@link Meetings#register}
       * @instance
       * @type {Boolean}
       * @public
       * @memberof Meetings
       */
      this.registered = false;

      /**
       * The public interface for the internal Media util files. These are helpful to expose outside the context
       * of a meeting so that a user can access media without creating a meeting instance.
       * @instance
       * @type {Object}
       * @private
       * @memberof Meetings
       */
      this.media = {
        getUserMedia: Media.getUserMedia
      };

      this.onReady();

      MeetingsUtil.triggerH264Codec();
      Metrics.initialSetup(this.meetingCollection, this.webex);
    }

    /**
     * handle locus events and takes meeting actions with them as they come in
     * @param {Object} data a locus event
     * @param {String} data.locusUrl
     * @param {Object} data.locus
     * @param {String} data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    handleLocusEvent(data) {
      let meeting = null;

      // getting meeting by correlationId. This will happen for the new event
      // Either the locus
      // TODO : Add check for the callBack Address
      meeting = this.meetingCollection.getByKey(LOCUS_URL, data.locusUrl) ||
      this.meetingCollection.getByKey(CORRELATION_ID, MeetingsUtil.checkForCorrelationId(this.webex.internal.device.url, data.locus)) ||
      this.meetingCollection.getByKey(SIP_URI, data.locus.self && data.locus.self.callbackInfo && data.locus.self.callbackInfo.callbackAddress) ||
      this.meetingCollection.getByKey(CONVERSATION_URL, data.locus.conversationUrl);

      // Special case when locus has got replaced, This only happend once if a replace locus exists
      // https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-changing-mid-call

      if (data.locus && data.locus.replaces && data.locus.replaces.length > 0) {
        // Findes the first occurence of the meeting in the collection with same locus url
        meeting = data.locus.replaces.some((replacedLocus) => this.meetingCollection.getByKey(LOCUS_URL, replacedLocus.locusUrl));
      }

      if (!meeting) {
        // TODO: create meeting when we get a meeting object
        // const checkForEnded = (locus) => {
        // TODO: you already ended the meeting but you got an event later
        // Mainly for 1:1 Callsor meeting
        // Happens mainly after refresh

        // 1:1 Meeting
        // 1)  You ended a call before but you got a mercury event
        // Make sure end the call and cleanup the meeting only if the mercury
        // event says so
        // 2) Maintain lastSync time in the meetings object which helps to compare
        // If the meeting came befor or after the sync . ANy meeting start time before the sync time is invalid

        // For space Meeting
        // Check the locus object and see who has joined

        // };
        // rather then locus object change to locus url

        if (data.locus && data.locus.fullState && data.locus.fullState.state === LOCUS.STATE.INACTIVE) {
          // just ignore the event as its already ended and not active
          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        }


        // When its wireless share or guest and user leaves the meeting we dont have to keep the meeting object
        // Any future events will be neglected

        if (data.locus && data.locus.self && (data.locus.self.state === _LEFT_ && data.locus.self.removed === true)) {
          // just ignore the event as its already ended and not active
          LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Locus event received for meeting, after it was ended.');

          return;
        }

        this.create(data.locus, _LOCUS_ID_).then((newMeeting) => {
          meeting = newMeeting;

          if (data.eventType === LOCUSEVENT.DIFFERENCE) {
            // its a delta object and we have a new meeting
            meeting.locusInfo.initialSetup(data.locus, meeting);
          }
          else {
            // Its a new meeting and have a fresh locus object
            meeting.locusInfo.initialSetup(data.locus);
          }
        }).catch((e) => {
          console.log(e);
        })
          .finally(() => {
            // There will be cases where locus event comes in gets created and deleted because its a 1:1 and meeting gets deleted
            // because the other user left so before sending 'added' event make sure it exists in the collection

            if (this.getMeetingByType(_ID_, meeting.id)) {
            // Had to put `meeting:added here as the parsing of the locus object is done here
              Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});

              Metrics.postEvent({event: eventType.REMOTE_STARTED, meeting, data: {trigger: trigger.MERCURY_EVENT}});
              Trigger.trigger(
                this,
                {
                  file: 'meetings',
                  function: 'handleLocusEvent'
                },
                EVENT_TRIGGERS.MEETING_ADDED,
                {
                  meeting,
                  type: meeting.type === _MEETING_ ? _JOIN_ : _INCOMING_
                }
              );
            }
            else {
              // Meeting got added but was not found in the collection. It might have got destroyed
              LoggerProxy.logger.warn('Meetings:index#handleLocusEvent --> Created and destroyed meeting object before sending an event');
            }
          });
      }
      else {
        Metrics.postEvent({event: eventType.NOTIFICATION_RECEIVED, meeting, data: {trigger: trigger.MERCURY_EVENT}});
        meeting.locusInfo.parse(meeting, data);
      }
    }

    /**
     * handles locus events through mercury that are not roap
     * @param {Object} envelope
     * @param {Object} envelope.data
     * @param {String} envelope.data.eventType
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    handleLocusMercury(envelope) {
      const {data} = envelope;
      const {eventType} = data;

      if (eventType && eventType !== LOCUSEVENT.MESSAGE_ROAP) {
        this.handleLocusEvent(data);
      }
    }


    /**
     * handles mecury offline event
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    handleMercuryOffline() {
      Trigger.trigger(
        this,
        {
          file: 'meetings/index',
          function: 'handleMercuryOffline'
        },
        EVENT_TRIGGERS.MEETINGS_NETWORK_DISCONNECTED,
      );
    }


    /**
     * registers for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    listenForEvents() {
      this.webex.internal.mercury.on(LOCUSEVENT.LOCUS_MERCURY, (envelope) => {
        this.handleLocusMercury(envelope);
      });
      this.webex.internal.mercury.on(ROAP.ROAP_MERCURY, (envelope) => {
        MeetingsUtil.handleRoapMercury(envelope, this.meetingCollection);
      });

      this.webex.internal.mercury.on(ONLINE, () => {
        this.syncMeetings();
      });

      this.webex.internal.mercury.on(OFFLINE, () => {
        this.handleMercuryOffline();
      });
    }

    /**
     * stops listening for locus and roap mercury events
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    stopListeningForEvents() {
      this.webex.internal.mercury.off(LOCUSEVENT.LOCUS_MERCURY);
      this.webex.internal.mercury.off(ROAP.ROAP_MERCURY);
      this.webex.internal.mercury.off(ONLINE);
    }

    /**
     * @returns {undefined}
     * @private
     * @memberof Meetings
     */
    onReady() {
      this.webex.once(READY, () => {
        StaticConfig.set(this.config);
        LoggerConfig.set(this.config.logging);
        LoggerProxy.set(this.webex.logger);
        Trigger.trigger(
          this,
          {
            file: 'meetings',
            function: 'onReady'
          },
          EVENT_TRIGGERS.MEETINGS_READY
        );
      });
    }

    /**
     * Explicitly sets up the meetings plugin by registering
     * the device, connecting to mercury, and listening for locus events.
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */
    register() {
      if (!this.webex.canAuthorize) {
        LoggerProxy.logger.error('Meetings:index#register --> ERROR, Unable to register, SDK cannot authorize');

        return Promise.reject(new Error('SDK cannot authorize'));
      }

      if (this.registered) {
        LoggerProxy.logger.info('Meetings:index#register --> INFO, Meetings plugin already registered');

        return Promise.resolve();
      }

      return this.webex.internal.device.register()
        .then(() => this.webex.internal.mercury.connect())
        .then(() => {
          this.listenForEvents();
          Trigger.trigger(
            this,
            {
              file: 'meetings',
              function: 'register'
            },
            EVENT_TRIGGERS.MEETINGS_REGISTERED
          );
          this.registered = true;
        })
        .catch((error) => {
          LoggerProxy.logger.error(`Meetings:index#register --> ERROR, Unable to register, ${error.message}`);

          return Promise.reject(error);
        });
    }

    /**
     * Explicitly tears down the meetings plugin by deregistering
     * the device, disconnecting from mercury, and stops listening to locus events
     *
     * @returns {Promise}
     * @public
     * @memberof Meetings
     */
    unregister() {
      if (!this.registered) {
        LoggerProxy.logger.info('Meetings:index#unregister --> INFO, Meetings plugin already unregistered');

        return Promise.resolve();
      }

      this.stopListeningForEvents();

      return this.webex.internal.mercury.disconnect()
        .then(() => this.webex.internal.device.unregister())
        .then(() => {
          Trigger.trigger(
            this,
            {
              file: 'meetings',
              function: 'unregister'
            },
            EVENT_TRIGGERS.MEETINGS_UNREGISTERED
          );
          this.registered = false;
        });
    }

    /**
     * Uploads logs to the webex services for tracking
     * @param {Object} [options={}]
     * @param {String} [options.feedbackId] ID used for tracking
     * @param {String} [options.locusId]
     * @param {Stirng} [options.correlationId]
     * @returns {String} feedback ID logs were submitted under
     */
    uploadLogs(options = {}) {
      return this.loggerRequest.uploadLogs(options);
    }

    /**
     * initializes the reachability instance for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */
    setReachability() {
      this.reachability = new Reachability({}, {parent: this.webex});
    }

    /**
     * gets the reachability instance for Meetings
     * @returns {Reachability}
     * @public
     * @memberof Meetings
     */
    getReachability() {
      return this.reachability;
    }

    /**
     * initializes and starts gathering reachability for Meetings
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */
    startReachability() {
      if (!this.reachability) {
        this.setReachability();
      }
      this.getReachability().gatherReachability();
    }

    /**
     * gets the personal meeting room instance, for saved PMR values for this user
     * @returns {PersonalMeetingRoom}
     * @public
     * @memberof Meetings
     */
    getPersonalMeetingRoom() {
      return this.personalMeetingRoom;
    }

    /**
     * @param {Meeting} meeting
     * @param {Object} reason
     * @param {String} type
     * @returns {Undefined}
     * @private
     * @memberof Meetings
     */
    destroy(meeting, reason) {
      if (this.config.autoUploadLogs) {
        LoggerProxy.logger.info('Meetings:index#destroy --> Meeting destroyed, uploading logs');
        const callStart = meeting.locusInfo && meeting.locusInfo.fullState ? meeting.locusInfo.fullState.lastActive : undefined;

        this.uploadLogs({
          callStart,
          correlationId: meeting.correlationId,
          feedbackId: meeting.correlationId,
          locusId: meeting.locusId
        })
          .then((uploadResult) => {
            LoggerProxy.logger.info('Meetings:index#destroy --> Upload logs for meeting completed.', uploadResult);
            Trigger.trigger(
              this,
              {
                file: 'meetings',
                function: 'destroy'
              },
              EVENT_TRIGGERS.MEETING_LOG_UPLOAD_SUCCESS,
              {
                meetingId: meeting.id,
                details: uploadResult
              }
            );
          })
          .catch((uploadError) => {
            LoggerProxy.logger.error('Meetings:index#destroy --> Unable to upload logs for meeting', uploadError);
            Trigger.trigger(
              this,
              {
                file: 'meetings',
                function: 'destroy'
              },
              EVENT_TRIGGERS.MEETING_LOG_UPLOAD_FAILURE,
              {
                meetingId: meeting.id,
                reason: uploadError
              }
            );
          });
      }

      this.meetingCollection.delete(meeting.id);
      Trigger.trigger(
        this,
        {
          file: 'meetings',
          function: 'destroy'
        },
        EVENT_TRIGGERS.MEETING_REMOVED,
        {
          meetingId: meeting.id,
          reason
        }
      );
    }

    /**
     * Create a meeting.
     * @param {string} destination - sipURL, spaceId, phonenumber, meeting link, or locus object}
     * @param {string} [type] - the optional specified type, such as locusId
     * @returns {Promise<Meeting>} A new Meeting.
     * @public
     * @memberof Meetings
     */
    create(destination, type = null) {
      // TODO: type should be from a dictionary

      // Validate meeting information based on the provided destination and
      // type. This must be performed prior to determining if the meeting is
      // found in the collection, as we mutate the destination for hydra person
      // id values.
      return this.meetingInfo.fetchInfoOptions(destination, type)
        // Catch a failure to fetch info options.
        .catch((error) => {
          LoggerProxy.logger.info(`Meetings:index#create --> INFO, unable to determine info options: ${error.message}`);
        })
        .then((options = {}) => {
          // Normalize the destination.
          const targetDest = options.wasHydraPerson ? options.destination : destination;


          // check for the conversation URL then sip Url
          let meeting = null;

          if (type === _CONVERSATION_URL_ || options.type === _CONVERSATION_URL_) {
            meeting = this.meetingCollection.getByKey(CONVERSATION_URL, targetDest);
          }

          // Attempt to collect the meeting if it exists.
          if (!meeting) {
            meeting = this.meetingCollection.getByKey(SIP_URI, targetDest);
          }


          // Validate if a meeting was found.
          if (!meeting) {
            // Create a meeting based on the normalized destination and type.
            return this.createMeeting(targetDest, type)
              .then((createdMeeting) => {
                // If the meeting was successfully created.
                if (createdMeeting && createdMeeting.on) {
                  // Create a destruction event for the meeting.
                  createdMeeting.on(EVENTS.DESTROY_MEETING, (payload) => {
                    this.destroy(createdMeeting, payload.reason);
                  });
                }
                else {
                  LoggerProxy.logger.error(`Meetings:index#create --> ERROR, meeting does not have on method, will not be destroyed, meeting cleanup impossible for meeting: ${meeting}`);
                }

                // Return the newly created meeting.
                return Promise.resolve(createdMeeting);
              });
          }

          // Return the existing meeting.
          return Promise.resolve(meeting);
        });
    }

    /**
     * @param {String} destination see create()
     * @param {String} type see create()
     * @returns {Promise} a new meeting instance complete with meeting info and destination
     * @private
     * @memberof Meetings
     */
    async createMeeting(destination, type = null) {
      const meeting = new Meeting(
        {
          userId: this.webex.internal.device.userId,
          deviceUrl: this.webex.internal.device.url,
          orgId: this.webex.internal.device.orgId,
          roapSeq: 0,
          locus: type === _LOCUS_ID_ ? destination : null // pass the locus object if present
        },
        {
          parent: this.webex
        }
      );

      this.meetingCollection.set(meeting);

      try {
        const info = await this.meetingInfo.fetchMeetingInfo(MeetingsUtil.extractDestination(destination, type), type);

        meeting.parseMeetingInfo(info);
        meeting.meetingInfo = info ? info.body : null;
      }
      catch (err) {
        // if there is no meeting info we assume its a 1:1 call or wireless share
        LoggerProxy.logger.info(`Meetings:index#createMeeting --> Info Unable to fetch meeting info for ${destination}.`);
        LoggerProxy.logger.info('Meetings:index#createMeeting --> Info assuming this destination is a 1:1 or wireless share');
        LoggerProxy.logger.debug(`Meetings:index#createMeeting --> Debug ${err} fetching /meetingInfo for creation.`);
        // We need to save this info for future reference
        meeting.destination = destination;
      }
      finally {
        // For type LOCUS_ID we need to parse the locus object to get the information
        // about the caller and callee
        // Meeting Added event will be created in `handleLocusEvent`
        if (type !== _LOCUS_ID_) {
          if (!meeting.sipUri) {
            meeting.setSipUri(destination);
          }

          // TODO: check if we have to move this to parser
          const meetingAddedType = MeetingsUtil.getMeetingAddedType(type);

          // We typically shouldn't need to trigger both and event and return a promise.
          // Is this a special case? We want to make the public API usage as simple as possible.
          Trigger.trigger(
            this,
            {
              file: 'meetings',
              function: 'createMeeting'
            },
            EVENT_TRIGGERS.MEETING_ADDED,
            {
              meeting,
              type: meetingAddedType
            }
          );
        }
      }

      return meeting;

      // Create the meeting calling the necessary service endpoints.

      // Internally, there are many more destinations:
      //
      // - locusID
      // - meetingURL
      // - globalMeetingID, e.g, *00*meetingID
      // - meetingID
      // - meetingURL
      // - PSTN
      // - phone number
      //
      // Our job is to determine the appropriate one
      // and its corresponding service so that developers
      // need only sipURL or spaceID to get a meeting
      // and its ID, but have the option to use createWithType()
      // and specify those types to get meetingInfo
    }

    /**
     * get a specifc meeting given it's type matched to the value, i.e., locus url
     * @param {String} type
     * @param {Object} value
     * @returns {Meeting}
     * @public
     * @memberof Meetings
     */
    getMeetingByType(type, value) {
      return this.meetingCollection.getByKey(type, value);
    }

    /**
     * Get all meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All currently active meetings.
     * @public
     * @memberof Meetings
     */
    getAllMeetings(options = {}) {
      // Options may include other parameters to filter this collection
      // of meetings.
      return this.meetingCollection.getAll(options);
    }

    /**
     * syncs all the meeting from server
     * @returns {undefined}
     * @public
     * @memberof Meetings
     */
    syncMeetings() {
      return this.request.getActiveMeetings().then((locusArray) => {
        const activeLocusUrl = [];

        if (locusArray.loci && locusArray.loci.length > 0) {
          locusArray.loci.forEach((locus) => {
            activeLocusUrl.push(locus.url);
            this.handleLocusEvent({
              locus,
              locusUrl: locus.url
            });
          });
        }
        if (Object.keys(this.meetingCollection.getAll()).length > 0) {
          // Some time the mercury event is missed after mercury reconnect
          // if sync returns no locus then clear all the meetings
          forEach(this.meetingCollection.getAll(), (meeting) => {
            if (!activeLocusUrl.includes(meeting.locusUrl)) {
              this.destroy(meeting, MEETING_REMOVED_REASON.NO_MEETINGS_TO_SYNC);
            }
          });
        }
      });
    }

    /**
     * Get all scheduled meetings.
     * @param {object} options
     * @param {object} options.startDate - get meetings after this start date
     * @param {object} options.endDate - get meetings before this end date
     * @returns {Object} All scheduled meetings.
     * @memberof Meetings
     */
    getScheduledMeetings() {
      return this.meetingCollection.getAll({scheduled: true});
    }

    /**
     * Get the logger instance for plugin-meetings
     * @returns {Logger}
     */
    getLogger() {
      return LoggerProxy.get();
    }

    /**
     * Get the Stats Analyzer singleton
     * @returns {StatsAnalyzer}
     * @public
     * @memberof Meetings
     */
    getAnalyzer() {
      return StatsAnalyzer;
    }

    /**
     * Get the Stats Calculator singleton
     * @returns {StatsCalculator}
     * @public
     * @memberof Meetings
     */
    getCalculator() {
      return StatsCalculator;
    }
}
