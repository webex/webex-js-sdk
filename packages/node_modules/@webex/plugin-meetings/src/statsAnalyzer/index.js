/* eslint-disable require-jsdoc */

import {types} from 'mime-types';

import EventsScope from '../common/events/events-scope';
import {EVENT_TRIGGERS} from '../constants';
import mqaConfig from '../mediaQualityMetrics/config';
import {eventType} from '../metrics/config';
import Metrics from '../metrics';

import defaultStats from './global';

console.log(mqaConfig);

export default class StatsAnalyzer extends EventsScope {
  constructor(config) {
    super();
    this.statsResults = defaultStats;
    this.config = config;
    this.correlationId = config.correlationId;
    this.mqaSentCount = 1;
    this.packetLossArraySender = {audio: [], video: [], share: []};
    this.packetLossArrayReceiver = {audio: [], video: [], share: []};
    this.lastMqaDataSent = {
      resolutions: {video: {send: {}, recv: {}}, audio: {send: {}, recv: {}}},
      video: {send: {}, recv: {}},
      audio: {send: {}, recv: {}},
      share: {send: {}, recv: {}}
    };
  }

  parseResults = (result, type, senderOrReceiver) => {
    if (!result) {
      return;
    }
    this.outboundrtp(result, type);
    this.inboundrtp(result, type);
    this.track(result, type);
    this.remotecandidate(result, type, senderOrReceiver);

    this.compareSentAndReceived(result, type);
  }

  parsePeerStats = (res) => {
    if (!res) {
      return;
    }
    this.compareSentAndReceived(res);
  }

  updateTransport() {
    // if (stats.transport && (stats.transport.bUpdated || (svrCommon && svrCommon.bUpdated))) {
    //   var tp = stats.transport.data;
    //   var protocol = (svrCommon && svrCommon.protocol) || tp.protocol;
    //   showData.common.protocol = protocol;
    //   showData.common.server = server;
    //   showData.common.localIp = tp.localIp;
    //   mqeData.peerReflexiveIP = showData.common.reflexIp = tp.reflxIp;
    //   mqeData.peerReflexiveIP = /sharing/i.test(mediaType) ? null : tp.reflxIp;
    //   showData.common.remoteIp = tp.remoteIp;
  }


  getAudioReceiverMqa(audioReceiver) {
    const mediaType = 'audio';
    const sendrecvType = 'recv';

    // collect the packets received for the last min
    audioReceiver.streams[0].common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsReceived - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsReceived;

    // Hope by hop are numbers and not percentage so we compare on what we sent the last min
    audioReceiver.common.mediaHopByHopLost = (this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost); // TODO: calculate the value
    audioReceiver.common.rtpHopByHopLost = this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost; // TODO: calculate the value
    audioReceiver.streams[0].common.rtpJitter = this.statsResults[mediaType][sendrecvType].rtpJitter;

    audioReceiver.streams[0].receivedHeight = this.statsResults.resolutions[mediaType][sendrecvType].height;
    audioReceiver.streams[0].receivedWidth = this.statsResults.resolutions[mediaType][sendrecvType].width;
    audioReceiver.streams[0].common.endToEndLost = this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost;// TODO: calculate the value
    // audioReceiver.streams[0].common.framesReceived = this.statsResults.resolutions[mediaType][sendrecvType].framesReceived - this.lastMqaDataSent.resolutions[mediaType][sendrecvType].framesReceived;
    audioReceiver.streams[0].common.receivedFrameRate = audioReceiver.streams[0].common.framesReceived / 60;
    audioReceiver.streams[0].common.receivedBitrate = (this.statsResults[mediaType][sendrecvType].totalBytesReceived - this.lastMqaDataSent[mediaType][sendrecvType].totalBytesReceived) * 8 / 60 || 0;
    //
  }


  getAudioSenderMqa(audioSender) {
    const mediaType = 'audio';
    const sendrecvType = 'send';

    audioSender.common.remoteJitter = this.statsResults[mediaType][sendrecvType].remoteJitter;
    audioSender.common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsSent - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsSent;

    // From candidate-pair
    audioSender.common.availableBitRate = this.statsResults[mediaType][sendrecvType].availableOutgoingBitrate || 0;
    // Calculate based on how much packets lost of received compated to how to the client sent

    const totalpacketsLostForaMin = this.statsResults[mediaType][sendrecvType].totalPacketsLostOnReceiver - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLostOnReceiver;

    audioSender.common.remoteLossRate = totalpacketsLostForaMin > 0 ? (totalpacketsLostForaMin) * 100 / audioSender.common.rtpPackets : 0; // This is the packets sent with in last min || 0;

    audioSender.common.roundTripTime = this.statsResults[mediaType][sendrecvType].roundTripTime * 1000 || 0;


    audioSender.streams[0].common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsSent - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsSent;

    // Calculate the outgoing bitrate
    const totalBytesSentInaMin = this.statsResults[mediaType][sendrecvType].totalBytesSent - this.lastMqaDataSent[mediaType][sendrecvType].totalBytesSent;

    console.log('sent totalBytesSentInaMin ,', totalBytesSentInaMin);
    audioSender.streams[0].common.transmittedBitrate = totalBytesSentInaMin ? (totalBytesSentInaMin) * 8 / 60 : 0;

    audioSender.streams[0].transmittedKeyFrames = this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded - this.lastMqaDataSent[mediaType][sendrecvType].totalKeyFramesEncoded;
    audioSender.streams[0].requestedKeyFrames = this.statsResults[mediaType][sendrecvType].totalFirCount - this.lastMqaDataSent[mediaType][sendrecvType].totalFirCount;
  }


  getVideoReceiverMqa(videoReceiver) {
    const mediaType = 'video';
    const sendrecvType = 'recv';

    // collect the packets received for the last min
    videoReceiver.streams[0].common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsReceived - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsReceived;

    // Hope by hop are numbers and not percentage so we compare on what we sent the last min
    videoReceiver.common.mediaHopByHopLost = (this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost); // TODO: calculate the value
    videoReceiver.common.rtpHopByHopLost = this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost; // TODO: calculate the value
    videoReceiver.streams[0].common.rtpJitter = this.statsResults[mediaType][sendrecvType].rtpJitter;
    videoReceiver.streams[0].common.endToEndLost = this.statsResults[mediaType][sendrecvType].totalPacketsLost - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLost;// TODO: calculate the value
    videoReceiver.streams[0].common.framesReceived = this.statsResults.resolutions[mediaType][sendrecvType].framesReceived - this.lastMqaDataSent.resolutions[mediaType][sendrecvType].framesReceived;
    videoReceiver.streams[0].common.receivedFrameRate = videoReceiver.streams[0].common.framesReceived / 60;
    videoReceiver.streams[0].common.receivedBitrate = (this.statsResults[mediaType][sendrecvType].totalBytesReceived - this.lastMqaDataSent[mediaType][sendrecvType].totalBytesReceived) * 8 / 60 || 0;


    //
  }

sendMqaData = () => {
  console.log(mqaConfig);
  const audioReciver = mqaConfig.intervals[0].audioReceive[0];
  const audioSender = mqaConfig.intervals[0].audioTransmit[0];
  const videoReceiver = mqaConfig.intervals[0].videoReceive[0];
  const videoSender = mqaConfig.intervals[0].videoTransmit[0];

  const mediaType = 'video';
  const sendrecvType = 'send';

  console.log('Senders Video ', this.statsResults[mediaType]);

  // videoReceiver.packetsReceived;
  // dstData.data.frameRateReceived = dstData.data.paintedFrames / (prevData.maxCount * connMonitor.GETSTATS_INTERVAL_s);

  // updateTransport();
  videoSender.common.remoteJitter = this.statsResults[mediaType][sendrecvType].remoteJitter;
  videoSender.common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsSent - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsSent;
  // videoSender.common.fecPackets = this.statsResults[mediaType][sendrecvType].fecPackets; // Not avaliable
  // videoSender.common.remoteReceiveRate = this.statsResults[mediaType][sendrecvType].reportsReceived;
  console.log('sent rtpPackets ,', videoSender.common.rtpPackets);

  // From candidate-pair
  videoSender.common.availableBitRate = this.statsResults[mediaType][sendrecvType].availableOutgoingBitrate || 0;
  // Calculate based on how much packets lost of received compated to how to the client sent

  const totalpacketsLostForaMin = this.statsResults[mediaType][sendrecvType].totalPacketsLostOnReceiver - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLostOnReceiver;

  videoSender.common.remoteLossRate = totalpacketsLostForaMin > 0 ? (totalpacketsLostForaMin) * 100 / videoSender.common.rtpPackets : 0; // This is the packets sent with in last min || 0;
  console.log('sent totalpacketsLostForaMin ,', videoSender.common.remoteLossRate);

  // TODO: convert the time to seconds
  videoSender.common.roundTripTime = this.statsResults[mediaType][sendrecvType].roundTripTime * 1000 || 0;


  videoSender.streams[0].common.rtpPackets = this.statsResults[mediaType][sendrecvType].totalPacketsSent - this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsSent;

  // Calculate the outgoing bitrate
  const totalBytesSentInaMin = this.statsResults[mediaType][sendrecvType].totalBytesSent - this.lastMqaDataSent[mediaType][sendrecvType].totalBytesSent;

  console.log('sent totalBytesSentInaMin ,', totalBytesSentInaMin);
  videoSender.streams[0].common.transmittedBitrate = totalBytesSentInaMin ? (totalBytesSentInaMin) * 8 / 60 : 0;

  videoSender.streams[0].transmittedKeyFrames = this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded - this.lastMqaDataSent[mediaType][sendrecvType].totalKeyFramesEncoded;
  videoSender.streams[0].requestedKeyFrames = this.statsResults[mediaType][sendrecvType].totalFirCount - this.lastMqaDataSent[mediaType][sendrecvType].totalFirCount;

  // From tracks //TODO: calculate a proper one
  const totalFrameSentInaMin = this.statsResults.resolutions[mediaType][sendrecvType].framesSent - this.lastMqaDataSent.resolutions[mediaType][sendrecvType].framesSent;

  videoSender.streams[0].common.transmittedFrameRate = totalFrameSentInaMin ? totalFrameSentInaMin / 60 : 0; // TODO: save last one and compare
  videoSender.streams[0].transmittedHeight = this.statsResults.resolutions[mediaType][sendrecvType].height;
  videoSender.streams[0].transmittedWidth = this.statsResults.resolutions[mediaType][sendrecvType].width;


  this.getVideoReceiverMqa(videoReceiver);
  this.getAudioSenderMqa(audioSender);
  this.getAudioSenderMqa(audioReciver);

  this.mqaSentCount = this.mqaSentCount + 1;

  mqaConfig.intervals[0].videoTransmit[0] = videoSender;
  mqaConfig.intervals[0].videoReceive[0] = videoReceiver;

  // console.log('RESULT ,', mqaConfig.intervals);


  mqaConfig.intervals[0].intervalNumber = this.mqaSentCount;

  // DO Deep copy, for some reason it takes the reference all the time rather then old value set
  this.lastMqaDataSent = JSON.parse(JSON.stringify(this.statsResults));


  // // Save last packet loss reported by the server side
  // // used to calculat the ratio when the loss happens
  // this.lastMqaDataSent[mediaType][sendrecvType].totalPacketsLostOnReceiver = this.statsResults[mediaType][sendrecvType].totalPacketsLostOnReceiver;
  // this.lastMqaDataSent[mediaType][sendrecvType].totalBytesSent = this.statsResults[mediaType][sendrecvType].totalBytesSent;

  // this.lastMqaDataSent[mediaType].recv.totalBytesReceived = this.statsResults[mediaType].recv.totalBytesReceived;


  Metrics.postEvent({event: eventType.MEDIA_QUALITY, meetingId: this.correlationId, data: {intervalData: mqaConfig.intervals[0]}});
}

  startAnalyzer = (peerconnection) => {
    this.peerconnection = peerconnection;
    this.peerconnection.onconnectionstatechange = () => {
      if (this.peerconnection.connectionState === 'closed') {
        clearInterval(this.statsInterval);
        // TODO: clear mqa stats
      }
    };
    this.statsInterval = setInterval(() => {
      this.startStats(peerconnection);
    }, this.config.analyzerInterval);

    this.mqaInterval = setInterval(() => {
      // this.statsResults;
      // Metrics.postEvent({event: eventType.MEDIA_QUALITY, meetingId: this.id, data: {intervalData: this.mqaProcessor.getData()}});
      // TODO: get the stats results and send MQA
      this.sendMqaData();
    }, this.config.mqaInterval);
  }

  startStats = (pc) => {
    const types = ['track', 'transport', 'candidate-pair', 'outbound-rtp', 'outboundrtp', 'inbound-rtp', 'inboundrtp', 'remote-inbound-rtp', 'remote-outbound-rtp'];

    pc.videoTransceiver.sender.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { this.parseResults(r, 'video', true); }
      });
    });

    pc.videoTransceiver.receiver.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { this.parseResults(r, 'video', false); }
      });
    });

    pc.audioTransceiver.sender.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { console.log('Audio stats send', r); this.parseResults(r, 'audio', true); }
      });
    });

    pc.audioTransceiver.receiver.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { console.log('Audio stats recv', r); this.parseResults(r, 'audio', false); }
      });
    });

    pc.shareTransceiver.sender.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { this.parseResults(r, 'share', true); }
      });
    });

    pc.shareTransceiver.receiver.getStats().then((res) => {
      res.forEach((r) => {
        if (types.includes(r.type)) { this.parseResults(r, 'share', false); }
      });
    });
  }

  outboundrtp = (result, type) => {
    if (!result) {
      return;
    }
    if (result.type !== 'outbound-rtp') return;
    const mediaType = type || 'audio';
    const sendrecvType = 'send';

    if (!sendrecvType) return;

    if (result.bytesSent) {
      let kilobytes = 0;

      if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesSent) {
        this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;
      }
      if (!this.statsResults.internal[mediaType][sendrecvType].framesEncoded) {
        this.statsResults.internal[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
      }
      if (!this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded) {
        this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded;
      }

      const bytes = result.bytesSent - this.statsResults.internal[mediaType][sendrecvType].prevBytesSent;

      this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;

      kilobytes = bytes / 1024;

      this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
      this.statsResults[mediaType].bytesSent = kilobytes;

      this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded - this.statsResults.internal[mediaType][sendrecvType].framesEncoded;
      this.statsResults[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded - this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded;
      this.statsResults.internal[mediaType].outboundRtpId = result.id;

      if (!this.statsResults.internal[mediaType][sendrecvType].packetsSent) {
        this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
      }

      this.statsResults[mediaType][sendrecvType].packetsSent = result.packetsSent - this.statsResults.internal[mediaType][sendrecvType].packetsSent;
      this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
      this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;

      // Data saved to send MQA metrics

      this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded = result.keyFramesEncoded;
      this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
      this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
      this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;
      this.statsResults[mediaType][sendrecvType].totalFirCount = result.firCount;
      this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
      this.statsResults[mediaType][sendrecvType].encoderImplementation = result.encoderImplementation;
      this.statsResults[mediaType][sendrecvType].qualityLimitationReason = result.qualityLimitationReason;
      this.statsResults[mediaType][sendrecvType].qualityLimitationResolutionChanges = result.qualityLimitationResolutionChanges;
      this.statsResults[mediaType][sendrecvType].retransmittedPacketsSent = result.retransmittedPacketsSent;
      this.statsResults[mediaType][sendrecvType].totalBytesSent = result.bytesSent;
      this.statsResults[mediaType][sendrecvType].headerBytesSent = result.headerBytesSent;
      this.statsResults[mediaType][sendrecvType].retransmittedBytesSent = result.retransmittedBytesSent;
    }
  };


  inboundrtp = (result, type) => {
    if (!result) {
      return;
    }
    if (result.type !== 'inbound-rtp') return;
    const mediaType = type || 'audio';
    const sendrecvType = 'recv';

    if (!sendrecvType) return;

    if (result.bytesReceived) {
      let kilobytes = 0;

      if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived) {
        this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].pliCount) {
        this.statsResults.internal[mediaType][sendrecvType].pliCount = result.pliCount;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].packetsLost) {
        this.statsResults.internal[mediaType][sendrecvType].packetsLost = result.packetsLost;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].packetsReceived) {
        this.statsResults.internal[mediaType][sendrecvType].packetsReceived = result.packetsReceived;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp) {
        this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;
      }

      const bytes = result.bytesReceived - (this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived);

      this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;

      kilobytes = bytes / 1024;
      this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
      this.statsResults[mediaType].bytesReceived = kilobytes.toFixed(1);

      this.statsResults[mediaType][sendrecvType].pliCount = result.pliCount - this.statsResults.internal[mediaType][sendrecvType].pliCount;
      this.statsResults[mediaType][sendrecvType].currentPacketsLost = result.packetsLost - this.statsResults.internal[mediaType][sendrecvType].packetsLost;
      if (this.statsResults[mediaType][sendrecvType].packetsLost < 0) {
        this.statsResults[mediaType][sendrecvType].packetsLost = 0;
      }


      this.statsResults[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;
      this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived - this.statsResults.internal[mediaType][sendrecvType].packetsReceived;
      this.statsResults.internal[mediaType][sendrecvType].packetsReceived = result.packetsReceived;

      if (this.statsResults.internal[mediaType][sendrecvType].packetsReceived === 0) {
        console.log(`No packests received for ${mediaType} `, this.statsResults.internal[mediaType][sendrecvType].packetsReceived);
      }

      //  Check the over all packet Lost ratio
      this.statsResults[mediaType][sendrecvType].avaragePacketsLostRatio = result.packetsLost / result.packetsReceived;
      this.statsResults[mediaType][sendrecvType].currentPacketLossRatio = this.statsResults[mediaType][sendrecvType].currentPacketsLost / this.statsResults.internal[mediaType][sendrecvType].packetsReceived;
      if (this.statsResults[mediaType][sendrecvType].currentPacketLossRatio > 3) {
        console.log('Packets getting lost from the receiver ', this.statsResults[mediaType][sendrecvType].currentPacketLossRatio);
      }

      this.statsResults[mediaType][sendrecvType].totalPacketsLost = result.packetsLost;
      this.packetLossArrayReceiver[mediaType].push(this.statsResults[mediaType][sendrecvType].packetsLost);
      this.statsResults[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;


      // From Thin
      this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
      this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
      this.statsResults[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
      this.statsResults[mediaType][sendrecvType].keyFramesDecoded = result.keyFramesDecoded;
      this.statsResults[mediaType][sendrecvType].decoderImplementation = result.decoderImplementation;
      this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived;

      this.statsResults[mediaType][sendrecvType].fecPacketsDiscarded = result.fecPacketsDiscarded;
      this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived;
      this.statsResults[mediaType][sendrecvType].fecPackets = result.fecPacketsReceived;
      this.statsResults[mediaType][sendrecvType].totalBytesReceived = result.bytesReceived;
      this.statsResults[mediaType][sendrecvType].headerBytesReceived = result.headerBytesReceived;
      this.statsResults[mediaType][sendrecvType].jitter = result.jitter;
    }
  };

  // TODO: check on the DTLS and ice on later
  remotecandidate = (result, type, senderOrReceiver) => {
    if (!result) {
      return;
    }
    const RemoteCandidateType = {};
    const RemoteTransport = {};
    const RemoteIpAddress = {};
    const RemoteNetworkType = {};

    if (result.type !== 'remotecandidate' && result.type !== 'remote-candidate') return;
    if (!result.id) return;

    const sendRecvType = senderOrReceiver ? 'send' : 'recv';

    if (!RemoteCandidateType[result.id]) {
      RemoteCandidateType[result.id] = [];
    }

    if (!RemoteTransport[result.id]) {
      RemoteTransport[result.id] = [];
    }

    if (!RemoteIpAddress[result.id]) {
      RemoteIpAddress[result.id] = [];
    }
    if (!RemoteNetworkType[result.id]) {
      RemoteNetworkType[result.id] = [];
    }

    if (result.candidateType && RemoteCandidateType[result.id].indexOf(result.candidateType) === 0) {
      RemoteCandidateType[result.id].push(result.candidateType);
    }

    if (result.transport && RemoteTransport[result.id].indexOf(result.transport) === 0) {
      RemoteTransport[result.id].push(result.transport);
    }

    if (result.ipAddress && RemoteIpAddress[result.id].indexOf(`${result.ipAddress}:${result.portNumber}`) === 0) {
      RemoteIpAddress[result.id].push(`${result.ipAddress}:${result.portNumber}`);
    }

    if (result.networkType && RemoteNetworkType[result.id].indexOf(result.networkType) === 0) {
      RemoteNetworkType[result.id].push(result.networkType);
    }

    this.statsResults.internal.candidates[result.id] = {
      candidateType: RemoteCandidateType[result.id],
      ipAddress: RemoteIpAddress[result.id],
      portNumber: result.portNumber,
      networkType: RemoteNetworkType[result.id],
      priority: result.priority,
      transport: RemoteTransport[result.id],
      timestamp: result.timestamp,
      id: result.id,
      type: result.type
    };

    this.statsResults.connectionType.remote.candidateType = RemoteCandidateType[result.id];
    this.statsResults.connectionType.remote.ipAddress = RemoteIpAddress[result.id];
    this.statsResults.connectionType.remote.networkType = RemoteNetworkType[result.id];
    this.statsResults.connectionType.remote.transport = RemoteTransport[result.id];

    this.statsResults[type][sendRecvType].totalRoundTripTime = result.totalRoundTripTime;
    this.statsResults[type][sendRecvType].bytesReceived = result.bytesReceived;
    this.statsResults[type][sendRecvType].bytesSent = result.bytesSent;
    this.statsResults[type][sendRecvType].packetsReceived = result.packetsReceived || undefined;
    this.statsResults[type][sendRecvType].packetsSent = result.packetsSent || undefined;
    this.statsResults[type][sendRecvType].currentRoundTripTime = result.currentRoundTripTime;
    this.statsResults[type][sendRecvType].availableOutgoingBitrate = result.availableOutgoingBitrate;
    this.statsResults[type][sendRecvType].availableIncomingBitrate = result.availableIncomingBitrate;
  };


  track = (result, mediaType) => {
    if (!result) {
      return;
    }
    if (result.type !== 'track') return;

    const sendrecvType = result.remoteSource === true ? 'recv' : 'send';

    if (result.frameWidth && result.frameHeight) {
      this.statsResults.resolutions[mediaType][sendrecvType].width = result.frameWidth;
      this.statsResults.resolutions[mediaType][sendrecvType].height = result.frameHeight;
      this.statsResults.resolutions[mediaType][sendrecvType].framesSent = result.framesSent;
      this.statsResults.resolutions[mediaType][sendrecvType].hugeFramesSent = result.hugeFramesSent;
    }

    if (mediaType === 'video') {
      this.statsResults.resolutions[mediaType][sendrecvType].framesReceived = result.framesReceived;
      this.statsResults.resolutions[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
      this.statsResults.resolutions[mediaType][sendrecvType].framesDropped = result.framesDropped;
    }


    if (result.trackIdentifier && mediaType !== 'audio') {
      this.statsResults.resolutions[mediaType][sendrecvType].trackIdentifier = result.trackIdentifier;

      const jitterBufferDelay = result && result.jitterBufferDelay && result.jitterBufferDelay;
      const jitterBufferEmittedCount = result && result.jitterBufferEmittedCount && result.jitterBufferEmittedCount;

      this.statsResults.resolutions[mediaType][sendrecvType].avgJitterDelay = jitterBufferEmittedCount && (+jitterBufferDelay / +jitterBufferEmittedCount);
    }
  };

  compareSentAndReceived = (result, type) => {
    if (!result) {
      return;
    }
    if (!['remote-inbound-rtp', 'remote-outbound-rtp'].includes(result.type)) { return; }
    const mediaType = type;

    if (!mediaType) {
      return;
    }

    if (!this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver) { this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost; }

    const currentPacketLoss = result.packetsLost - this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver;

    this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
    this.statsResults[mediaType].send.packetsLostOnReceiver = currentPacketLoss;
    this.statsResults[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
    this.statsResults[mediaType].send.remoteJitter = result.jitter;
    this.statsResults[mediaType].send.roundTripTime = result.roundTripTime;
    this.statsResults[mediaType].send.timestamp = result.timestamp;
    this.statsResults[mediaType].send.ssrc = result.ssrc;
    this.statsResults[mediaType].send.reportsReceived = result.reportsReceived;


    this.packetLossArraySender[mediaType].push(currentPacketLoss);

    // Total packloss ratio on this video section of the call
    this.statsResults[mediaType].send.overAllPacketLossRatio = this.statsResults[mediaType].send.totalPacketsLostOnReceiver > 0 ? this.statsResults[mediaType].send.totalPacketsLostOnReceiver / this.statsResults[mediaType].send.totalPacketsSent : 0;

    this.statsResults[mediaType].send.currentPacketLossRatio = this.statsResults[mediaType].send.packetsLostOnReceiver > 0 ? this.statsResults[mediaType].send.packetsLostOnReceiver / this.statsResults[mediaType].send.packetsSent : 0;

    if (this.statsResults[mediaType].send.maxPacketLossRatio < this.statsResults[mediaType].send.currentPacketLossRatio) {
      this.statsResults[mediaType].send.maxPacketLossRatio = this.statsResults[mediaType].send.currentPacketLossRatio;
    }


    if (this.statsResults[mediaType].send.currentPacketLossRatio > 9 && mediaType === 'video') {
      // Trigger downgrade video callback
      console.log('Packet Loss is high ', this.statsResults[mediaType].send.currentPacketLossRatio);
      this.emit(
        {
          file: 'statsAnalyzer',
          function: 'compareSentAndReceived'
        },
        EVENT_TRIGGERS.MEETING_HIGH_PACKETLOSS,
        {
          mediaType,
          packetLossRatio: this.statsResults[mediaType].send.currentPacketLossRatio
        }
      );
    }
  }
}

