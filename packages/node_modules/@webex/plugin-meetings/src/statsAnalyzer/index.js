
import EventsScope from '../common/events/events-scope';
import {EVENT_TRIGGERS,
  DEFAULT_GET_STATS_FILTER, CONNECTION_STATE, STATS, MQA_INTEVAL} from '../constants';
import mqaData from '../mediaQualityMetrics/config';
import LoggerProxy from '../common/logs/logger-proxy';

import defaultStats from './global';
import {
  getAudioSenderMqa,
  getAudioReceiverMqa,
  getVideoSenderMqa,
  getVideoReceiverMqa
} from './mqaUtil';


/**
  * Meeting High Packet Loss Event
  * Emitted when ever there is high packet loss detected
  * @event meeting:highPacketLoss
  * @type {Object}
  * @property {String} mediaType Type of media experiencing packet loss
  * @property {Number} packetLossRatio current packet loss ratio
  * @memberof StatsAnalyzer
  */

/**
 * Stats Analyzer class that will emit events based on detected quality
 *
 * @export
 * @class StatsAnalyzer
 * @extends {EventsScope}
 */
export default class StatsAnalyzer extends EventsScope {
  /**
   * Creates a new instance of StatsAnalyzer
   * @constructor
   * @public
   * @param {Object} config SDK Configuration Object
   */
  constructor(config) {
    super();
    this.statsResults = defaultStats;
    this.config = config;
    this.correlationId = config.correlationId;
    this.mqaSentCount = 0;
    this.lastMqaDataSent = {
      resolutions: {video: {send: {}, recv: {}}, audio: {send: {}, recv: {}}, share: {send: {}, recv: {}}},
      video: {send: {}, recv: {}},
      audio: {send: {}, recv: {}},
      share: {send: {}, recv: {}}
    };
  }

  /**
   * captures MQA data from peerconnection
   *
   * @public
   * @memberof StatsAnalyzer
   * @returns {void}
   */
  sendMqaData() {
    const audioReceiver = mqaData.intervals[0].audioReceive[0];
    const audioSender = mqaData.intervals[0].audioTransmit[0];
    const videoReceiver = mqaData.intervals[0].videoReceive[0];
    const videoSender = mqaData.intervals[0].videoTransmit[0];
    const shareSender = mqaData.intervals[0].videoTransmit[1];
    const shareReceiver = mqaData.intervals[0].videoReceive[1];

    getAudioSenderMqa({
      audioSender,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent
    });
    getAudioReceiverMqa({
      audioReceiver,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent
    });

    getVideoReceiverMqa({
      videoReceiver,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent
    });
    getVideoSenderMqa({
      videoSender,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent
    });

    // Capture mqa for share scenario

    getVideoSenderMqa({
      videoSender: shareSender,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent,
      isShareStream: true
    });

    getVideoReceiverMqa({
      videoReceiver: shareReceiver,
      statsResults: this.statsResults,
      lastMqaDataSent: this.lastMqaDataSent,
      isShareStream: true
    });


    this.mqaSentCount = this.mqaSentCount + 1;

    mqaData.intervals[0].intervalNumber = this.mqaSentCount;

    // DO Deep copy, for some reason it takes the reference all the time rather then old value set
    this.lastMqaDataSent = JSON.parse(JSON.stringify(this.statsResults));

    this.emit(
      {
        file: 'statsAnalyzer',
        function: 'sendMqaData'
      },
      EVENT_TRIGGERS.MEDIA_QUALITY,
      mqaData.intervals[0]
    );
  }

  /**
   * updated the peerconnection when changed
   *
   * @private
   * @memberof updatePeerconnection
   * @param {PeerConnection} peerConnection
   * @returns {void}
   */
  updatePeerconnection(peerConnection) {
    this.peerConnection = peerConnection;
  }

  /**
   * Starts the stats analyzer on interval
   *
   * @public
   * @memberof StatsAnalyzer
   * @param {PeerConnection} peerConnection
   * @returns {void}
   */
  startAnalyzer(peerConnection) {
    this.peerConnection = peerConnection;
    this.getStatsAndParse();
    this.statsInterval = setInterval(() => {
      this.getStatsAndParse();
    }, this.config.analyzerInterval);
    // Trigger initial fetch
    this.sendMqaData();
    this.mqaInterval = setInterval(() => {
      this.sendMqaData();
    }, MQA_INTEVAL);
  }

  /**
   * Cleans up the analyzer when done
   *
   * @public
   * @memberof StatsAnalyzer
   * @returns {void}
   */
  stopAnalyzer() {
    if (this.statsInterval) {
      this.getStatsAndParse();
      clearInterval(this.statsInterval);
      this.statsInterva = undefined;
    }

    if (this.mqaInterval) {
      this.sendMqaData();
      clearInterval(this.mqaInterval);
      this.statsInterva = undefined;
    }
    this.peerConnection = null;
  }

  /**
   * Parse a single result of get stats
   *
   * @private
   * @param {*} getStatsResult
   * @param {String} type
   * @param {boolean} isSender
   * @returns {void}
   * @memberof StatsAnalyzer
   */
  parseGetStatsResult(getStatsResult, type, isSender) {
    if (!getStatsResult) {
      return;
    }

    switch (getStatsResult.type) {
      case 'outbound-rtp':
        this.processOutboundRTPResult(getStatsResult, type);
        break;
      case 'inbound-rtp':
        this.processInboundRTPResult(getStatsResult, type);
        break;
      case 'track':
        this.processTrackResult(getStatsResult, type);
        break;
      case 'remote-inbound-rtp':
      case 'remote-outbound-rtp':
        this.compareSentAndReceived(getStatsResult, type, isSender);
        break;
      case 'remotecandidate':
      case 'remote-candidate':
        this.remotecandidate(getStatsResult, type, isSender);
        break;
      default:
        break;
    }
  }

  /**
   * Filters the get stats results for types
   * @private
   * @param {Array} getStatsResults
   * @param {String} type
   * @param {boolean} isSender
   * @returns {void}
   */
  filterAndParseGetStatsResults(getStatsResults, type, isSender) {
    const {types} = DEFAULT_GET_STATS_FILTER;

    getStatsResults.forEach((result) => {
      if (types.includes(result.type)) {
        this.parseGetStatsResult(result, type, isSender);
      }
    });
  }

  /**
   * Does a `getStats` on all the transceivers and parses the results
   *
   * @private
   * @memberof StatsAnalyzer
   * @returns {void}
   */
  getStatsAndParse() {
    if (!this.peerConnection) {
      return;
    }

    if (this.peerConnection && this.peerConnection.connectionState === CONNECTION_STATE.FAILED) {
      LoggerProxy.logger.trace('StatsAnalyzer:index#getStatsAndParse --> PeerConnection is in failed state');

      return;
    }
    LoggerProxy.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Collecting Stats');
    this.peerConnection.videoTransceiver.sender.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.VIDEO_CORRELATE, true);
    });

    this.peerConnection.videoTransceiver.receiver.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.VIDEO_CORRELATE, false);
    });

    this.peerConnection.audioTransceiver.sender.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.AUDIO_CORRELATE, true);
    });

    this.peerConnection.audioTransceiver.receiver.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.AUDIO_CORRELATE, false);
    });

    this.peerConnection.shareTransceiver.sender.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.SHARE_CORRELATE, true);
    });

    this.peerConnection.shareTransceiver.receiver.getStats().then((res) => {
      this.filterAndParseGetStatsResults(res, STATS.SHARE_CORRELATE, false);
    });
    LoggerProxy.logger.trace('StatsAnalyzer:index#getStatsAndParse --> Finished Collecting Stats');
  }

  /**
   * Processes OutboundRTP stats result and stores
   * @private
   * @param {*} result
   * @param {*} type
   * @returns {void}
   */
  processOutboundRTPResult(result, type) {
    const mediaType = type || 'audio';
    const sendrecvType = 'send';

    if (result.bytesSent) {
      let kilobytes = 0;

      if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesSent) {
        this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;
      }
      if (!this.statsResults.internal[mediaType][sendrecvType].framesEncoded) {
        this.statsResults.internal[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
      }
      if (!this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded) {
        this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded;
      }

      const bytes = result.bytesSent - this.statsResults.internal[mediaType][sendrecvType].prevBytesSent;

      this.statsResults.internal[mediaType][sendrecvType].prevBytesSent = result.bytesSent;

      kilobytes = bytes / 1024;

      this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
      this.statsResults[mediaType].bytesSent = kilobytes;

      this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded - this.statsResults.internal[mediaType][sendrecvType].framesEncoded;
      this.statsResults[mediaType][sendrecvType].keyFramesEncoded = result.keyFramesEncoded - this.statsResults.internal[mediaType][sendrecvType].keyFramesEncoded;
      this.statsResults.internal[mediaType].outboundRtpId = result.id;

      if (!this.statsResults.internal[mediaType][sendrecvType].packetsSent) {
        this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
      }

      this.statsResults[mediaType][sendrecvType].packetsSent = result.packetsSent - this.statsResults.internal[mediaType][sendrecvType].packetsSent;
      this.statsResults.internal[mediaType][sendrecvType].packetsSent = result.packetsSent;
      this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;

      if (this.statsResults[mediaType][sendrecvType].packetsSent === 0) {
        LoggerProxy.logger.log(`StatsAnalyzer:index#processInboundRTPResult --> No packets sent for ${mediaType} `, this.statsResults[mediaType][sendrecvType].packetsSent);
      }

      // Data saved to send MQA metrics

      this.statsResults[mediaType][sendrecvType].totalKeyFramesEncoded = result.keyFramesEncoded;
      this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
      this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
      this.statsResults[mediaType][sendrecvType].totalPacketsSent = result.packetsSent;
      this.statsResults[mediaType][sendrecvType].totalFirCount = result.firCount;
      this.statsResults[mediaType][sendrecvType].framesEncoded = result.framesEncoded;
      this.statsResults[mediaType][sendrecvType].encoderImplementation = result.encoderImplementation;
      this.statsResults[mediaType][sendrecvType].qualityLimitationReason = result.qualityLimitationReason;
      this.statsResults[mediaType][sendrecvType].qualityLimitationResolutionChanges = result.qualityLimitationResolutionChanges;
      this.statsResults[mediaType][sendrecvType].retransmittedPacketsSent = result.retransmittedPacketsSent;
      this.statsResults[mediaType][sendrecvType].totalBytesSent = result.bytesSent;
      this.statsResults[mediaType][sendrecvType].headerBytesSent = result.headerBytesSent;
      this.statsResults[mediaType][sendrecvType].retransmittedBytesSent = result.retransmittedBytesSent;
    }
  }


  /**
   * Processes InboundRTP stats result and stores
   * @private
   * @param {*} result
   * @param {*} type
   * @returns {void}
   */
  processInboundRTPResult(result, type) {
    const mediaType = type || 'audio';
    const sendrecvType = 'recv';

    if (result.bytesReceived) {
      let kilobytes = 0;

      if (!this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived) {
        this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].pliCount) {
        this.statsResults.internal[mediaType][sendrecvType].pliCount = result.pliCount;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].packetsLost) {
        this.statsResults.internal[mediaType][sendrecvType].packetsLost = result.packetsLost;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived) {
        this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;
      }

      if (!this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp) {
        this.statsResults.internal[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;
      }

      const bytes = result.bytesReceived - (this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived);

      this.statsResults.internal[mediaType][sendrecvType].prevBytesReceived = result.bytesReceived;

      kilobytes = bytes / 1024;
      this.statsResults[mediaType][sendrecvType].availableBandwidth = kilobytes.toFixed(1);
      this.statsResults[mediaType].bytesReceived = kilobytes.toFixed(1);

      this.statsResults[mediaType][sendrecvType].pliCount = result.pliCount - this.statsResults.internal[mediaType][sendrecvType].pliCount;
      this.statsResults[mediaType][sendrecvType].currentPacketsLost = result.packetsLost - this.statsResults.internal[mediaType][sendrecvType].packetsLost;
      if (this.statsResults[mediaType][sendrecvType].currentPacketsLost < 0) {
        this.statsResults[mediaType][sendrecvType].currentPacketsLost = 0;
      }

      this.statsResults[mediaType][sendrecvType].packetsReceived = result.packetsReceived - this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived;
      this.statsResults.internal[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;

      if (this.statsResults[mediaType][sendrecvType].packetsReceived === 0) {
        LoggerProxy.logger.info(`StatsAnalyzer:index#processInboundRTPResult --> No packets received for ${mediaType} `, this.statsResults[mediaType][sendrecvType].packetsReceived);
      }

      //  Check the over all packet Lost ratio
      this.statsResults[mediaType][sendrecvType].currentPacketLossRatio = this.statsResults[mediaType][sendrecvType].currentPacketsLost > 0 ? this.statsResults[mediaType][sendrecvType].currentPacketsLost / (this.statsResults[mediaType][sendrecvType].packetsReceived + this.statsResults[mediaType][sendrecvType].currentPacketsLost) : 0;
      if (this.statsResults[mediaType][sendrecvType].currentPacketLossRatio > 3) {
        LoggerProxy.logger.info('StatsAnalyzer:index#processInboundRTPResult --> Packets getting lost from the receiver ', this.statsResults[mediaType][sendrecvType].currentPacketLossRatio);
      }

      this.statsResults[mediaType][sendrecvType].totalPacketsLost = result.packetsLost;
      this.statsResults[mediaType][sendrecvType].lastPacketReceivedTimestamp = result.lastPacketReceivedTimestamp;

      // From Thin
      this.statsResults[mediaType][sendrecvType].totalNackCount = result.nackCount;
      this.statsResults[mediaType][sendrecvType].totalPliCount = result.pliCount;
      this.statsResults[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
      this.statsResults[mediaType][sendrecvType].keyFramesDecoded = result.keyFramesDecoded;
      this.statsResults[mediaType][sendrecvType].decoderImplementation = result.decoderImplementation;
      this.statsResults[mediaType][sendrecvType].totalPacketsReceived = result.packetsReceived;


      this.statsResults[mediaType][sendrecvType].fecPacketsDiscarded = result.fecPacketsDiscarded;
      this.statsResults[mediaType][sendrecvType].fecPackets = result.fecPacketsReceived;
      this.statsResults[mediaType][sendrecvType].totalBytesReceived = result.bytesReceived;
      this.statsResults[mediaType][sendrecvType].headerBytesReceived = result.headerBytesReceived;
      this.statsResults[mediaType][sendrecvType].jitter = result.jitter;
    }
  }

  /**
   * Processes remote candidate result and stores
   * @private
   * @param {*} result
   * @param {*} type
   * @param {boolean} isSender
   *
   * @returns {void}
   */
  remotecandidate = (result, type, isSender) => {
    if (!result || !result.id) {
      return;
    }
    const RemoteCandidateType = {};
    const RemoteTransport = {};
    const RemoteIpAddress = {};
    const RemoteNetworkType = {};

    if (!result.id) return;

    const sendRecvType = isSender ? 'send' : 'recv';

    if (!RemoteCandidateType[result.id]) {
      RemoteCandidateType[result.id] = [];
    }

    if (!RemoteTransport[result.id]) {
      RemoteTransport[result.id] = [];
    }

    if (!RemoteIpAddress[result.id]) {
      RemoteIpAddress[result.id] = [];
    }
    if (!RemoteNetworkType[result.id]) {
      RemoteNetworkType[result.id] = [];
    }

    if (result.candidateType && RemoteCandidateType[result.id].indexOf(result.candidateType) === 0) {
      RemoteCandidateType[result.id].push(result.candidateType);
    }

    if (result.transport && RemoteTransport[result.id].indexOf(result.transport) === 0) {
      RemoteTransport[result.id].push(result.transport);
    }

    if (result.ipAddress && RemoteIpAddress[result.id].indexOf(`${result.ipAddress}:${result.portNumber}`) === 0) {
      RemoteIpAddress[result.id].push(`${result.ipAddress}:${result.portNumber}`);
    }

    if (result.networkType && RemoteNetworkType[result.id].indexOf(result.networkType) === 0) {
      RemoteNetworkType[result.id].push(result.networkType);
    }

    this.statsResults.internal.candidates[result.id] = {
      candidateType: RemoteCandidateType[result.id],
      ipAddress: RemoteIpAddress[result.id],
      portNumber: result.portNumber,
      networkType: RemoteNetworkType[result.id],
      priority: result.priority,
      transport: RemoteTransport[result.id],
      timestamp: result.timestamp,
      id: result.id,
      type: result.type
    };

    this.statsResults.connectionType.remote.candidateType = RemoteCandidateType[result.id];
    this.statsResults.connectionType.remote.ipAddress = RemoteIpAddress[result.id];
    this.statsResults.connectionType.remote.networkType = RemoteNetworkType[result.id];
    this.statsResults.connectionType.remote.transport = RemoteTransport[result.id];

    this.statsResults[type][sendRecvType].totalRoundTripTime = result.totalRoundTripTime;
    this.statsResults[type][sendRecvType].bytesReceived = result.bytesReceived;
    this.statsResults[type][sendRecvType].bytesSent = result.bytesSent;
    this.statsResults[type][sendRecvType].packetsReceived = result.packetsReceived || 0;
    this.statsResults[type][sendRecvType].packetsSent = result.packetsSent || 0;
    this.statsResults[type][sendRecvType].currentRoundTripTime = result.currentRoundTripTime;
    this.statsResults[type][sendRecvType].availableOutgoingBitrate = result.availableOutgoingBitrate;
    this.statsResults[type][sendRecvType].availableIncomingBitrate = result.availableIncomingBitrate;
  };


  /**
   * Process Track results
   *
   * @private
   * @param {*} result
   * @param {*} mediaType
   * @returns {void}
   * @memberof StatsAnalyzer
   */
  processTrackResult(result, mediaType) {
    if (!result || result.type !== 'track') {
      return;
    }
    if (result.type !== 'track') return;

    const sendrecvType = result.remoteSource === true ? 'recv' : 'send';

    if (result.frameWidth && result.frameHeight) {
      this.statsResults.resolutions[mediaType][sendrecvType].width = result.frameWidth;
      this.statsResults.resolutions[mediaType][sendrecvType].height = result.frameHeight;
      this.statsResults.resolutions[mediaType][sendrecvType].framesSent = result.framesSent;
      this.statsResults.resolutions[mediaType][sendrecvType].hugeFramesSent = result.hugeFramesSent;
    }

    if (sendrecvType === 'recv') {
      this.statsResults.resolutions[mediaType][sendrecvType].framesReceived = result.framesReceived;
      this.statsResults.resolutions[mediaType][sendrecvType].framesDecoded = result.framesDecoded;
      this.statsResults.resolutions[mediaType][sendrecvType].framesDropped = result.framesDropped;
    }


    if (result.trackIdentifier && mediaType !== 'audio') {
      this.statsResults.resolutions[mediaType][sendrecvType].trackIdentifier = result.trackIdentifier;

      const jitterBufferDelay = result && result.jitterBufferDelay;
      const jitterBufferEmittedCount = result && result.jitterBufferEmittedCount;

      this.statsResults.resolutions[mediaType][sendrecvType].avgJitterDelay = jitterBufferEmittedCount && (+jitterBufferDelay / +jitterBufferEmittedCount);
    }
  }

  /**
   *
   * @private
   * @param {*} result
   * @param {*} type
   * @returns {void}
   * @memberof StatsAnalyzer
   */
  compareSentAndReceived(result, type) {
    if (!type) {
      return;
    }

    const mediaType = type;

    if (!this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver) { this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost; }

    const currentPacketLoss = result.packetsLost - this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver;

    this.statsResults.internal[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
    this.statsResults[mediaType].send.packetsLostOnReceiver = currentPacketLoss;
    this.statsResults[mediaType].send.totalPacketsLostOnReceiver = result.packetsLost;
    this.statsResults[mediaType].send.jitter = result.jitter;
    this.statsResults[mediaType].send.roundTripTime = result.roundTripTime;
    this.statsResults[mediaType].send.timestamp = result.timestamp;
    this.statsResults[mediaType].send.ssrc = result.ssrc;
    this.statsResults[mediaType].send.reportsReceived = result.reportsReceived;

    // Total packloss ratio on this video section of the call
    this.statsResults[mediaType].send.overAllPacketLossRatio = this.statsResults[mediaType].send.totalPacketsLostOnReceiver > 0 ? this.statsResults[mediaType].send.totalPacketsLostOnReceiver / this.statsResults[mediaType].send.totalPacketsSent : 0;

    this.statsResults[mediaType].send.currentPacketLossRatio = this.statsResults[mediaType].send.packetsLostOnReceiver > 0 ? this.statsResults[mediaType].send.packetsLostOnReceiver * 100 / (this.statsResults[mediaType].send.packetsSent + this.statsResults[mediaType].send.packetsLostOnReceiver) : 0;

    if (this.statsResults[mediaType].send.maxPacketLossRatio < this.statsResults[mediaType].send.currentPacketLossRatio) {
      this.statsResults[mediaType].send.maxPacketLossRatio = this.statsResults[mediaType].send.currentPacketLossRatio;
    }


    if (this.statsResults[mediaType].send.currentPacketLossRatio > this.config.videoPacketLossRatioThreshold && mediaType === STATS.VIDEO_CORRELATE) {
      // Trigger downgrade video callback
      LoggerProxy.logger.log('StatsAnalyzer:index#compareSentAndReceived -->  Packet Loss is high ', this.statsResults[mediaType].send.currentPacketLossRatio);
      this.emit(
        {
          file: 'statsAnalyzer',
          function: 'compareSentAndReceived'
        },
        EVENT_TRIGGERS.MEETING_HIGH_PACKETLOSS,
        {
          mediaType,
          packetLossRatio: this.statsResults[mediaType].send.currentPacketLossRatio
        }
      );
    }
  }
}
