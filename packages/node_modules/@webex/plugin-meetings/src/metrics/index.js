/* globals window */
import util from 'util';

import {includes} from 'lodash';
import bowser from 'bowser';
import uuid from 'uuid';

import {MEETING_ERRORS} from '../constants';

import {error, eventType, errorCodes as ERROR_CODE} from './config';
import LoggerProxy from '@webex/plugin-meetings/src/common/logs/logger-proxy';
/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */
class Metrics {
  /**
     * crating Metrics
     * @constructor
     * @public
     * @memberof Meetings
     */
  constructor() {
    if (!Metrics.instance) {
      this._events = [];
      this.meetingCollection = null;
      Metrics.instance = this;
    }

    return Metrics.instance;
  }

  /**
   * poste call event metrics
   * @param {object} meetingCollection meetings object
   * @returns {object} null
   */
  setMeetings(meetingCollection) {
    this.meetingCollection = meetingCollection;
  }

  /**
   * poste call event metrics
   * @param {object} options {meetingId/meeting} as a json object
   * @returns {object} null
   */
  postEvent(options) {
    const {meetingId, data = {}, event} = options;
    let {meeting} = options;

    if (!meeting && meetingId) {
      meeting = this.meetingCollection.get(meetingId);
    }

    // meeting.emit();
    if (meeting && meeting.callEvents) {
      meeting.callEvents.push(event);
    }
    else if (meeting) {
      meeting.callEvents = [];
      meeting.callEvents.push(event);
    }
    else {
      LoggerProxy.logger.error('Metrics->postEvent: Meeting object not defined');
    }
    data.event = event;
    meeting.sendCallAnalyzerMetrics(data);
  }

  // https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
  // https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
  callInitiated(options) {
    console.log(eventType);
    options.event = eventType.CALL_INITIATED;
    this.postEvent(options);
  }

  moveMedia(options) {
    options.event = eventType.MOVE_MEDIA;
    this.postEvent(options);
  }

  localSdpGeneration(options) {
    options.event = eventType.CLIENT_MEDIA_ENGINE_LOCAL_SDP_GENERATED;
    this.postEvent(options);
  }

  remoteSdpGeneration(options) {
    options.event = eventType.CLIENT_MEDIA_ENGINE_REMOTE_SDP_RECEIVED;
    this.postEvent(options);
  }

  joinRequest(options) {
    options.event = eventType.CLIENT_LOCUS_JOIN_REQUEST;
    this.postEvent(options);
  }

  joinResponse(options) {
    options.event = eventType.CLIENT_LOCUS_JOIN_RESPONSE;
    this.postEvent(options);
  }

  notificationReceived(options) {
    options.event = eventType.CLIENT_NOTIFICATION_RECEIVED;
    this.postEvent(options);
  }

  alertDisplayed(options) {
    options.event = eventType.CLIENT_ALERT_DISPLAYED;
    this.postEvent(options);
  }

  iceStart(options) {
    options.event = eventType.CLIENT_ICE_START;
    this.postEvent(options);
  }

  iceStop(options) {
    options.event = eventType.CLIENT_ICE_END;
    this.postEvent(options);
  }

  startedRecvMedia(options) {
    options.event = eventType.CLIENT_MEDIA_RX_START;
    this.postEvent(options);
  }

  stoppedRecvMedia(options) {
    options.event = eventType.CLIENT_MEDIA_RX_STOP;
    this.postEvent(options);
  }

  startedSendingMedia(options) {
    options.event = eventType.CLIENT_MEDIA_TX_START;
    this.postEvent(options);
  }

  stoppedSendingMedia(options) {
    options.event = eventType.CLIENT_MEDIA_TX_STOP;
    this.postEvent(options);
  }

  renderingStarted(options) {
    options.event = eventType.CLIENT_MEDIA_RENDER_START;
    this.postEvent(options);
  }

  renderingStopped(options) {
    options.event = eventType.CLIENT_MEDIA_RENDER_STOP;
    this.postEvent(options);
  }

  // ?? Whats this one for
  mediaCapabilities(options) {
    options.event = eventType.CLIENT_MEDIA_CAPABILITIES;
    this.postEvent(options);
  }

  mediaReconnected(options) {
    options.event = eventType.CLIENT_MEDIA_RECONNECTING;
    this.postEvent(options);
  }

  mediaRecovered(options) {
    options.event = eventType.CLIENT_MEDIA_RECOVERED;
    this.postEvent(options);
  }

  mediaReconnectionFailed(options) {
    options.event = eventType.CALL_RECONNECTION_FAILED;
    this.postEvent(options);
  }

  pinPrompted(options) {
    options.event = eventType.CLIENT_PIN_PROMPT;
    this.postEvent(options);
  }

  pinCollected(options) {
    options.event = eventType.CLIENT_PIN_COLLECTED;
    this.postEvent(options);
  }

  enteredLobby(options) {
    options.event = eventType.CLIENT_LOBBY_ENTERED;
    this.postEvent(options);
  }

  exitedLobby(options) {
    options.event = eventType.CLIENT_LOBBY_EXITED;
    this.postEvent(options);
  }

  shareInitiated(options) {
    options.event = eventType.CLIENT_SHARE_INITIATED;
    this.postEvent(options);
  }

  shareStopped(options) {
    options.event = eventType.CLIENT_SHARE_STOPPED;
    this.postEvent(options);
  }

  shareFloorGranted(options) {
    options.event = eventType.CLIENT_SHARE_FLOOR_GRANTED_LOCAL;
    this.postEvent(options);
  }

  shareLayout(options) {
    options.event = eventType.CLIENT_SHARE_LAYOUT_DISPLAYED;
    this.postEvent(options);
  }

  muted(options) {
    options.event = eventType.CLIENT_MUTED;
    this.postEvent(options);
  }

  unmuted(options) {
    options.event = eventType.CLIENT_UNMUTED;
    this.postEvent(options);
  }

  leaveMeeting(options) {
    options.event = eventType.CLIENT_CALL_LEAVE;
    this.postEvent(options);
  }

  remoteEnded(options) {
    options.event = eventType.CLIENT_CALL_REMOTE_ENDED;
    this.postEvent(options);
  }

  remoteStarted(options) {
    options.event = eventType.CLIENT_CALL_REMOTE_STARTED;
    this.postEvent(options);
  }

  // ???? check if its correct
  receivedIncoming(options) {
    options.event = eventType.CLIENT_CALL_REMOTE_STARTED;
    this.postEvent(options);
  }

  sendMediaRequest(options) {
    options.event = eventType.CLIENT_LOCUS_MEDIA_REQUEST;
    this.postEvent(options);
  }

  gotMediaResponse(options) {
    options.event = eventType.CLIENT_LOCUS_MEDIA_RESPONSE;
    this.postEvent(options);
  }

  startPstn(options) {
    options.event = eventType.CLIENT_PSTN_AUDIO_ATTEMPT_START;
    this.postEvent(options);
  }

  finishPstn(options) {
    options.event = eventType.CLIENT_PSTN_AUDIO_ATTEMPT_FINISH;
    this.postEvent(options);
  }

  skipPstn(options) {
    options.event = eventType.CLIENT_PSTN_AUDIO_ATTEMPT_SKIP;
    this.postEvent(options);
  }

  generateMediaEngineError() {

  }

  initPayload(eventType, identifiers, options) {
    // TODO: add envirnoment to the call analyzer metrics

    // const buildType = config.env === 'production' || config.env === 'test' ?
    //   config.env.substr(0, 4) : 'debug';

    const payload = {
      eventId: uuid.v4(),
      version: 1,
      origin: {
        buildType: 'production',
        name: 'endpoint',
        networkType: 'unknown',
        userAgent: this.getUserAgentInfo()
      },
      originTime: {
        triggered: new Date().toISOString()
      },
      event: {
        name: eventType,
        canProceed: true,
        identifiers,
        eventData: {webClientDomain: window.location.hostname}
      }
    };

    // TODO: more options should be checked and some of them should be mandatory in certain conditions
    if (options) {
      if (Object.prototype.hasOwnProperty.call(options, 'canProceed')) {
        payload.event.canProceed = options.canProceed;
      }
      if (options.errors) {
        payload.event.errors = options.errors;
      }
      if (options.mediaType) {
        payload.event.mediaType = options.mediaType;
      }
      if (options.trigger) {
        payload.event.trigger = options.trigger;
      }
      if (options.pstnAudioType) {
        payload.event.pstnAudioType = options.pstnAudioType;
      }
      if (options.mediaCapabilities) {
        payload.event.mediaCapabilities = options.mediaCapabilities;
      }
      if (options.recoveredBy) {
        payload.event.recoveredBy = options.recoveredBy;
      }
    }

    return payload;
  }

  /*
   * This function parse Locus error into the error property of call diagnostic event payload.
   * It should keep updating from:
   * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
   * @param err {Object} the error Object from Locus response
   * @param {boolean} showToUser true if a toast is shown to user
   * @returns {{showToUser: boolean, category: string, errorDescription: string,
   *  errorCode: number, errorData: *, fatal: boolean, name: string}}
   */
  parseLocusError(err, showToUser) {
    let errorCode;

    if (err && err.body && err.body.errorCode) {
      switch (ERROR_CODE[err.body.errorCode]) {
        case MEETING_ERRORS.FREE_USER_MAX_PARTICIPANTS_EXCEEDED:
          errorCode = 3007;
          break;
        case MEETING_ERRORS.PAID_USER_MAX_PARTICIPANTS_EXCEEDED:
        case MEETING_ERRORS.SERVICE_MAX_PARTICIPANTS_EXCEEDED:
          errorCode = 3002;
          break;
        case MEETING_ERRORS.INACTIVE:
          errorCode = 4001;
          break;
        case MEETING_ERRORS.EXCEEDED_MAX_JOINED_PARTICIPANTS:
        case MEETING_ERRORS.EXCEEDED_SERVICE_MAX_PARTICIPANTS:
          errorCode = 3001;
          break;
        case MEETING_ERRORS.MEETING_IS_LOCKED:
          errorCode = 4002;
          break;
        case MEETING_ERRORS.MEETING_IS_TERMINATING:
          errorCode = 4003;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN_INTENT:
          errorCode = 4004;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN:
          errorCode = 4005;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_ROLE:
          errorCode = 4006;
          break;
        case MEETING_ERRORS.JOIN_RESTRICTED_USER:
        case MEETING_ERRORS.GET_RESTRICTED_USER:
        case MEETING_ERRORS.CREATE_MEDIA_RESTRICTED_USER:
          errorCode = 3005;
          break;
        case MEETING_ERRORS.JOIN_RESTRICTED_USER_NOT_IN_ROOM:
          errorCode = 4007;
          break;
        case MEETING_ERRORS.MEETING_NOT_FOUND:
          errorCode = 4011;
          break;
        case MEETING_ERRORS.NOT_WEBEX_SITE:
          errorCode = 4012;
          break;
        case MEETING_ERRORS.INVALID_JOIN_TIME:
          errorCode = 4013;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_NOT_A_NUMBER:
          errorCode = 4016;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_TOO_LONG:
          errorCode = 4017;
          break;
        case MEETING_ERRORS.INVALID_DIALABLE_KEY:
          errorCode = 4018;
          break;
        case MEETING_ERRORS.ONE_ON_ONE_TO_SELF_NOT_ALLOWED:
          errorCode = 4019;
          break;
        case MEETING_ERRORS.REMOVED_PARTICIPANT:
          errorCode = 4020;
          break;
        case MEETING_ERRORS.MEETING_LINK_NOT_FOUND:
          errorCode = 4021;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_TOO_SHORT_AFTER_IDD:
          errorCode = 4022;
          break;
        case MEETING_ERRORS.INVALID_INVITEE_ADDRESS:
          errorCode = 4023;
          break;
        case MEETING_ERRORS.PMR_ACCOUNT_LOCKED:
          errorCode = 4024;
          break;
        case MEETING_ERRORS.RESOURCE_GUEST_FORBIDDEN:
          errorCode = 4025;
          break;
        case MEETING_ERRORS.PMR_ACCOUNT_SUSPENDED:
          errorCode = 4026;
          break;
        case MEETING_ERRORS.EMPTY_PHONE_NUMBER_OR_COUNTRY_CODE:
          errorCode = 4027;
          break;
        case MEETING_ERRORS.INVALID_SINCE_OR_SEQUENCE_HASH_IN_REQUEST:
          errorCode = 1006;
          break;
        case MEETING_ERRORS.CONVERSATION_NOT_FOUND:
          errorCode = 4028;
          break;
        case MEETING_ERRORS.RECORDING_CONTROL_NOT_SUPPORTED:
        case MEETING_ERRORS.RECORDING_NOT_STARTED:
        case MEETING_ERRORS.RECORDING_NOT_ENABLED:
          errorCode = 4029;
          break;
        default:
          errorCode = 4008;
      }
    }
    else {
      errorCode = 4008;
    }

    return this.createErrorPayloadWithErrorCode(
      errorCode, showToUser, error.name.LOCUS_RESPONSE, err
    );
  }


  generateErrorPayload(errorCode, shownToUser, name, err) {
    if (error.errors[errorCode]) {
      const errorPayload = {
        shownToUser: shownToUser || false,
        category: error.errors[errorCode][2],
        errorDescription: error.errors[errorCode][0],
        errorCode,
        fatal: !includes(error.notFatalErrorList, errorCode),
        name: name || error.name.OTHER
      };

      if (err && err.body) {
        errorPayload.errorData = err.body;
      }

      return errorPayload;
    }

    // config.console.error('Can not create the error payload with given errorCode', errorCode);

    return null;
  }

  updateIdentifiersWithResponse(identifiers, res = {}) {
    if (!identifiers) {
      // config.console.error('Error [Update Identifiers]: missing identifers!');
    }
    else {
      if (res.body && res.body.locus) {
        const {locus} = res.body;

        identifiers.locusId = locus.url.split('/').pop();
        identifiers.locusStartTime = locus.fullState.lastActive;
      }
      if (res.headers && res.headers.trackingid) {
        identifiers.trackingId = res.headers.trackingid;
      }
    }

    return identifiers;
  }

  getUserAgentInfo() {
    let userAgentOption;
    let browserInfo;
    let osInfo;

    if (bowser.name && ['chrome', 'firefox', 'msie', 'msedge', 'safari'].indexOf(bowser.name.toLowerCase()) !== -1 && bowser.version) {
      browserInfo = util.format('browser=%s', `${bowser.name.toLowerCase()}/${bowser.version.split('.')[0]}`);
    }
    if (window.navigator.platform && bowser.osversion) {
      osInfo = util.format('os=%s', `${window.navigator.platform}/${bowser.osversion.split('.')[0]}`);
    }
    if (browserInfo) {
      userAgentOption = `(${browserInfo}`;
    }
    if (osInfo) {
      userAgentOption = userAgentOption ? `${userAgentOption}; ${osInfo}` : `(${osInfo}`;
    }
    if (userAgentOption) {
      userAgentOption += ')';

      // TODO:  add version of the SDK
      return util.format('SparkWeb/%s %s', 'test', userAgentOption);
    }

    // TODO:  add version of the SDK
    return util.format('SparkWeb/%s', 'test');
  }

  addCorrelationIdIntoRequestBody(postBody, correlationId) {
    if (!correlationId || !postBody) {
      // config.console.error('Error [Call Diagnostic Event]: CorrelationId or postBody is missing!');

      return null;
    }
    postBody.correlationId = correlationId;

    return postBody;
  }
}

const instance = new Metrics();

export default instance;
