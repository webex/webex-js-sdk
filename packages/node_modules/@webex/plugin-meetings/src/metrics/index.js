/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
import util from 'util';

import {includes} from 'lodash';
import bowser from 'bowser';
import uuid from 'uuid';
import window from 'global/window';

import LoggerProxy from '../common/logs/logger-proxy';
import {MEETING_ERRORS} from '../constants';
import StaticConfig from '../common/config';

import {error, eventType, errorCodes as ERROR_CODE} from './config';
/**
 * @description Metrics handles all the call metrics events
 * @export
 * @class Metrics
 */
class Metrics {
  /**
     * Create Metrics Object
     * @constructor
     * @public
     * @memberof Meetings
     */
  constructor() {
    if (!Metrics.instance) {
    /**
     * @instance
     * @type {Array}
     * @private
     * @memberof Metrics
     */
      this._events = [];
      /**
     * @instance
     * @type {MeetingCollection}
     * @private
     * @memberof Metrics
     */
      this.meetingCollection = null;
      /**
     * @instance
     * @type {MeetingCollection}
     * @private
     * @memberof Metrics
     */
      this.keys = Object.values(eventType);
      /**
       * @instance
       * @type {Metrics}
       * @private
       * @memberof Metrics
       */
      Metrics.instance = this;
    }

    return Metrics.instance;
  }

  /**
   * Initializes the Metrics singleton with a meeting Collection.
   *
   * @param {Object} meetingCollection meetings object
   * @param {Object} webex  webex SDK object
   *
   * @returns {void}
   */
  initialSetup(meetingCollection, webex) {
    this.meetingCollection = meetingCollection;
    this.webex = webex;
  }

  /**
   * poste Meeting event metrics
   * @param {object} options {meetingId/meeting} as a json object
   * @param {String} options.meetingId
   * @param {object} options.data
   * @param {object} options.event
   * @returns {object} null
   */
  postEvent(options) {
    const {meetingId, data = {}, event} = options;
    let {meeting} = options;

    if (this.keys.indexOf(event) === -1) {
      LoggerProxy.logger.error(`Metrics:index#postEvent --> Event ${event} doesn't exist in dictionary`);
    }

    if (!meeting && meetingId) {
      meeting = this.meetingCollection.get(meetingId);
    }

    if (meeting) {
      if (!meeting.callEvents) {
        meeting.callEvents = [];
      }
      if (event === eventType.MEDIA_QUALITY) {
        data.event = event;
        meeting.sendMediaQualityAnalyzerMetrics(data);
      }
      else {
        meeting.callEvents.push(event);
        data.event = event;
        meeting.sendCallAnalyzerMetrics(data);
      }
    }

    else {
      LoggerProxy.logger.info(`Metrics:index#postEvent --> Event received for meetingId:${meetingId}, but meeting not found in collection.`);
    }
  }

  /**
   *  Docs for Call analyzer metrics
  *   https://sqbu-github.cisco.com/WebExSquared/call-analyzer/wiki
  *   https://sqbu-github.cisco.com/WebExSquared/event-dictionary/blob/master/diagnostic-events.raml
 */

  initPayload(eventType, identifiers, options) {
    const payload = {
      eventId: uuid.v4(),
      version: 1,
      origin: {
        buildType: 'prod',
        name: 'endpoint',
        networkType: 'unknown',
        userAgent: this.userAgentToString(),
        clientInfo: {
          clientType: options.clientType,
          os: 'linux', // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'
          osVersion: bowser.osVersion || '-1',
          subClientType: options.subClientType
        }
      },
      originTime: {
        triggered: new Date().toISOString()
      },
      event: {
        name: eventType,
        canProceed: true,
        identifiers,
        eventData: {webClientDomain: window.location.hostname}
      }
    };

    // TODO: more options should be checked and some of them should be mandatory in certain conditions
    if (options) {
      if (Object.prototype.hasOwnProperty.call(options, 'canProceed')) {
        payload.event.canProceed = options.canProceed;
      }
      if (options.errors) {
        payload.event.errors = options.errors;
      }
      if (options.mediaType) {
        payload.event.mediaType = options.mediaType;
      }
      if (options.trigger) {
        payload.event.trigger = options.trigger;
      }
      if (options.pstnAudioType) {
        payload.event.pstnAudioType = options.pstnAudioType;
      }
      if (options.mediaCapabilities) {
        payload.event.mediaCapabilities = options.mediaCapabilities;
      }
      if (options.recoveredBy) {
        payload.event.recoveredBy = options.recoveredBy;
      }
    }

    return payload;
  }

  osName() {
    // TODO: BUG AND DOESNT ACCEPT OSNAME ON CA -> bowser.osname || 'null'

    return 'mac';
  }

  /**
   * get the payload specific for a media quality event through call analyzer
   * @param {String} eventType the event name
   * @param {Object} identifiers contains the identifiers needed for CA
   * @param {String} identifiers.correlationId
   * @param {String} identifiers.locusUrl
   * @param {String} identifiers.locusId
   * @param {Object} options
   * @param {Object} options.intervalData
   * @param {String} options.clientType
   * @returns {Object}
   * @public
   * @memberof Metrics
   */
  initMediaPayload(eventType, identifiers, options) {
    const payload = {
      eventId: uuid.v4(),
      version: 1,
      origin: {
        buildType: 'prod',
        name: 'endpoint',
        networkType: 'unknown', // TODO: check if we can get mediaType
        userAgent: this.userAgentToString(),
        clientInfo: {
          clientType: options.clientType, // TODO: Only clientType: 'TEAMS_CLIENT' is whitelisted
          os: 'linux' || this.osName(), // TODO: For some reason Mqa does not accept mac
          osVersion: bowser.osVersion || '-1',
          subClientType: options.subClientType
        }
      },
      originTime: {
        triggered: new Date().toISOString()
      },
      event: {
        name: eventType,
        canProceed: true,
        identifiers,
        intervals: [options.intervalData],
        eventData: {webClientDomain: window.location.hostname},
        sourceMetadata: {
          applicationSoftwareType: 'webex-js-sdk',
          applicationSoftwareVersion: this.webex.version,
          mediaEngineSoftwareType: bowser.name || 'browser',
          mediaEngineSoftwareVersion: bowser.osVersion || '-1',
          startTime: new Date().toISOString()
        }
      }
    };

    return payload;
  }

  /*
   * This function Parses a Locus error and returns a diagnostic event payload.
   * It should keep updating from:
   * https://sqbu-github.cisco.com/WebExSquared/spark-client-framework/blob/master/spark-client-framework/Adapters/TelephonyAdapter/TelephonyAdapter.cpp#L920
   * @param err {Object} the error Object from Locus response
   * @param {boolean} showToUser true if a toast is shown to user
   * @returns {{showToUser: boolean, category: string, errorDescription: string,
   *  errorCode: number, errorData: *, fatal: boolean, name: string}}
   */
  parseLocusError(err, showToUser) {
    let errorCode;

    if (err && err.body && err.body.errorCode) {
      switch (ERROR_CODE[err.body.errorCode]) {
        case MEETING_ERRORS.FREE_USER_MAX_PARTICIPANTS_EXCEEDED:
          errorCode = 3007;
          break;
        case MEETING_ERRORS.PAID_USER_MAX_PARTICIPANTS_EXCEEDED:
        case MEETING_ERRORS.SERVICE_MAX_PARTICIPANTS_EXCEEDED:
          errorCode = 3002;
          break;
        case MEETING_ERRORS.INACTIVE:
          errorCode = 4001;
          break;
        case MEETING_ERRORS.EXCEEDED_MAX_JOINED_PARTICIPANTS:
        case MEETING_ERRORS.EXCEEDED_SERVICE_MAX_PARTICIPANTS:
          errorCode = 3001;
          break;
        case MEETING_ERRORS.MEETING_IS_LOCKED:
          errorCode = 4002;
          break;
        case MEETING_ERRORS.MEETING_IS_TERMINATING:
          errorCode = 4003;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN_INTENT:
          errorCode = 4004;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_PIN:
          errorCode = 4005;
          break;
        case MEETING_ERRORS.MEETING_REQUIRE_MODERATOR_ROLE:
          errorCode = 4006;
          break;
        case MEETING_ERRORS.JOIN_RESTRICTED_USER:
        case MEETING_ERRORS.GET_RESTRICTED_USER:
        case MEETING_ERRORS.CREATE_MEDIA_RESTRICTED_USER:
          errorCode = 3005;
          break;
        case MEETING_ERRORS.JOIN_RESTRICTED_USER_NOT_IN_ROOM:
          errorCode = 4007;
          break;
        case MEETING_ERRORS.MEETING_NOT_FOUND:
          errorCode = 4011;
          break;
        case MEETING_ERRORS.NOT_WEBEX_SITE:
          errorCode = 4012;
          break;
        case MEETING_ERRORS.INVALID_JOIN_TIME:
          errorCode = 4013;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_NOT_A_NUMBER:
          errorCode = 4016;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_TOO_LONG:
          errorCode = 4017;
          break;
        case MEETING_ERRORS.INVALID_DIALABLE_KEY:
          errorCode = 4018;
          break;
        case MEETING_ERRORS.ONE_ON_ONE_TO_SELF_NOT_ALLOWED:
          errorCode = 4019;
          break;
        case MEETING_ERRORS.REMOVED_PARTICIPANT:
          errorCode = 4020;
          break;
        case MEETING_ERRORS.MEETING_LINK_NOT_FOUND:
          errorCode = 4021;
          break;
        case MEETING_ERRORS.PHONE_NUMBER_TOO_SHORT_AFTER_IDD:
          errorCode = 4022;
          break;
        case MEETING_ERRORS.INVALID_INVITEE_ADDRESS:
          errorCode = 4023;
          break;
        case MEETING_ERRORS.PMR_ACCOUNT_LOCKED:
          errorCode = 4024;
          break;
        case MEETING_ERRORS.RESOURCE_GUEST_FORBIDDEN:
          errorCode = 4025;
          break;
        case MEETING_ERRORS.PMR_ACCOUNT_SUSPENDED:
          errorCode = 4026;
          break;
        case MEETING_ERRORS.EMPTY_PHONE_NUMBER_OR_COUNTRY_CODE:
          errorCode = 4027;
          break;
        case MEETING_ERRORS.INVALID_SINCE_OR_SEQUENCE_HASH_IN_REQUEST:
          errorCode = 1006;
          break;
        case MEETING_ERRORS.CONVERSATION_NOT_FOUND:
          errorCode = 4028;
          break;
        case MEETING_ERRORS.RECORDING_CONTROL_NOT_SUPPORTED:
        case MEETING_ERRORS.RECORDING_NOT_STARTED:
        case MEETING_ERRORS.RECORDING_NOT_ENABLED:
          errorCode = 4029;
          break;
        default:
          errorCode = 4008;
      }
    }
    else {
      errorCode = 4008;
    }

    return this.generateErrorPayload(
      errorCode, showToUser, error.name.LOCUS_RESPONSE, err
    );
  }


  generateErrorPayload(errorCode, shownToUser, name, err) {
    if (error.errors[errorCode]) {
      const errorPayload = {
        shownToUser: shownToUser || false,
        category: error.errors[errorCode][2],
        errorDescription: error.errors[errorCode][0],
        errorCode,
        fatal: !includes(error.notFatalErrorList, errorCode),
        name: name || error.name.OTHER
      };

      if (err && err.body) {
        errorPayload.errorData = err.body;
      }

      return errorPayload;
    }

    return null;
  }

  /**
   * Returns a formated string of the user agent.
   *
   * @returns {string} formatted user agent information
   */
  userAgentToString() {
    let userAgentOption;
    let browserInfo;
    let osInfo;
    const clientInfo = util.format('client=%s', `${StaticConfig.meetings.metrics.clientName}`);

    if (bowser.name && ['chrome', 'firefox', 'msie', 'msedge', 'safari'].indexOf(bowser.name.toLowerCase()) !== -1 && bowser.version) {
      browserInfo = util.format('browser=%s', `${bowser.name.toLowerCase()}/${bowser.version.split('.')[0]}`);
    }
    if (bowser.osname && bowser.osversion) {
      osInfo = util.format('os=%s', `${bowser.osname}/${bowser.osversion.split('.')[0]}`);
    }

    if (browserInfo) {
      userAgentOption = `(${browserInfo}`;
    }
    if (osInfo) {
      userAgentOption = userAgentOption ? `${userAgentOption}; ${clientInfo}; ${osInfo}` : `${clientInfo}; (${osInfo}`;
    }
    if (userAgentOption) {
      userAgentOption += ')';

      return util.format('webex-js-sdk/%s %s', `${process.env.NODE_ENV}-${this.webex.version}`, userAgentOption);
    }

    return util.format('webex-js-sdk/%s', `${process.env.NODE_ENV}-${this.webex.version}`);
  }

  /**
   * Uploads given metric to the Metrics service as an operational metric.
   * Metadata about the environment such as browser, OS, SDK and their versions
   * are automatically added when the metric is sent.
   *
   * The Metrics service will send an operational metric to InfluxDB for
   * aggregation.
   * See https://confluence-eng-gpk2.cisco.com/conf/display/WBXT/Getting+started+with+Metrics+Service.
   *
   * @param {string} metricName  Name of the metric (measurement) to send
   * @param {Object} metricFields  Key-valye pairs of data or values about this metric
   * @param {Object} metricTags  Key-value pairs of metric metadata
   *
   * @returns {void}
   */
  sendOperationalMetric(metricName, metricFields = {}, metricTags = {}) {
    const fields = {
      ...metricFields,
      browser_version: bowser.version,
      os_version: bowser.osversion,
      sdk_version: this.webex.version
    };

    const tags = {
      ...metricTags,
      browser: bowser.name,
      org_id: this.webex.credentials.getOrgId(),
      os: bowser.osname
    };

    if (!metricName) {
      throw Error('Missing operational metric name. Please provide one');
    }

    this.webex.internal.metrics.submitClientMetrics(metricName, {
      type: ['operational'],
      fields,
      tags
    });
  }
}

// Export Metrics singleton ---------------------------------------------------
const instance = new Metrics();

export default instance;
