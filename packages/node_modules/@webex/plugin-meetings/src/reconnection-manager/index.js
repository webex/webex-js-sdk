/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import LoggerProxy from '../common/logs/logger-proxy';
import {_ACTIVE_, RECONNECTION} from '../constants';
import ReconnectionError from '../common/errors/reconnection';
import PeerConnectionManager from '../peer-connection-manager';
import Media from '../media';

/**
 * @export
 * @class ReconnectionManager
*/
export default class ReconnectionManager {
  /**
   * @param {Meeting} meeting
   */
  constructor(meeting) {
    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    this.webex = meeting.webex;
    this.configure(meeting);
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  configure(meeting) {
    this.backOff = meeting.config.reconnection.retry.backOff.start;
  }

  /**
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  reset() {
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
  }

  /**
   * @param {Meeting} meeting
   * @returns {Boolean}
   * @returns {ReconnectionError}
   * @private
   * @memberof ReconnectionManager
   */
  validate(meeting) {
    if (meeting.config.reconnection.enabled) {
      if (
        meeting.locusInfo &&
          meeting.locusInfo.fullState &&
          (
            meeting.locusInfo.fullState.state === _ACTIVE_ &&
            meeting.locusInfo.fullState.active
          )
      ) {
        if (meeting.webex.internal.mercury.connected) {
          if (
            this.status !== RECONNECTION.STATE.DEFAULT_STATUS ||
            this.status !== RECONNECTION.STATE.COMPLETE
          ) {
            return true;
          }

          return new ReconnectionError('Multiple reconnections cannot occur concurrently');
        }

        return new ReconnectionError('mercury is not connected, cannot reconnect');
      }

      return new ReconnectionError('locus server for this call is not active, cannot reconnect');
    }

    return new ReconnectionError('Reconnection is not enabled.');
  }

  /**
   * Initiates a media reconnect for the active meeting
   * @param {Meeting} meeting
   * @returns {Promise}
   * @public
   * @memberof ReconnectionManager
   */
  reconnect(meeting) {
    const validatedReconnect = this.validate(meeting);

    return validatedReconnect === true ? this.execute(meeting) : Promise.reject(validatedReconnect);
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  execute(meeting) {
    this.status = RECONNECTION.STATE.IN_PROGRESS;

    return this.media(meeting)
      .then((media) => {
        LoggerProxy.logger.log(`ReconnectionManager->execute#Media reestablished at: ${new Date()}`);
        this.status = RECONNECTION.STATE.COMPLETE;

        return Promise.resolve(media);
      })
      .catch((err) => { // eslint-disable-line
        LoggerProxy.logger.error(`ReconnectionManager->execute#Media reestablishment failed at: ${new Date()}`);
        if (this.tryCount > meeting.config.reconnection.retry.times) {
          this.status = RECONNECTION.STATE.FAILURE;

          return Promise.reject(new ReconnectionError(err));
        }
        // exponential backoff and retry logic
        setTimeout(() =>
          this.reconnect(meeting),
        this.backOff *= meeting.config.reconnection.retry.backOff.rate);
      });
  }

  /**
   * @param {Meeting} meeting
   * @param {boolean} recreate optional
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  reconnectMedia(meeting, recreate = false) {
    let promise = null;

    if (recreate) {
      promise = Media.attachMedia(meeting.mediaProperties)
        .then((peerConnection) => meeting.setRemoteStream(peerConnection));
    }
    else {
      promise = Media.reconnectMedia(meeting.mediaProperties.peerConnection, meeting.meetingId);
    }

    return Promise.resolve(promise)
      .then(() => meeting.roap
        .sendRoapMediaRequest({
          sdp: meeting.mediaProperties.peerConnection.sdp,
          roapSeq: meeting.roapSeq,
          meeting // or can pass meeting ID
        }));
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise} see #Meeting.addMedia
   * @private
   * @memberof ReconnectionManager
   */
  media(meeting) {
    this.tryCount += 1;
    LoggerProxy.logger.log(`Reconnection->media#Begin reestablishment of media at ${new Date()}`);


    // TODO: chekc peerconnection status
    // create an offer
    return this.reconnectMedia(meeting)
      .then((media) => Promise.resolve(media))
      .catch((err) => {
        LoggerProxy.logger.warn(`Reconnection->media#Media could not reuse peer connection, failed with ${err}`);
        // TODO: test getting to this scenario
        ReconnectionManager.cleanup(meeting);
        meeting.mediaProperties.reInitiatePeerconnection();

        return meeting.reconnectMedia(true)
          .catch((error) => {
            LoggerProxy.logger.error(`ReconnectionManager->media#Error reconnecting , error: ${error}`);
          });
      });
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   * @private
   * @memberof ReconnectionManager
   */
  static cleanup(meeting) {
    // close pcs, unset to null and reuse the streams with new pcs
    PeerConnectionManager.close(meeting.mediaProperties.peerConnection);
    meeting.mediaProperties.unsetPeerConnection();
  }
}
