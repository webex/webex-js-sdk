/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint-disable no-warning-comments */

import LoggerProxy from '../common/logs/logger-proxy';
import Trigger from '../common/events/trigger-proxy';
import {
  EVENT_TRIGGERS, RECONNECTION, SHARE_STOPPED_REASON, _LEFT_
} from '../constants';
import ReconnectionError from '../common/errors/reconnection';
import ReconnectInProgress from '../common/errors/reconnection-in-progress';
import PeerConnectionManager from '../peer-connection-manager';
import {eventType, reconnection, errorObjects} from '../metrics/config';
import Media from '../media';
import Metrics from '../metrics';

/**
 * Used to indicate that the reconnect logic needs to be retried.
 *
 * @class NeedsRetryError
 * @extends {Error}
 */
class NeedsRetryError extends Error {}

/**
 * Used to indicate that the meeting needs to be rejoined, not just media reconnected
 *
 * @class NeedsRejoinError
 * @extends {Error}
 */
class NeedsRejoinError extends Error {
  /**
   * Creates an instance of NeedsRejoinError.
   * @param {Object} params
   * @param {boolean} params.wasSharing
   * @param {Error} params.error
   * @memberof NeedsRejoinError
   */
  constructor({wasSharing, error}) {
    super(error);

    this.wasSharing = wasSharing;
  }
}

/**
 * @export
 * @class ReconnectionManager
*/
export default class ReconnectionManager {
  /**
   * @param {Meeting} meeting
   */
  constructor(meeting) {
    /**
     * Stores ICE reconnection state data.
     *
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
     */
    this.iceState = {
      disconnected: false,
      resolve: () => {},
      timer: undefined,
      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout
    };

    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    this.webex = meeting.webex;
    /**
     * @instance
     * @type {Meeting}
     * @private
     * @memberof ReconnectionManager
     */
    this.meeting = meeting;

    this.maxRejoinAttempts = meeting.config.reconnection.maxRejoinAttempts;
    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;


    // Make sure reconnection state is in default
    this.reset();
  }

  /**
   * Sets the iceState to connected and clears any disconnect timeouts and
   * related timeout data within the iceState.
   *
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  iceReconnected() {
    if (this.iceState.disconnected) {
      LoggerProxy.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');

      this.iceState.resolve();
      this.iceState.resolve = () => {};

      if (this.iceState.timer) {
        clearTimeout(this.iceState.timer);
        delete this.iceState.timer;
      }

      this.iceState.disconnected = false;
    }
  }

  /**
   * Set the iceState to disconnected and generates a timeout that waits for the
   * iceState to reconnect and then resolves. If the ice state is already
   * processing a reconnect, it immediately resolves. Rejects if the timeout
   * duration is reached.
   *
   * @returns {Promise<undefined>}
   * @public
   * @memberof ReconnectionManager
   */
  waitForIceReconnect() {
    if (!this.iceState.disconnected) {
      LoggerProxy.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');

      this.iceState.disconnected = true;

      return new Promise((resolve, reject) => {
        this.iceState.timer = setTimeout(() => {
          if (this.iceState.disconnected === false) {
            resolve();
          }
          else {
            this.iceState.disconnected = false;
            reject(new Error(`ice reconnection did not occur in ${this.iceState.timeoutDuration}ms`));
          }
        }, this.iceState.timeoutDuration);

        this.iceState.resolve = resolve;
      });
    }

    // return a resolved promise to prevent multiple catch executions of reconnect
    return Promise.resolve();
  }

  /**
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  reset() {
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    this.rejoinAttempts = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
  }

  /**
   * @returns {Boolean}
   * @throws {ReconnectionError}
   * @private
   * @memberof ReconnectionManager
   */
  validate() {
    if (this.meeting.config.reconnection.enabled) {
      if (
        this.status === RECONNECTION.STATE.DEFAULT_STATUS ||
        this.status === RECONNECTION.STATE.COMPLETE
      ) {
        return true;
      }

      LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection already in progress.');

      throw new ReconnectInProgress('Reconnection already in progress.');
    }

    LoggerProxy.logger.info('ReconnectionManager:index#validate --> Reconnection is not enabled.');

    throw new ReconnectionError('Reconnection is not enabled.');
  }

  /**
   * Initiates a media reconnect for the active meeting
   * @param {Object} reconnectOptions
   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
   * @param {boolean} [reconnectOptions.networkRetry=false] indicates if we are retrying the reconnect
   * @returns {Promise}
   * @public
   * @memberof ReconnectionManager
   */
  async reconnect({networkDisconnect = false, networkRetry = false} = {}) {
    LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection start.');
    // First, validate that we can reconnect, if not, it will throw an error
    try {
      this.validate();
    }
    catch (error) {
      LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection unable to begin.', error);
      throw error;
    }

    if (!networkRetry) {
      // Only log START metrics on the initial reconnect
      LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect start metric.');
      Metrics.postEvent({
        event: eventType.MEDIA_RECONNECTING,
        meeting: this.meeting
      });
    }

    return this.executeReconnection({networkDisconnect})
      .then(() => {
        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection successful.');
        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect success metric.');
        Metrics.postEvent({
          event: eventType.MEDIA_RECOVERED,
          meeting: this.meeting,
          data: {recoveredBy: reconnection.RECOVERED_BY_NEW}
        });
      })
      .catch((reconnectError) => {
        if (reconnectError instanceof NeedsRetryError) {
          LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Reconnection not successful, retrying.');
          // Reset our reconnect status since we are looping back to the beginning
          this.status = RECONNECTION.STATE.DEFAULT_STATUS;

          // This is a network retry, so we should not log START metrics again
          return this.reconnect({networkDisconnect: true, networkRetry: true});
        }

        // Reconnect has failed
        LoggerProxy.logger.error('ReconnectionManager:index#reconnect --> Reconnection failed.', reconnectError);
        LoggerProxy.logger.info('ReconnectionManager:index#reconnect --> Sending reconnect abort metric.');
        Metrics.postEvent({
          event: eventType.CALL_ABORTED,
          meeting: this.meeting,
          data: {
            errors: [
              {
                category: errorObjects.category.media,
                errorCode: 2008,
                fatal: true,
                name: errorObjects.name.mediaEngine,
                shownToUser: false
              }
            ]
          }
        });

        if (reconnectError instanceof NeedsRejoinError) {
          return this.rejoinMeeting(reconnectError.wasSharing);
        }

        throw reconnectError;
      });
  }

  /**
   * @param {Object} reconnectOptions
   * @param {boolean} [reconnectOptions.networkDisconnect=false] indicates if a network disconnect event happened
   * @returns {Promise}
   * @throws {NeedsRetryError}
   * @private
   * @memberof ReconnectionManager
   */
  async executeReconnection({networkDisconnect = false}) {
    this.status = RECONNECTION.STATE.IN_PROGRESS;

    LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Attempting to reconnect to meeting.');

    if (networkDisconnect) {
      try {
        await this.reconnectMercuryWebSocket();
        LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Websocket reconnected.');
      }
      catch (error) {
        LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Unable to reconnect to websocket, giving up.');
        this.status = RECONNECTION.STATE.FAILURE;
        throw (error);
      }
    }

    const wasSharing = this.meeting.isSharing;

    try {
      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Updating meeting data from server.');
      await this.webex.meetings.syncMeetings();
    }
    catch (syncError) {
      LoggerProxy.logger.info('ReconnectionManager:index#executeReconnection --> Unable to sync meetings, reconnecting.', syncError);
      throw (new NeedsRetryError(syncError));
    }

    // If the meeting state was left, no longer reconnect media
    if (this.meeting.state === _LEFT_) {
      throw (new NeedsRejoinError({wasSharing}));
    }

    try {
      const media = await this.reconnectMedia();

      LoggerProxy.logger.log('ReconnectionManager:index#executeReconnection --> Media reestablished');
      this.status = RECONNECTION.STATE.COMPLETE;

      return media;
    }
    catch (error) {
      LoggerProxy.logger.error('ReconnectionManager:index#executeReconnection --> Media reestablishment failed');
      this.status = RECONNECTION.STATE.FAILURE;

      throw (error);
    }
  }

  /**
   * Rejoins a meeting after detecting the member was in a LEFT state
   *
   * @async
   * @param {boolean} wasSharing
   * @returns {Promise}
   */
  async rejoinMeeting(wasSharing = false) {
    try {
      await this.meeting.join();
      LoggerProxy.logger.info('ReconnectionManager:index#rejoinMeeting --> meeting rejoined');

      if (wasSharing) {
        // Stop the share streams if user tried to rejoin
        Media.stopTracks(this.meeting.mediaProperties.shareTrack);
        this.meeting.isSharing = false;
        this.meeting.mediaProperties.mediaDirection.sendShare = false;
        Trigger.trigger(
          this.meeting,
          {
            file: 'reconnection-manager/index',
            function: 'rejoinMeeting'
          },
          EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,
          {
            reason: SHARE_STOPPED_REASON.MEETING_REJOIN
          }
        );
      }
    }
    catch (joinError) {
      this.rejoinAttempts += 1;
      if (this.rejoinAttempts <= this.maxRejoinAttempts) {
        LoggerProxy.logger.info(`ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting, attempt #${this.rejoinAttempts}, retrying.`, joinError);
        this.rejoinMeeting();
      }
      else {
        LoggerProxy.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to rejoin meeting after max attempts.', joinError);
        this.status = RECONNECTION.STATE.FAILURE;
        throw joinError;
      }
    }

    try {
      await this.reconnectMedia(false);
    }
    catch (mediaError) {
      LoggerProxy.logger.error('ReconnectionManager:index#rejoinMeeting --> Unable to reestablish media after rejoining.', mediaError);
      throw mediaError;
    }
  }

  /**
   * @param {boolean} reconnect was this media reconnection from a reconnect
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  reconnectMedia(reconnect = true) {
    LoggerProxy.logger.log('ReconnectionManager:index#reconnectMedia --> Begin reestablishment of media');

    ReconnectionManager.setupPeerConnection(this.meeting);

    return Media.attachMedia(this.meeting.mediaProperties, {
      meetingId: this.meeting.id,
      remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel,
      enableRtx: this.meeting.config.enableRtx
    })
      .then((peerConnection) => this.meeting.setRemoteStream(peerConnection))
      .then(() => this.meeting.roap
        .sendRoapMediaRequest({
          sdp: this.meeting.mediaProperties.peerConnection.sdp,
          roapSeq: this.meeting.roapSeq,
          meeting: this.meeting,
          reconnect
        }));
  }

  /**
   * Attempt to Reconnect Mercury Websocket
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  async reconnectMercuryWebSocket() {
    LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Reconnecting websocket.');
    // First, attempt to disconnect if we think we are already connected.
    if (this.webex.internal.mercury.connected) {
      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Disconnecting existing websocket.');
      try {
        await this.webex.internal.mercury.disconnect();
        LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket disconnected successfully.');
      }
      catch (disconnectError) {
        // If we can't disconnect, the sdk is in such a bad state that reconnecting is not going to happen.
        LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to disconnect from websocket, giving up.', disconnectError);
        throw disconnectError;
      }
    }

    try {
      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Connecting websocket.');
      await this.webex.internal.mercury.connect();
      LoggerProxy.logger.info('ReconnectionManager:index#reconnectMercuryWebSocket --> Websocket connected successfully.');
    }
    catch (connectError) {
      LoggerProxy.logger.error('ReconnectionManager:index#reconnectMercuryWebSocket --> Unable to connect to websocket, giving up.', connectError);

      throw (connectError);
    }
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   * @private
   * @memberof ReconnectionManager
   */
  static setupPeerConnection(meeting) {
    // close pcs, unset to null and create a new one with out closing any streams
    PeerConnectionManager.close(meeting.mediaProperties.peerConnection);
    meeting.mediaProperties.unsetPeerConnection();
    meeting.mediaProperties.reInitiatePeerconnection();
    PeerConnectionManager.setPeerConnectionEvents(meeting);
    // update the peerconnection in the stats manager when ever we reconnect
    meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);
  }
}
