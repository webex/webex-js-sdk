/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

import LoggerProxy from '../common/logs/logger-proxy';
import {_ACTIVE_, RECONNECTION, _LEFT_} from '../constants';
import ReconnectionError from '../common/errors/reconnection';
import PeerConnectionManager from '../peer-connection-manager';
import Media from '../media';

/**
 * @export
 * @class ReconnectionManager
*/
export default class ReconnectionManager {
  /**
   * @param {Meeting} meeting
   */
  constructor(meeting) {
    /**
     * Stores ICE reconnection state data.
     *
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
     */
    this.iceState = {
      disconnected: false,
      resolve: () => {},
      timer: undefined,
      timeoutDuration: meeting.config.reconnection.iceReconnectionTimeout
    };

    /**
     * @instance
     * @type {String}
     * @private
     * @memberof ReconnectionManager
    */
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    /**
     * @instance
     * @type {Number}
     * @private
     * @memberof ReconnectionManager
    */
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
    /**
     * @instance
     * @type {Object}
     * @private
     * @memberof ReconnectionManager
    */
    this.webex = meeting.webex;
    /**
     * @instance
     * @type {Meeting}
     * @private
     * @memberof ReconnectionManager
     */
    this.meeting = meeting;

    this.backOff = meeting.config.reconnection.retry.backOff.start;

    // Make sure reconnection state is in default
    this.reset();
  }

  /**
   * Sets the iceState to connected and clears any disconnect timeouts and
   * related timeout data within the iceState.
   *
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  iceReconnected() {
    if (this.iceState.disconnected) {
      LoggerProxy.logger.log('ReconnectionManager:index#iceReconnected --> ice has reconnected');

      this.iceState.resolve();
      this.iceState.resolve = () => {};

      if (this.iceState.timer) {
        clearTimeout(this.iceState.timer);
        delete this.iceState.timer;
      }

      this.iceState.disconnected = false;
    }
  }

  /**
   * Set the iceState to disconnected and generates a timeout that waits for the
   * iceState to reconnect and then resolves. If the ice state is already
   * processing a reconnect, it immediately resolves. Rejects if the timeout
   * duration is reached.
   *
   * @returns {Promise<undefined>}
   * @public
   * @memberof ReconnectionManager
   */
  waitForIceReconnect() {
    if (!this.iceState.disconnected) {
      LoggerProxy.logger.log('ReconnectionManager:index#waitForIceReconnect --> waiting for ice reconnect');

      this.iceState.disconnected = true;

      return new Promise((resolve, reject) => {
        this.iceState.timer = setTimeout(() => {
          if (this.iceState.disconnected === false) {
            resolve();
          }
          else {
            this.iceState.disconnected = false;
            reject(new Error(`ice reconnection did not occur in ${this.iceState.timeoutDuration}ms`));
          }
        }, this.iceState.timeoutDuration);

        this.iceState.resolve = resolve;
      });
    }

    // return a resolved promise to prevent multiple catch executions of reconnect
    return Promise.resolve();
  }

  /**
   * @returns {undefined}
   * @public
   * @memberof ReconnectionManager
   */
  reset() {
    this.status = RECONNECTION.STATE.DEFAULT_STATUS;
    this.tryCount = RECONNECTION.STATE.DEFAULT_TRY_COUNT;
  }

  /**
   * @returns {Boolean}
   * @returns {ReconnectionError}
   * @private
   * @memberof ReconnectionManager
   */
  validate() {
    // TODO: re write the validate function
    if (this.meeting.config.reconnection.enabled) {
      if (
        this.meeting.locusInfo &&
          this.meeting.locusInfo.fullState &&
          (
            this.meeting.locusInfo.fullState.state === _ACTIVE_ &&
            this.meeting.locusInfo.fullState.active
          )
      ) {
        if (this.meeting.webex.internal.mercury.connected) {
          if (
            this.status !== RECONNECTION.STATE.DEFAULT_STATUS ||
            this.status !== RECONNECTION.STATE.COMPLETE
          ) {
            return true;
          }

          return new ReconnectionError('Multiple reconnections cannot occur concurrently');
        }

        return new ReconnectionError('mercury is not connected, cannot reconnect');
      }

      return new ReconnectionError('locus server for this call is not active, cannot reconnect');
    }

    return new ReconnectionError('Reconnection is not enabled.');
  }

  /**
   * Initiates a media reconnect for the active meeting
   * @returns {Promise}
   * @public
   * @memberof ReconnectionManager
   */
  reconnect() {
    // TODO: re write the validate function
    const validatedReconnect = this.validate();

    if (validatedReconnect === true) {
      return this.execute();
    }

    return Promise.reject(validatedReconnect);
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  execute() {
    this.status = RECONNECTION.STATE.IN_PROGRESS;

    // Makes sure only join if you are not join else continue with reconnect
    return new Promise((resolve, reject) => {
      // Irrespective of who or when a reconnect is triggred try to join if in left state
      if (this.meeting.state === _LEFT_) {
        this.meeting.join()
          .then(() => resolve())
          .catch((error) => reject(error));
      }

      resolve();
    }).then(() => this.reconnectMedia()
      .then((media) => {
        LoggerProxy.logger.log(`ReconnectionManager:index#execute --> Media reestablished at: ${new Date()}`);
        this.status = RECONNECTION.STATE.COMPLETE;

        return Promise.resolve(media);
      })
      .catch((err) => { // eslint-disable-line
        LoggerProxy.logger.error(`ReconnectionManager:index#execute --> Media reestablishment failed at: ${new Date()}`);
        if (this.tryCount > this.meeting.config.reconnection.retry.times) {
          this.status = RECONNECTION.STATE.FAILURE;

          return Promise.reject(new ReconnectionError(err));
        }
        // exponential backoff and retry logic
        setTimeout(() =>
          this.reconnect(),
        this.backOff *= this.meeting.config.reconnection.retry.backOff.rate);
      }));
  }

  /**
   * @param {Meeting} meeting
   * @returns {Promise}
   * @private
   * @memberof ReconnectionManager
   */
  reconnectMedia() {
    this.tryCount += 1;
    LoggerProxy.logger.log(`ReconnectionManager:index#media --> Begin reestablishment of media at ${new Date()}`);

    ReconnectionManager.setupPeerConnection(this.meeting);

    return Media.attachMedia(this.meeting.mediaProperties, {
      meetingId: this.meeting.id,
      remoteQualityLevel: this.meeting.mediaProperties.remoteQualityLevel
    })
      .then((peerConnection) => this.meeting.setRemoteStream(peerConnection))
      .then(() => this.meeting.roap
        .sendRoapMediaRequest({
          sdp: this.meeting.mediaProperties.peerConnection.sdp,
          roapSeq: this.meeting.roapSeq,
          meeting: this.meeting,
          reconnect: true // Need to check if its a reconnect after rejoin or media inactivity
        }));
  }

  /**
   * @param {Meeting} meeting
   * @returns {undefined}
   * @private
   * @memberof ReconnectionManager
   */
  static setupPeerConnection(meeting) {
    // close pcs, unset to null and create a new one with out closing any streams
    PeerConnectionManager.close(meeting.mediaProperties.peerConnection);
    meeting.mediaProperties.unsetPeerConnection();
    meeting.mediaProperties.reInitiatePeerconnection();

    // update the peerconnection in the stats manager when ever we reconnect
    meeting.statsAnalyzer.updatePeerconnection(meeting.mediaProperties.peerConnection);
  }
}
