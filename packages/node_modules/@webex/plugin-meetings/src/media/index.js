/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */

/* eslint-disable no-logger */
import {AUDIO_INPUT, VIDEO_INPUT} from '../constants';
import PeerConnectionManager from '../peer-connection-manager';
/**
 *
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
const Media = {};

Media.setLocalTracks = (audio, video, stream) => {
  Media.setLocalAudioTracks(audio, stream);
  Media.setLocalVideoTracks(video, stream);
};

Media.setLocalAudioTracks = (audio, stream) => {
  if (stream) {
    if (stream.getAudioTracks) {
      const [audioTrack] = stream.getAudioTracks();

      if (audioTrack) {
        audioTrack.enabled = !audio.mute;

        return true;
      }
    }
  }

  return false;
};

Media.setLocalVideoTracks = (video, stream) => {
  if (stream) {
    if (stream.getVideoTracks) {
      const [videoTrack] = stream.getVideoTracks();

      if (videoTrack) {
        videoTrack.enabled = !video.mute;

        return true;
      }
    }
  }

  return false;
};

Media.generateLocalMedias = (mediaId, audio, video) => {
  if (mediaId) {
    return [
      {
        localSdp: JSON.stringify({
          audioMuted: audio.mute,
          videoMuted: video.mute
        }),
        mediaId
      }
    ];
  }

  return [];
};

Media.getLocalMedia = (options) => {
  const {sendAudio, sendVideo, sendShare} = options;
  // we return undefined here as the second param until screen share is implemented

  if (sendAudio || sendVideo) {
    return Media.getMedia(sendAudio, sendVideo);
  }

  if (sendShare) {
    return Media.getDisplayMedia(
      {
        sendAudio: false,
        sendShare: true
      }
    );
  }

  return Promise.resolve(undefined);
};
/**
 *  Returns the direction and tracks
 * @param {string} trackType type of track (audio/video)
 * @param {object}  track  tracks passed
 * @param {boolean} receiveTracks do you want to receive tracks from the remote side
 * @returns {Object} returns direction tracks to be added in transceiver
 */
Media.checkTracks = (trackType, track, receiveTracks) => {
  const getDirection = (sendTracks, receiveTracks) => {
    if (sendTracks && receiveTracks) {
      return 'sendrecv';
    } if (sendTracks && !receiveTracks) {
      return 'sendOnly';
    } if (!sendTracks && receiveTracks) {
      return 'recvonly';
    } if (sendTracks && receiveTracks) {
      return 'inactive';
    }

    return 'inactive';
  };

  if (track) {
    return {track, direction: getDirection(!!track, receiveTracks)};
  }

  return {track: trackType, direction: getDirection(!!track, receiveTracks)};
};
/**
 * creates peerconnection and attaches streams
 * @param {object} mediaProperties mediaProperties
 * @param {Object} audioVideo audioVideo streams
 * @param {Object} localShare sendScreen: {Boolean} sendShare constraints
 * @param {Object} mappedPCs {peerConnection, sharePeerConnection}
 * @returns {Array} [peerConnection, ]
 */
Media.attachMedia = (mediaProperties) => {
  const {
    mediaDirection, audioTrack, videoTrack, shareTrack, peerConnection
  } = mediaProperties;
  let result = null;

  // Add Transceiver for audio
  result = Media.checkTracks('audio', mediaDirection.sendAudio && audioTrack, mediaDirection.receiveAudio);
  peerConnection.audioTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  // Add Transceiver for video
  result = Media.checkTracks('video', mediaDirection.sendVideo && videoTrack, mediaDirection.receiveVideo);
  peerConnection.videoTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  // Add Transceiver for share
  result = Media.checkTracks('video', mediaDirection.sendShare && shareTrack, mediaDirection.receiveShare);
  peerConnection.shareTransceiver = peerConnection.addTransceiver(result.track, {direction: result.direction});

  peerConnection.onnegotiationneeded = (event) => {
    console.log('PEER-CONNECTION ', event);
  };

  return PeerConnectionManager.createOffer(peerConnection);
};

Media.updateMedia = () => {

};

Media.updateTransceiver = (peerConnection, transceiver, options) => {
  const {
    type, track, sendTrack, receiveTrack
  } = options;

  try {
    const result = Media.checkTracks(type, sendTrack && track, receiveTrack);

    if (options.track) {
      transceiver.sender.replaceTrack(track);
    }
    transceiver.direction = result.direction;

    return PeerConnectionManager.createOffer(peerConnection);
  }
  catch (e) {
    throw e;
  }
};

/**
 * generates share streams (chrome)
 * @param {object} options parameter
 * @param {Object} options.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} options.sendScreen sendScreen: {Boolean} sendShare constraints
 * @returns {Object} {streams}
 */
Media.getDisplayMedia = (options) =>
  navigator.mediaDevices.getDisplayMedia({audio: options.sendAudio, video: options.sendScreen});

/**
 * generates audio and video using constraints (often called after getSupportedDevices)
 * @param {Object} audio audio: {Boolean} gum constraints
 * @param {Object} video video: {Boolean} gum constraints
 * @returns {Object} {streams}
 */
Media.getMedia = (audio, video) => {
  const mediaConfig = {
    audio,
    video
  };

  return new Promise((resolve, reject) => {
    navigator.mediaDevices
      .getUserMedia(mediaConfig)
      .then((stream) => {
        resolve(stream);
      })
      .catch((err) => {
        reject(
          new Error({
            name: err.name,
            localMediaFailed: true,
            cameraFailed: err === mediaConfig.permissionDenied
          })
        );
      });
  });
};

/**
 * Checks if the machine has at least one audio or video device (Dont use this for screen share)
 * @param {object} options optional parameter
 * {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 * }
 * @returns {Object} {
 *    sendAudio: true/false,
 *    sendVideo: true/false
 *}
 */
Media.getSupportedDevice = ({sendAudio, sendVideo}) =>
  Promise.resolve().then(() => {
    if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
      return {
        sendAudio: true,
        sendVideo: true
      };
    }

    return navigator.mediaDevices.enumerateDevices().then((devices) => {
      const supported = {
        audio: devices.filter((device) => device.kind === AUDIO_INPUT).length > 0,
        video: devices.filter((device) => device.kind === VIDEO_INPUT).length > 0
      };

      return {
        sendAudio: (supported.audio && sendAudio) || true,
        sendVideo: (supported.video && sendVideo) || true
      };
    });
  });

Media.getDevices = () => {
  if (navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
    return navigator.mediaDevices.enumerateDevices();
  }

  return Promise.reject(new Error('enumerateDevices not supported.'));
};

/**
 *
 * Toggle a specific stream
 * @returns {null}
 */
Media.toggleStream = () => {};

/**
 *
 * Stop input stream
 * @param {Stream} stream A media stream
 * @returns {null}
 * @memberof Media
 */
Media.stopStream = (stream) => {
  if (!stream) {
    return Promise.resolve();
  }

  /*
   * To release local media
   * 1) Chrome requires all tracks to be stopped (stream.stop got deprecated)
   * 2) Firefox requires the stream to be stopped
   */
  return Promise.resolve().then(() => {
    if (stream.getTracks) {
      stream.getTracks().forEach((track) => {
        track.stop();
      });
    }
    else if (stream.stop) {
      stream.stop();
    }
  });
};

/**
 * generates streams for audio video and share
 * @param {object} mediaSetting parameter
 * @param {Object} mediaSetting.sendAudio sendAudio: {Boolean} sendAudio constraints
 * @param {Object} mediaSetting.sendVideo sendVideo: {Boolean} sendVideo constraints
 * @param {Object} mediaSetting.sendScreen sendScreen: {Boolean} sendShare constraints
 * @param {Object} audioVideo parameter
 * @param {Object} audioVideo.audio {deviceId: {String}}
 * @param {Object} audioVideo.video {deviceId: {String}}
 * @returns {Array} [localStream, shareStream]
 */
Media.getUserMedia = (mediaSetting, audioVideo) => Media.getLocalMedia({
  sendAudio: mediaSetting.sendAudio ? audioVideo.audio || mediaSetting.sendAudio : false,
  sendVideo: mediaSetting.sendVideo ? audioVideo.video || mediaSetting.sendVideo : false
}).then((localStream) => Media.getLocalMedia({
  sendShare: mediaSetting.sendShare
}).then((shareStream) => [localStream, shareStream]));

export default Media;
