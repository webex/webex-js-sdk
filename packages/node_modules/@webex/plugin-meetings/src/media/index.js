/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */
/* globals navigator */
import {
  AUDIOINPUT,
  VIDEOINPUT
} from '../constants';
/**
 *
 * @export
 * Mimic browser APIs as "the ultimate browser".
 * Handles the quirks of each browser.
 * Extends and enhances adapter.js, i.e., the "media" file from the web client.
 */
const Media = {};

Media.localTracks = (audio, video, stream) => {
  let audioTrack;
  let videoTrack;
  if (stream) {
    if (stream.getAudioTracks) {
      [audioTrack] = stream.getAudioTracks();
    }
    if (stream.getVideoTracks) {
      [videoTrack] = stream.getVideoTracks();
    }
  }
  if (audioTrack) {
    audioTrack.enabled = audio;
  }
  // remove local video tracks not remote
  // if (videoTrack) {
  //   videoTrack.enabled = video;
  // }
};

Media.generateLocalMedias = (mediaId, audio, video) => {
  if (mediaId) {
    return [{
      localSdp: JSON.stringify({
        audioMuted: !audio,
        videoMuted: !video
      }),
      mediaId
    }];
  }
  return {};
};

Media.getLocalMedia = (options) => {
  const {sendAudio, sendVideo, sendShare} = options;
  return Promise.try(() =>
    /* Media.getScreenShare(sendShare))
    .then((screenConstraints) => Media.getMedia(false, screenConstraints))
    .then((screen) => */ Media.getMedia(
      sendAudio,
      sendVideo
    ).then((media) => [media, undefined])); // TODO define undefined as screen pc
};

Media.addMedia = (mediaDirection, pcMgr, audioVideo, screen) => {
  const promises = [];
  if (mediaDirection.receiveVideo || mediaDirection.receiveAudio) {
    promises.push(
      pcMgr.createOffer({
        receiveAudio: mediaDirection.receiveAudio,
        receiveVideo: mediaDirection.receiveVideo,
        // After you get the localStream
        streams: audioVideo
      })
    );
    promises.push(
      pcMgr.createOffer({
        // its for screen sharing but can change in future when user wants just share with audio
        receiveAudio: false,
        receiveVideo: mediaDirection.receiveVideo,
        // After you get the localStream
        streams: screen
      })
    );
  }
  return Promise.all(promises);
};

/**
* generates audio and video using constraints (often called after getSupportedDevices)
* @param {Object} audio audio: {Boolean} gum constraints
* @param {Object} video video: {Boolean} gum constraints
* @returns {Object} {streams}
*/
Media.getMedia = (audio, video) => {
  const mediaConfig = {
    audio,
    video
  };

  return new Promise(((resolve, reject) => {
    navigator.mediaDevices.getUserMedia(mediaConfig)
      .then((stream) => {
        resolve(stream);
      })
      .catch((err) => {
        reject(new Error({
          name: err.name,
          localMediaFailed: true,
          cameraFailed: err === mediaConfig.permissionDenied
        }));
      });
  }));
};


/**
* Checks if the machine has at least one audio or video device (Dont use this for screen share)
* @param {object} options optional parameter
* {
*    sendAudio: true/false,
*    sendVideo: true/false
* }
* @returns {Object} {
*    sendAudio: true/false,
*    sendVideo: true/false
*}
*/
Media.getSupportedDevice = (options = {
  sendAudio: true,
  sendVideo: true
}) => {
  const constraints = options;
  if (!navigator.mediaDevices || navigator.mediaDevices.enumerateDevices === undefined) {
    return Promise.resolve({sendAudio: true, sendVideo: true});
  }

  return new Promise(((resolve, reject) => {
    navigator.mediaDevices.enumerateDevices()
      .then((devices) => {
        // TODO handle constants
        const supported = {
          audio: devices.filter((device) => device.kind === AUDIOINPUT).length > 0,
          video: devices.filter((device) => device.kind === VIDEOINPUT).length > 0
        };
        this.devices = {
          sendAudio: (supported.audio && constraints.sendAudio),
          sendVideo: (supported.video && constraints.sendVideo)
        };
        resolve(this.devices);
      })
      .catch((err) => {
        console.error(`Not able to get supported device${err.name}: ${err.message}`);
        reject(err);
      });
  }));
};

/**
 *
 * Toggle a specific stream
 * @returns {null}
 */
Media.toggleStream = () => {};

/**
 *
 * Stop input stream
 * @returns {null}
 * @memberof Media
 */
Media.stopStream = () => {};

export default Media;
