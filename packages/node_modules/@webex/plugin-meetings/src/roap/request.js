/* eslint require-jsdoc:0 */
/* globals window */

import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {PARTICIPANT, LOCI, CALL, POST, DEVELOPMENT, MEDIA, PUT, LOCUS} from '../constants';

const config = window;

export default class RoapRequest extends StatelessSparkPlugin {
  joinMeetingWithRoap(options) {
    config.console.info('Call->Locus: Join locus with roap');
    config.console.info('Call-local SDP', options.roapMessage);
    const deviceUrl = this.spark.internal.device.url;
    let url = '';

    const body = {
      deviceUrl,
      usingResource: options.resourceId || null,
      correlationId: options.correlationId,
      localMedias: [
        {
          localSdp: JSON.stringify({
            roapMessage: options.roapMessage,
            audioMuted: false,
            videoMuted: false
          })
        }
      ]
    };

    if (options.locusUrl) {
      url = `${options.locusUrl}/${PARTICIPANT}`;
    }
    else {
      url = `${this.spark.internal.device.services.locusServiceUrl}/${LOCI}/${CALL}`;
      body.invitee = {
        address: options.sipTarget
      };
    }

    return this.spark
      .request({
        method: POST,
        uri: url,
        body
      })
      .then((res) => {
        const {locus} = res.body;
        locus.roapSeq = options.roapMessage.seq;
        locus.id = locus.url.split('/').pop();
        config.console.info(`Call-Locus->App: Joined locus [${locus.id}][${locus.fullState.lastActive}]`);
        return locus;
      })
      .catch((err) => {
        config.console.error('joinMeetingWithRoap : ', err);
        this.logError('MeetingAdapter#joinMeetingWithRoap failed', err);
        return Promise.reject(err);
      });
  }

  logError(message, error) {
    // Throw the exception so we can get a call stack
    if (process.env.NODE_ENV === DEVELOPMENT) {
      config.console.error(message);
      throw error;
    }
    else {
      config.console.error(message, error);
    }
  }

  sendRoap(options) {
    const {
      roapMessage, locusId, locusSelfId, mediaId, correlationId
    } = options;

    if (!mediaId) {
      config.console.info('Race Condition /call mediaID not present');
    }

    const mediaUrl = `${LOCI}/${locusId}/${PARTICIPANT}/${locusSelfId}/${MEDIA}`;
    const deviceUrl = this.spark.internal.device.url;

    config.console.info(`Call-sendRoap: ${mediaUrl} \n ${roapMessage.messageType} \n seq:${roapMessage.seq}`);

    return this.spark
      .request({
        api: LOCUS,
        resource: mediaUrl,
        method: PUT,
        body: {
          deviceUrl,
          correlationId,
          localMedias: [
            {
              localSdp: JSON.stringify({
                roapMessage,
                // TODO: check whats the need for video and audiomute
                audioMuted: !!options.audioMuted,
                videoMuted: !!options.audioVideo
              }),
              mediaId: options.mediaId
            }
          ]
        }
      })
      .then((res) => {
        // always it will be the first mediaConnection Object
        const mediaConnection
          = res.body.mediaConnections && res.body.mediaConnections.length > 0 && res.body.mediaConnections[0];
        config.console.info(
          `Call-sendRoap:response:${JSON.stringify(mediaConnection, null, 2)}'\n StatusCode:'${res.statusCode}`
        );
        const {locus} = res.body;
        locus.roapSeq = options.roapMessage.seq;
        return locus;
      })
      .catch((err) => {
        config.console.error(`Call-sendRoap Error:${JSON.stringify(err, null, 2)}`);
        config.console.error(
          `Call-sendRoap errorBody:${JSON.stringify(roapMessage, null, 2)} + '\\n mediaId:'${options.mediaId}`
        );
        throw new Error(err);
      });
  }
}
