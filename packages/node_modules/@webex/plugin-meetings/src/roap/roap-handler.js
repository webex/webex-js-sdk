/* eslint require-jsdoc:0 */
/* globals window */
import {SparkPlugin} from '@ciscospark/spark-core';

import {ROAP, ERROR, CONFLICT, IDLE, OFFER, REQUESTED, ANSWER} from '../constants';
import PeerConnectionManager from '../peer-connection-manager';

const config = window;

const RoapHandler = SparkPlugin.extend({
  sessions: {},
  initialize() {
    this.spark.internal.mercury.on(ROAP.ROAP_MERCURY, (result) => {
      const msg = result.data.message;

      // TODO: not going to use locusID any more
      // var locusId = result.data.locusId;
      const {correlationId} = result.data;
      config.console.info(`Call-Mercury->-App: receives Roap Message [${JSON.stringify(msg, null, 2)}]`);
      this.submit({
        type: ROAP.RECEIVE_ROAP_MSG,
        msg,
        correlationId
      });
    });
  },
  // returns true if a state update is to be triggered
  save(roap) {
    const {correlationId} = roap;
    const {seq: sequenceId, messageType, errorType} = roap.msg;

    config.console.info('Call-RoapHandler: CorrelationID, ', correlationId);

    const meeting = this.spark.meetings.meetingCollection.get(correlationId);

    if (messageType === ERROR && errorType === CONFLICT) {
      // reset the peer-connection and send the request

      PeerConnectionManager.rollBackLocalDescription({mediaPeerConnection: meeting.mediaPeerConnection})
        .then(() => {
          config.console.info('Delete the sequence data ', sequenceId);

          if (meeting) {
            config.console.info('emitting the callStore changes');
            meeting.shareStatus = IDLE;
          }
          delete this.sessions[correlationId][sequenceId];
        })
        .catch((err) => {
          config.console.info('Cannot reset the peer connection', err);
        });

      return false;
    }

    this.sessions[correlationId] = this.sessions[correlationId] || {};
    this.sessions[correlationId][sequenceId] = this.sessions[correlationId][sequenceId] || {};

    if (this.sessions[correlationId][sequenceId].OFFER && messageType === OFFER) {
      this.sessions[correlationId][sequenceId].GLARE_OFFER = roap.msg;
      this.sessions[correlationId][sequenceId].GLARE_OFFER.remote = !!roap.remote;
      config.console.info(`Its a GLARE condition seq:${sequenceId} new mercury event`);
    }
    else {
      config.console.info(
        `Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(
          this.sessions[correlationId][sequenceId].state,
          null,
          2
        )}`
      );
      this.sessions[correlationId][sequenceId][messageType] = roap.msg;
      this.sessions[correlationId][sequenceId][messageType].remote = !!roap.remote;
    }

    if (meeting) {
      if (messageType === OFFER && roap.remote && meeting.shareStatus === REQUESTED) {
        // The peer-connection is waiting for answer but got an offer Reset. Try to
        // send the offer later after you accept the answer
        config.console.info(
          `Call-RoapHandler:The peer-connection has changed before sending the request:${sequenceId}`
        );
        // Roapint.sendRoapError(RoapHandler.sessions[correlationId][sequenceId], MeetingCollection.calls[correlationId], 'CONFLICT');
        return false;
      }
    }

    // initialize state
    if (!this.sessions[correlationId][sequenceId].state) {
      this.sessions[correlationId][sequenceId].state = ROAP.RoapState.INIT;
    }

    // Assuming the mercury event has come first before the response for the event
    // we have to wait for the response and trigger the ROAP request later on
    if (meeting && (!meeting.mediaPeerConnection && !meeting.screenPeerConnection) && messageType === ANSWER) {
      config.console.info(
        `Call-RoapHandler: Got RemoteSdp Mercury event before \`/participants\` response correlationId: ${correlationId}`
      );
      return false;
    }

    config.console.info('Call-RoapHandler: success save proceeding with transition, ', roap.msg);

    return true;
  },

  /* eslint-disable no-empty */
  // jscs:disable

  // signal: action perfomed and signaled
  // session: current session Object
  // meeting: meeting object
  transition(signal, session, meeting) {
    const prevState = session.state;
    config.console.info('Call-RoapHandler# Current state %s action %s', prevState, signal);

    switch (session.state) {
      case ROAP.RoapState.INIT:
        if (signal === ROAP.RoapSignal.RX_OFFER) {
          session.state = ROAP.RoapState.WAIT_TX_ANSWER;
        }
        else if (signal === ROAP.RoapSignal.TX_OFFER) {
          session.state = ROAP.RoapState.WAIT_RX_ANSWER;
        }
        break;

      case ROAP.RoapState.WAIT_RX_OFFER:
        break;
      case ROAP.RoapState.WAIT_RX_ANSWER:
        if (signal === ROAP.RoapSignal.RX_ANSWER) {
          // There is a race condition where the /call response comes after mercury event from the server
          // As mercury sends roap event if it didnt get back a response. We can send the roap ok after that
          if (meeting.mediaId) {
            session.state = ROAP.RoapState.WAIT_TX_OK;
          }
          else {
            config.console.error('Call-RoapHandler#Race Condition no mediaId');
          }
        }
        else if (signal === ROAP.RoapSignal.RX_OFFER) {
          session.state = ROAP.RoapState.GLARE;
        }
        break;

      case ROAP.RoapState.WAIT_TX_OFFER:
        break;
      case ROAP.RoapState.WAIT_TX_ANSWER:
        if (signal === ROAP.RoapSignal.TX_ANSWER) {
          session.state = ROAP.RoapState.WAIT_RX_OK;
        }
        break;

      case ROAP.RoapState.WAIT_TX_OK:
        if (signal === ROAP.RoapSignal.TX_OK) {
          session.state = ROAP.RoapState.INIT;
        }
        break;
      case ROAP.RoapState.WAIT_RX_OK:
        if (signal === ROAP.RoapSignal.RX_OK) {
          session.state = ROAP.RoapState.INIT;
        }
        break;
      case ROAP.RoapState.ERROR:
        // TODO: resolve error state. Add a signal constant and handle the cleanup
        session.state = ROAP.RoapState.INIT;
        break;
      case ROAP.RoapState.GLARE:
        session.state = ROAP.RoapState.WAIT_RX_ANSWER;
        break;
      default:
        break;
    }

    if (!session.state) {
      config.console.error('Call-RoapHandler#transition invalid state', session);
    }
    // TODO emit with pub sub for the state transition for any listeners that need the update
    // RoapHandler.emit(Constants.ROAP_TRANSITION, session.state);
    config.console.info(
      'Call-RoapHandler# transition roapSeq %d , %s : %s to %s ',
      session.OFFER ? session.OFFER.seq : null,
      signal,
      prevState,
      session.state
    );

    this.performState(session, meeting);
  },

  performState(session, meeting) {
    config.console.info('CALL-RoapHandler: PerfomState ', session.state);

    const setRemoteDescription = () => {
      config.console.info('Call-RoapHandler: Transmite WAIT_TX_OK', meeting.correlationId);

      // if (meeting && meeting.shareStatus === 'REQUESTED') {
      //   MeetingClientActionCreators.sendFloorGrant(meeting);
      // }

      if (!(meeting && (meeting.mediaPeerConnection || meeting.screenPeerConnection))) {
        config.console.error('Call-RoapHandler: DANGER no media or screen peer connection', meeting.correlationId);
        return;
      }

      let promise;

      if (meeting.mediaPeerConnection && meeting.screenPeerConnection) {
        promise = Promise.all([
          PeerConnectionManager.setRemoteSessionDetails(
            meeting.mediaPeerConnection,
            'answer',
            session.ANSWER.sdps[0],
            meeting.clientIdentifiers
          ),
          PeerConnectionManager.setRemoteSessionDetails(
            meeting.screenPeerConnection,
            'answer',
            session.ANSWER.sdps[1],
            meeting.clientIdentifiers
          )
        ]);
      }
      else if (meeting.screenPeerConnection) {
        promise = PeerConnectionManager.setRemoteSessionDetails(
          meeting.screenPeerConnection,
          'answer',
          session.ANSWER.sdps[0],
          meeting.clientIdentifiers
        );
      }

      promise
        .then(() => {
          config.console.info('Call-RoapHandler: setRemote Description successfull', meeting.correlationId);

          return this.spark.meetings.roap.sendRoapOK({
            seq: session.ANSWER.seq,
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            correlationId: meeting.correlationId
          });
        })
        .catch((err) => {
          config.console.error('Call-RoapHandler: Error setting remote and sending Roap Message', err);
        });
    };

    const mediaOffer = meeting.mediaPeerConnection && meeting.mediaPeerConnection.signalingState === 'have-local-offer';
    const screenOffer
      = meeting.screenPeerConnection && meeting.screenPeerConnection.signalingState === 'have-local-offer';

    switch (session.state) {
      // case ROAP.RoapState.INIT:
      // case ROAP.RoapState.WAIT_RX_OFFER:
      // case ROAP.RoapState.WAIT_RX_ANSWER:
      // case ROAP.RoapState.WAIT_RX_OK:

      // TODO: default audio and video , change later
      case ROAP.RoapState.WAIT_TX_ANSWER:
        // TODO: sometime the you get an answer while you are creating an offer so SKIP
        // Server will send the mercury event comes back

        if (mediaOffer || screenOffer) {
          return;
        }

        PeerConnectionManager.updatePeerConnection({
          offerSdp: session.OFFER.sdps,
          pc: meeting.mediaPeerConnection,
          screenPeerConnection: meeting.screenPeerConnection,
          offerToReceiveAudio: true,
          offerToReceiveVideo: true
        }).then((answerSdps) => {
          this.spark.meetings.roap.sendRoapAnswer({
            locusId: meeting.locusId,
            locusSelfId: meeting.locus.self.id,
            mediaId: meeting.mediaId,
            sdps: answerSdps,
            roapSeq: session.OFFER.seq,
            correlationId: meeting.correlationId
          });
        });
        break;
      case ROAP.RoapState.WAIT_TX_OK:
        setRemoteDescription();
        break;
      // case ROAP.RoapState.IDLE_LOCAL_OFFER:
      case ROAP.RoapState.ERROR:
        config.console.error('Call-RoapHandler#ERROR state=error', session);
        break;
      case session.state === ROAP.RoapState.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        config.console.error('Resolve the GLARE condition');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          config.console.error('local offer wins');
        }
        else {
          config.console.error('remote offer wins', session);
        }
        this.transition(ROAP.RoapSignal.GLARE_RESOLVED, session, meeting);
        break;
      default:
        break;
    }
  },

  submit(action) {
    let session;
    const {correlationId} = action;
    const meeting = this.spark.meetings.meetingCollection.get(correlationId);
    let signal;
    let logging = true;

    switch (action.type) {
      case ROAP.RECEIVE_ROAP_MSG:
        // TODO: handle incomplete sequences

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#RECEIVE_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.remote = true;
        if (this.save(action)) {
          session = this.sessions[correlationId][action.msg.seq];
          signal = ROAP.RoapSignal[`RX_${action.msg.messageType}`];
          this.transition(signal, session, meeting);
        }
        break;

      case ROAP.SEND_ROAP_MSG:
        // TODO: handle incomplete sequences
        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-RoapHandler#SEND_ROAP_MSG: should always have meeting object on roap event');
          break;
        }
        action.local = true;
        if (this.save(action)) {
          session = this.sessions[correlationId][action.msg.seq];
          signal = ROAP.RoapSignal[`TX_${action.msg.messageType}`];
          this.transition(signal, session, meeting);
        }
        break;

      case ROAP.SEND_ROAP_MSG_SUCCESS:
        session = this.sessions[correlationId][action.seq];

        if (!meeting) {
          // There should be a meeting object for each roap call associated
          config.console.error('Call-this#SEND_ROAP_MSG_SUCCESS: should always have meeting object on roap event');
          break;
        }
        // This means we got and answer and waiting for 200 ok for /participants
        if (this.sessions && this.sessions[correlationId][action.seq].ANSWER) {
          signal = ROAP.RoapSignal.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;

      case 'RECEIVE_CALL_LEAVE':
        delete this.sessions[correlationId];
        config.console.info('Call-this#RECEIVE_CALL_LEAVE: cleaning up the RoapHandler', correlationId);
        break;
      case ROAP.RESET_ROAP_STATE:
        delete this.sessions[correlationId][action.msg.seq];
        config.console.info('Call-RoapHandler#RESET_ROAP_STATE: resetting the RoapHandler state', action.msg.seq);
        break;
      default:
        logging = false;
        return true;
    }

    if (logging) {
      config.console.log('Call-RoapHandler: Event %s ,  %s , %s', action.type, correlationId, action.msg);
    }
    return true;
  }
});

export default RoapHandler;
