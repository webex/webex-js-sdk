import {isEmpty} from 'lodash';

import PeerConnectionManager from '../peer-connection-manager';
import {
  _ANSWER_,
  _ERROR_,
  _CONFLICT_,
  ROAP,
  SDP,
  _S_LINE
} from '../constants';
import LoggerProxy from '../common/logs/logger-proxy';
import ParameterError from '../common/errors/parameter';

const RoapUtil = {};
const ROAP_ANSWER = _ANSWER_.toLowerCase();

RoapUtil.shouldHandleMedia = (meeting) => {
  const offer =
    meeting.mediaProperties.peerConnection &&
    meeting.mediaProperties.peerConnection.signalingState === SDP.HAVE_LOCAL_OFFER;

  if (offer) {
    return false;
  }

  return true;
};

RoapUtil.handleError = (pc) =>
  PeerConnectionManager.rollBackLocalDescription({peerConnection: pc})
    .then(() => Promise.resolve(true))
    .catch((err) => Promise.reject(err));

RoapUtil.findError = (messageType, errorType, type) =>
  (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG) && messageType === _ERROR_ && errorType === _CONFLICT_;

RoapUtil.ensureMeeting = (meeting, type) => {
  if (type === ROAP.RECEIVE_ROAP_MSG || type === ROAP.SEND_ROAP_MSG || type === ROAP.SEND_ROAP_MSG_SUCCESS) {
    if (!meeting) {
      return false;
    }
  }

  return true;
};

RoapUtil.compareLastRemoteOffer = (currentOffer, previousOffer) => {
  let index1, index2;
  let difference = false;

  if (isEmpty(previousOffer)) {
    return true;
  }

  // TODO: fix roap issue where chrome cannot create offer after replaceTrack and createOffer
  if (previousOffer.length > 0 && previousOffer.length === currentOffer.length) {
    previousOffer.forEach((sdp, index) => {
      index1 = sdp.indexOf(_S_LINE);
      index2 = currentOffer[index].indexOf(_S_LINE);
      if (sdp.substring(index1) !== currentOffer[index].substring(index2)) {
        difference = true;
      }
    });
  }

  return difference;
};

RoapUtil.updatePeerConnection = (meeting, session) => {
  const res = RoapUtil.compareLastRemoteOffer(session.OFFER.sdps, meeting.roap.lastRoapOffer);

  // when roap messages are same or roap message not present
  if (!res && Object.keys(meeting.roap.lastRoapOffer).length > 0) {
    const sdpPromises = [];

    LoggerProxy.logger.info('Meeting/RoapUtil: Previous Roap Offer is same as current offer');
    if (meeting.mediaProperties.peerConnection) {
      sdpPromises.push(meeting.mediaProperties.peerConnection.sdp);
    }

    return Promise.resolve(sdpPromises);
  }

  return PeerConnectionManager.updatePeerConnection({
    offerSdp: session.OFFER.sdps,
    peerConnection: meeting.mediaProperties.peerConnection
  },
  meeting.id)
    .then((res) => {
      meeting.roap.lastRoapOffer = session.OFFER.sdps;

      return res;
    });
};


RoapUtil.setRemoteDescription = (meeting, session) => {
  LoggerProxy.logger.info(`RoapUtil->setRemoteDescription#Transmit WAIT_TX_OK, correlationId: ${meeting.correlationId}`);
  if (!(meeting && (meeting.mediaProperties.peerConnection))) {
    LoggerProxy.logger.error(`RoapUtil->setRemoteDescription#DANGER no media or screen peer connection, correlationId: ${meeting.correlationId}`);

    return Promise.reject(new ParameterError('Must provide a media or screen peer connection'));
  }

  return PeerConnectionManager.setRemoteSessionDetails(
    meeting.mediaProperties.peerConnection,
    ROAP_ANSWER,
    session.ANSWER.sdps[0],
    meeting.id
  ).then(() => {
    LoggerProxy.logger.info(`RoapUtil->setRemoteDescription#Success for correlationId: ${meeting.correlationId}`);

    return {
      seq: session.ANSWER.seq,
      locusId: meeting.locusId,
      locusSelfId: meeting.locusInfo.self.id,
      mediaId: meeting.mediaId,
      correlationId: meeting.correlationId
    };
  })
    .catch((err) => {
      throw err;
    });
};

export default RoapUtil;
