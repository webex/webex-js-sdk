/* no-param-reassign */
import {StatelessWebexPlugin} from '@webex/webex-core';

import LoggerProxy from '../common/logs/logger-proxy';
import {ROAP, _OFFER_} from '../constants';
import RoapUtil from '../roap/util';
import RoapCollection from '../roap/collection';

const checkForAndHandleErrors = (action, meeting, correlationId) => {
  if (action && action.type) {
    if (action.msg && action.msg.messageType && action.msg.errorType) {
      if (RoapUtil.findError(action.msg.messageType, action.msg.errorType, action.type)) {
        RoapUtil.handleError(meeting.mediaProperties.peerConnection)
          .then((res) => {
            if (res) {
              RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
            }
          })
          .catch((err) => {
            LoggerProxy.logger.warn(`Roap:handler#checkForAndHandleErrors --> Cannot reset the peer connection with error: ${err}`);
          });

        return true;
      }
    }
    if (!RoapUtil.ensureMeeting(meeting, action.type)) {
      return true;
    }
  }

  return false;
};

const handleSessionStep = (roap, session) => {
  const {seq: sequenceId, messageType} = roap.msg;

  if (session.OFFER && messageType === _OFFER_) {
    session.GLARE_OFFER = roap.msg;
    session.GLARE_OFFER.remote = !!roap.remote;
    LoggerProxy.logger.warn(`Roap:handler#handleSessionStep --> Glare condition occurred with new mercury event, sequenceId: ${sequenceId}`);
  }
  else {
    LoggerProxy.logger.info(`Roap:handler#handleSessionStep --> Save OFFER/ANSWER seq:${sequenceId} new mercury event ${messageType}local state: ${JSON.stringify(session.state.state, null, 2)}`);
    session[messageType] = roap.msg;
    session[messageType].remote = !!roap.remote;
  }
};

/**
 * @class RoapHandler
 */
export default class RoapHandler extends StatelessWebexPlugin {
  constructor(attrs, options, roapOk, roapAnswer) {
    super({}, options);
    this.attrs = attrs;
    this.options = options;
    this.roapOk = roapOk;
    this.roapAnswer = roapAnswer;
  }

  /**
   *
   * @param {Object} session
   * @param {Meeting} meeting
   * @param {Object} action
   * @returns {null}
   */
  perform(session, meeting, action) {
    switch (session.state.state) {
      // case ROAP.ROAP_STATE.INIT:
      // case ROAP.ROAP_STATE.WAIT_RX_OFFER:
      // case ROAP.ROAP_STATE.WAIT_RX_ANSWER:
      // case ROAP.ROAP_STATE.WAIT_RX_OK:
      case ROAP.ROAP_STATE.WAIT_TX_ANSWER:
        // eslint-disable-next-line no-warning-comments
        // TODO: sometime the you get an answer while you are creating an offer so SKIP
        // Server will send the mercury event comes back
        if (RoapUtil.shouldHandleMedia(meeting)) {
          RoapUtil.updatePeerConnection(meeting, session)
            .then((answerSdps) => {
              this.roapAnswer({
                locusId: meeting.locusId,
                locusSelfId: meeting.locusInfo.self.id,
                mediaId: meeting.mediaId,
                sdps: answerSdps,
                seq: session.OFFER.seq,
                correlationId: meeting.correlationId,
                audioMuted: meeting.isAudioMuted(),
                videoMuted: meeting.isVideoMuted()
              });
            })
            .catch((err) => {
              LoggerProxy.logger.error(`Roap:handler#perform --> Error occured during wait receive answer, continuing, ${err}`);
            });
        }
        break;
      case ROAP.ROAP_STATE.WAIT_TX_OK:
        if (!RoapUtil.shouldHandleMedia(meeting)) {
          RoapUtil.setRemoteDescription(meeting, session).then((res) => {
            this.roapOk(res);
          });
        }
        break;
      // case ROAP.ROAP_STATE.IDLE_LOCAL_OFFER:
      case ROAP.ROAP_STATE.ERROR:
        LoggerProxy.logger.error(`Roap:handler#perform --> Roap State ERROR for session: ${session}`);
        break;
      case ROAP.ROAP_STATE.GLARE:
        session.GLARE_OFFER.tieBreaker = session.GLARE_OFFER.tieBreaker || 0;
        session.OFFER.tieBreaker = session.OFFER.tieBreaker || 0;
        LoggerProxy.logger.warn('Roap:handler#perform --> Roap State resolved the GLARE condition.');
        if (session.GLARE_OFFER.tieBreaker < session.OFFER.tieBreaker) {
          // 2
          LoggerProxy.logger.log('Roap:handler#perform --> Roap State local offer won after GLARE.');
        }
        else {
          LoggerProxy.logger.log('Roap:handler#perform --> Roap State remote offer won after GLARE.');
        }
        session.state.step(ROAP.ROAP_SIGNAL.GLARE_RESOLVED, meeting, action);
        this.perform(session, meeting);
        break;
      default:
        break;
    }
  }

  /**
   *
   * @param {String} signal
   * @param {Object} session
   * @param {Object} action
   * @param {Meeting} meeting
   * @param {String} prefix
   * @returns {null}
   */
  execute(signal, session, action, meeting, prefix) {
    if (session && session.state) {
      handleSessionStep(action, session);
      signal = ROAP.ROAP_SIGNAL[`${prefix}${action.msg.messageType}`];
      session.state.step(signal, meeting, action);
      this.perform(session, meeting, action);
    }
  }

  /**
   *
   * @param {Object} session
   * @param {Object} action
   * @param {Meeting} meeting
   * @param {String} correlationId
   * @returns {Boolean}
   */
  handleAction(session, action, meeting, correlationId) {
    let signal;

    switch (action.type) {
      case ROAP.RECEIVE_ROAP_MSG:
        action.remote = true;
        this.execute(signal, session, action, meeting, ROAP.RX_);
        break;
      case ROAP.SEND_ROAP_MSG:
        action.local = true;
        this.execute(signal, session, action, meeting, ROAP.TX_);
        break;
      case ROAP.SEND_ROAP_MSG_SUCCESS:
        // This means we got and answer and waiting for 200 ok for /participants
        if (RoapCollection.getSessionSequence(correlationId, action.seq).ANSWER) {
          signal = ROAP.ROAP_SIGNAL.RX_ANSWER;
          // NOTE: When server send back an answer via mercury the
          // remote SDP is already saved sent and ok message is sent back
          // We dont have to indicate the roapHandler about the RX_ANSWER via SEND_ROAP_MSG_SUCCESS
          // RoapHandler.transition(signal, session, meeting);
        }
        break;
      case ROAP.RECEIVE_CALL_LEAVE:
        RoapCollection.deleteSession(correlationId);
        LoggerProxy.logger.log(`Roap:handler#handleAction --> RECEIVE_CALL_LEAVE event captured, cleaning up the RoapHandler for correlationId: ${correlationId}`); break;
      case ROAP.RESET_ROAP_STATE:
        RoapCollection.deleteSessionSequence(correlationId, action.msg.seq);
        LoggerProxy.logger.log(`Roap:handler#handleAction --> RESET_ROAP_STATE event captured, resetting the RoapHandler state based on sequenceId: ${action.msg.seq}`); break;
      default:
        return true;
    }

    return true;
  }

  /**
   *
   * @param {Object} action
   * @returns {Boolean}
   */
  submit(action) {
    const {correlationId} = action;
    let {seq} = action;

    if (!seq && action.msg) {
      seq = action.msg.seq;
    }
    const session = RoapCollection.getSessionSequence(correlationId, seq);
    const meeting = this.webex.meetings.meetingCollection.get(correlationId);

    if (checkForAndHandleErrors(action, meeting, correlationId)) {
      return true;
    }

    return this.handleAction(session, action, meeting, correlationId);
  }
}
