/*!
 * Copyright (c) 2015-2018 Cisco Systems, Inc. See LICENSE file.
 */

import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {MEETINGS, MEETING_LINK, SIP_URI} from '../constants';

import MeetingInfoCollection from './collection';
import MeetingInfoRequest from './request';
import MeetingInfoUtil from './util';

/**
 * @class MeetingInfo
 */
export default class MeetingInfo extends StatelessSparkPlugin {
  namespace = MEETINGS;

  /**
   *
   * @param {Object} attrs
   * @param {Object} options
   */
  constructor(attrs, options) {
    super({}, options);
    this.meetingInfoRequest = new MeetingInfoRequest({}, options);
  }

  /**
   * @param {string} id
   * @returns {object}
   * @memberof MeetingInfo
   */
  static getMeetingInfo(id) {
    return MeetingInfoCollection.get(id);
  }

  /**
   * @param {string} id
   * @param {object} info
   * @returns {null}
   * @memberof MeetingInfo
   */
  static setMeetingInfo(id, info) {
    MeetingInfoCollection.set(id, info);
  }

  /**
   * Helper to make the actual MeetingInfo request and set the meetingInfo if successful, else reject
   * @param {Object} options
   * @returns {Promise}
   * @private
   */
  requestFetchInfo(options) {
    return this.meetingInfoRequest.fetchMeetingInfo(options).then((info) => {
      MeetingInfo.setMeetingInfo(info.id, info);
      return info;
    }).catch((error) => Promise.reject(error));
  }

  /**
   * Helper to generate the options for the MeetingInfo request
   * @param {String} destination
   * @param {String} type
   * @returns {Object}
   * @private
   */
  fetchInfoOptions(destination, type) {
    return MeetingInfoUtil.generateOptions({
      destination,
      type,
      conversationServiceUrl: this.spark.internal.device.services.conversationServiceUrl
    });
  }

  /**
   * Fetches meeting info from the server
   * @param {String} destination one of many different types of destinations to look up info for
   * @param {String} type optional type to match up with the destination value
   * @returns {Promise} returns a meeting info object
   * @public
   */
  fetchMeetingInfo(destination, type = null) {
    const options = this.fetchInfoOptions(destination, type);
    return this.requestFetchInfo(options).catch((error) => {
      // retry meeting info fetch logic
      // if it failed first as a meeting link
      // try converting it to a sip address
      // and doing the look up as a SIP_URI against server
      if (options.type === MEETING_LINK) {
        return this.requestFetchInfo(this.fetchInfoOptions(MeetingInfoUtil.convertLinkToSip(destination), SIP_URI));
      }
      return Promise.reject(error);
    });
  }
}
