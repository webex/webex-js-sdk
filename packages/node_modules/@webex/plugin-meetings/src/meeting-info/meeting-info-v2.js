
import {HTTP_VERBS} from '../constants';

import MeetingInfoUtil from './utilv2';

const PASSWORD_ERROR_DEFAULT_MESSAGE = 'Password required. Call fetchMeetingInfo() with password argument';
const CAPTCHA_ERROR_DEFAULT_MESSAGE = 'Captcha required. Call fetchMeetingInfo() with captchaInfo argument';

/**
 * Error to indicate that wbxappapi requires a password
 */
export class MeetingInfoV2PasswordError extends Error {
  /**
    *
    * @constructor
    * @param {Number} [wbxAppApiErrorCode]
    * @param {Object} [meetingInfo]
    * @param {String} [message]
    */
  constructor(wbxAppApiErrorCode, meetingInfo, message = PASSWORD_ERROR_DEFAULT_MESSAGE) {
    super(`${message}, code=${wbxAppApiErrorCode}`);
    this.name = 'MeetingInfoV2PasswordError';
    this.sdkMessage = message;
    this.stack = (new Error()).stack;
    this.wbxAppApiCode = wbxAppApiErrorCode;
    this.meetingInfo = meetingInfo;
  }
}

/**
   * Error to indicate that wbxappapi requires a captcha
   */
export class MeetingInfoV2CaptchaError extends Error {
  /**
    *
    * @constructor
    * @param {Number} [wbxAppApiErrorCode]
    * @param {Object} [captchaInfo]
    * @param {String} [message]
    */
  constructor(wbxAppApiErrorCode, captchaInfo, message = CAPTCHA_ERROR_DEFAULT_MESSAGE) {
    super(`${message}, code=${wbxAppApiErrorCode}`);
    this.name = 'MeetingInfoV2PasswordError';
    this.sdkMessage = message;
    this.stack = (new Error()).stack;
    this.wbxAppApiCode = wbxAppApiErrorCode;
    this.isPasswordRequired = wbxAppApiErrorCode === 423005;
    this.captchaInfo = captchaInfo;
  }
}

/**
   * @class MeetingInfo
   */
export default class MeetingInfoV2 {
  /**
     *
     * @param {WebexSDK} webex
     */
  constructor(webex) {
    this.webex = webex;
  }

  /**
     * converts hydra id into conversation url and persons Id
     * @param {String} destination one of many different types of destinations to look up info for
     * @param {String} [type] to match up with the destination value
     * @returns {Promise} returns destination and type
     * @public
     * @memberof MeetingInfo
     */
  fetchInfoOptions(destination, type = null) {
    return MeetingInfoUtil.getDestinationType({
      destination,
      type,
      webex: this.webex
    });
  }

  /**
     * Fetches meeting info from the server
     * @param {String} destination one of many different types of destinations to look up info for
     * @param {String} [type] to match up with the destination value
     * @param {String} password
     * @param {Object} captchaInfo
     * @param {String} captchaInfo.code
     * @param {String} captchaInfo.id
     * @returns {Promise} returns a meeting info object
     * @public
     * @memberof MeetingInfo
     */
  async fetchMeetingInfo(destination, type = null, password = null, captchaInfo = null) {
    const destinationType = await MeetingInfoUtil.getDestinationType({
      destination,
      type,
      webex: this.webex
    });
    const body = await MeetingInfoUtil.getRequestBody({...destinationType, password, captchaInfo});
    const directURI = await MeetingInfoUtil.getDirectMeetingInfoURI(destinationType);

    return this.webex.request({
      method: HTTP_VERBS.POST,
      service: 'webex-appapi-service',
      resource: 'meetingInfo',
      uri: directURI, // possibly null, will fall back to looking up service uri
      body
    })
      .catch((err) => {
        if (err?.statusCode === 403) {
          throw new MeetingInfoV2PasswordError(err.body?.code, err.body?.data?.meetingInfo);
        }
        if (err?.statusCode === 423) {
          throw new MeetingInfoV2CaptchaError(err.body?.code, {
            captchaId: err.body.captchaID,
            verificationImageURL: err.body.verificationImageURL,
            verificationAudioURL: err.body.verificationAudioURL,
            refreshURL: err.body.refreshURL
          });
        }
        throw err;
      });
  }
}

