import {isEmpty} from 'lodash';

import StatsUtil from '../stats/util';
import Metrics from '../metrics';
import {eventType, trigger, mediaType} from '../metrics/config';
import Media from '../media';
import LoggerProxy from '../common/logs/logger-proxy';
import WebRTCStats from '../stats/index';
import {
  INTENT_TO_JOIN,
  _JOINED_,
  STATS,
  EVENT_TRIGGERS
} from '../constants';
import Trigger from '../common/events/trigger-proxy';
import IntentToJoinError from '../common/errors/intent-to-join';
import JoinMeetingError from '../common/errors/join-meeting';
import ParameterError from '../common/errors/parameter';
import PermissionError from '../common/errors/permission';

const MeetingUtil = {};

MeetingUtil.parseLocusJoin = (response) => {
  const parsed = {};

  // First todo: add check for existance
  parsed.locus = response.body.locus;
  parsed.mediaConnections = response.body.mediaConnections;
  parsed.locusUrl = parsed.locus.url;
  parsed.locusId = parsed.locus.url.split('/').pop();
  parsed.selfId = parsed.locus.self.id;

  // we need mediaId before making roap calls
  parsed.mediaConnections.forEach((mediaConnection) => {
    if (mediaConnection.mediaId) {
      parsed.mediaId = mediaConnection.mediaId;
    }
  });

  return parsed;
};

MeetingUtil.remoteUpdateAudioVideo = (audioMuted, videoMuted, meeting) => {
  if (!meeting) {
    return Promise.reject(new ParameterError('You need a meeting object.'));
  }
  const localMedias = Media.generateLocalMedias(meeting.mediaId, audioMuted, videoMuted);

  if (isEmpty(localMedias)) {
    return Promise.reject(new ParameterError('You need a media id on the meeting to change remote audio.'));
  }

  Metrics.postEvent({event: eventType.MEDIA_REQUEST, meeting});

  return meeting.meetingRequest.remoteAudioVideoToggle({
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    localMedias,
    deviceUrl: meeting.deviceUrl,
    correlationId: meeting.correlationId
  }).then((response) => {
    Metrics.postEvent({event: eventType.MEDIA_RESPONSE, meeting});
    meeting.locusInfo.onFullLocus(response.body.locus);
  });
};

MeetingUtil.checkShare = (meeting) => {
  if ((meeting.wirelessShare && meeting.isSharing) || meeting.isSharing) {
    return meeting.stopShare();
  }

  return Promise.resolve();
};

MeetingUtil.hasOwner = (info) => info && info.owner;

MeetingUtil.isOwnerSelf = (owner, selfId) => owner === selfId;

MeetingUtil.isPinOrGuest = (err) => {
  if (err && err.body && err.body.errorCode === INTENT_TO_JOIN) {
    return true;
  }

  return false;
};

MeetingUtil.joinMeeting = (meeting, options) => {
  if (!meeting) {
    return Promise.reject(new ParameterError('You need a meeting object.'));
  }

  Metrics.postEvent({event: eventType.LOCAL_JOIN_REQUEST, meeting});

  // eslint-disable-next-line no-warning-comments
  // TODO: check if the meeting is in JOINING state
  // if Joining state termintate the request as user might click multiple times
  return meeting.meetingRequest
    .joinMeeting({
      sipUri: meeting.sipUri,
      deviceUrl: meeting.deviceUrl,
      locusUrl: meeting.locusUrl,
      correlationId: meeting.id,
      roapMessage: options.roapMessage,
      resourceId: options.resourceId || null,
      moderator: options.moderator,
      pin: options.pin,
      moveToResource: options.moveToResource
    })
    .then((res) => {
      Metrics.postEvent({
        event: eventType.LOCUS_JOIN_RESPONSE,
        meeting,
        data: {
          trigger: trigger.LOCI_UPDATE,
          locus: res.body.locus,
          trackingId: res.headers.trackingid
        }
      });

      return MeetingUtil.parseLocusJoin(res);
    });
};

MeetingUtil.cleanUp = (meeting) => {
  // make sure we send last metrics before we close the peerconnection
  if (meeting.statsAnalyzer) meeting.statsAnalyzer.stopAnalyzer();

  return meeting.closeLocalStream()
    .then(() => meeting.closeLocalShare())
    .then(() => meeting.closeRemoteStream())
    .then(() => meeting.closePeerConnections())
    .then(() => {
      meeting.unsetLocalVideoTrack();
      meeting.unsetLocalShareTrack();
      meeting.unsetRemoteStream();
      meeting.unsetPeerConnections();
      meeting.cleanMQAInterval();
    })
    .then(() => meeting.roap.stop(meeting.correlationId, meeting.roapSeq));
};

// by default will leave on meeting's resourceId
// if you explicity want it not to leave on resource id, pass
// {resourceId: null}
// TODO: chris, you can modify this however you want
MeetingUtil.leaveMeeting = (meeting, options = {}) => {
  const defaultOptions = {
    locusUrl: meeting.locusUrl,
    selfId: meeting.selfId,
    correlationId: meeting.correlationId,
    resourceId: meeting.resourceId,
    deviceUrl: meeting.deviceUrl
  };

  const leaveOptions = {...defaultOptions, ...options};

  return meeting.meetingRequest
    .leaveMeeting(leaveOptions)
    .then((response) => {
      if (response && response.body && response.body.locus) { // && !options.moveMeeting) {
        meeting.locusInfo.onFullLocus(response.body.locus);
      }

      return Promise.resolve();
    })
    .then(() => {
      if (options.moveMeeting) {
        return Promise.resolve();
      }

      return MeetingUtil.cleanUp(meeting);
    })
    .catch((err) => {
      LoggerProxy.logger.error(
        `Meeting:util#leaveMeeting --> An error occured while trying to leave meeting with an id of ${
          meeting.id
        }, error: ${err}`
      );

      return Promise.reject(err);
    });
};
MeetingUtil.declineMeeting = (meeting, reason) =>
  meeting.meetingRequest.declineMeeting({
    locusUrl: meeting.locusUrl,
    deviceUrl: meeting.deviceUrl,
    reason
  });

MeetingUtil.isGuestUnjoined = (locusInfo) =>
  locusInfo.parsedLocus && locusInfo.parsedLocus.self && locusInfo.parsedLocus.self.guest && locusInfo.parsedLocus.self.state !== _JOINED_;

MeetingUtil.joinMeetingOptions = (meeting, options = {}) => {
  meeting.resourceId = meeting.resourceId || options.resourceId;
  meeting.setCorrelationId(meeting.id);

  if (options.pin) {
    Metrics.postEvent({
      event: eventType.PIN_COLLECTED,
      meeting
    });
  }

  // normal join meeting, scenario A, D
  return MeetingUtil.joinMeeting(meeting, options)
    .then((response) => {
      meeting.setLocus(response);

      return Promise.resolve(response);
    })
    .catch((err) => {
      // joining a claimed PMR that is not my own, scenario B
      if (MeetingUtil.isPinOrGuest(err)) {
        if (MeetingUtil.hasOwner(meeting.meetingInfo)) {
          return MeetingUtil.joinMeeting(meeting, options).then((response) => {
            meeting.setLocus(response);

            return Promise.resolve();
          });
        }

        Metrics.postEvent({
          event: eventType.PIN_PROMPT,
          meeting
        });

        // request host pin or non host for unclaimed PMR, start of Scenario C
        // see https://sqbu-github.cisco.com/WebExSquared/locus/wiki/Locus-Lobby-and--IVR-Feature
        return Promise.reject(new IntentToJoinError('Error Joining Meeting', err));
      }
      LoggerProxy.logger.error('Meeting:util#joinMeetingOptions --> Error joining the call, ', err);

      return Promise.reject(new JoinMeetingError(options, 'Error Joining Meeting', err));
    });
};

MeetingUtil.updateTransceiver = (options, meetingOptions) => {
  const {
    type,
    sendTrack,
    receiveTrack,
    track,
    transceiver,
    peerConnection,
    previousMediaDirection
  } = options;

  if ((sendTrack !== undefined && sendTrack !== previousMediaDirection.sendTrack) ||
  (receiveTrack !== undefined && receiveTrack !== previousMediaDirection.receiveTrack)) {
    return Media.updateTransceiver({
      meetingId: meetingOptions.meeting.id,
      remoteQualityLevel: meetingOptions.mediaProperties.remoteQualityLevel
    }, peerConnection, transceiver,
    {
      track,
      type,
      receiveTrack,
      sendTrack
    })
      .then(() => meetingOptions.meeting.roap
        .sendRoapMediaRequest({
          sdp: meetingOptions.mediaProperties.peerConnection.sdp,
          roapSeq: meetingOptions.roapSeq,
          meeting: meetingOptions.meeting // or can pass meeting ID
        }))
      .catch((e) => {
        LoggerProxy.logger.error(`Meeting:util#updateTransceiver --> Error updating the ${type} streams with error: ${e}`);
      });
  } if (track) {
    transceiver.sender.replaceTrack(track);

    return Promise.resolve();
  }

  return Promise.reject(new ParameterError('update Failed: please pass valid parameter'));
};

MeetingUtil.validateOptions = (options) => {
  const {
    sendVideo, sendAudio, sendShare, localStream, localShare
  } = options;

  if (sendVideo && !MeetingUtil.getTrack(localStream).videoTrack) {
    return Promise.reject(new ParameterError('please pass valid video streams'));
  }

  if (sendAudio && !MeetingUtil.getTrack(localStream).audioTrack) {
    return Promise.reject(new ParameterError('please pass valid audio streams'));
  }

  if (sendShare && !MeetingUtil.getTrack(localShare).videoTrack) {
    return Promise.reject(new ParameterError('please pass valid share streams'));
  }

  return Promise.resolve();
};

MeetingUtil.getTrack = (stream) => {
  let audioTrack = null;
  let videoTrack = null;
  let audioTracks = null;
  let videoTracks = null;

  if (!stream) {
    return {audioTrack: null, videoTrack: null};
  }
  if (stream.getAudioTracks) {
    audioTracks = stream.getAudioTracks();
  }
  if (stream.getVideoTracks) {
    videoTracks = stream.getVideoTracks();
  }

  if (audioTracks && audioTracks.length > 0) {
    [audioTrack] = audioTracks;
  }

  if (videoTracks && videoTracks.length > 0) {
    [videoTrack] = videoTracks;
  }

  return {audioTrack, videoTrack};
};

MeetingUtil.getModeratorFromLocusInfo = (locusInfo) =>
  locusInfo &&
  locusInfo.parsedLocus &&
  locusInfo.parsedLocus.info &&
  locusInfo.parsedLocus.info &&
  locusInfo.parsedLocus.info.moderator;

MeetingUtil.getPolicyFromLocusInfo = (locusInfo) =>
  locusInfo &&
  locusInfo.parsedLocus &&
  locusInfo.parsedLocus.info &&
  locusInfo.parsedLocus.info &&
  locusInfo.parsedLocus.info.policy;

MeetingUtil.canUserLock = (moderator, joined) => {
  if (moderator.LOCK_CONTROL_LOCK && joined.LOCK_STATUS_UNLOCKED) {
    return true;
  }

  return false;
};

MeetingUtil.canUserUnlock = (moderator, joined) => {
  if (moderator.LOCK_CONTROL_UNLOCK && joined.LOCK_STATUS_LOCKED) {
    return true;
  }

  return false;
};

MeetingUtil.canUserRecord = (moderator) => moderator.RECORDING_CONTROL_START;

MeetingUtil.canUserPause = (moderator) => moderator.RECORDING_CONTROL_PAUSE;

MeetingUtil.canUserResume = (moderator) => moderator.RECORDING_CONTROL_RESUME;

MeetingUtil.canUserStop = (moderator) => moderator.RECORDING_CONTROL_STOP;

MeetingUtil.startRecording = (request, locusUrl, locusInfo) => {
  const moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserRecord(moderator)) {
    return request.recordMeeting({locusUrl, recording: true, paused: false});
  }

  return Promise.reject(new PermissionError('Start recording not allowed, due to moderator property.'));
};

MeetingUtil.pauseRecording = (request, locusUrl, locusInfo) => {
  const moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserPause(moderator)) {
    return request.recordMeeting({locusUrl, recording: true, paused: true});
  }

  return Promise.reject(new PermissionError('Pause recording not allowed, due to moderator property.'));
};

MeetingUtil.resumeRecording = (request, locusUrl, locusInfo) => {
  const moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserResume(moderator)) {
    return request.recordMeeting({locusUrl, recording: true, paused: false});
  }

  return Promise.reject(new PermissionError('Resume recording not allowed, due to moderator property.'));
};

MeetingUtil.stopRecording = (request, locusUrl, locusInfo) => {
  const moderator = MeetingUtil.getModeratorFromLocusInfo(locusInfo);

  if (moderator && MeetingUtil.canUserStop(moderator)) {
    return request.recordMeeting({locusUrl, recording: false, paused: false});
  }

  return Promise.reject(new PermissionError('Stop recording not allowed, due to moderator property.'));
};

MeetingUtil.lockMeeting = (actions, request, locusUrl) => {
  if (actions && actions.canLock) {
    return request.lockMeeting({locusUrl, lock: true});
  }

  return Promise.reject(new PermissionError('Lock not allowed, due to joined property.'));
};

MeetingUtil.unlockMeeting = (actions, request, locusUrl) => {
  if (actions && actions.canUnlock) {
    return request.lockMeeting({locusUrl, lock: false});
  }

  return Promise.reject(new PermissionError('Unlock not allowed, due to joined property.'));
};

MeetingUtil.startInternalStats = (meeting) => {
  if (!meeting.internalStats) {
    const options = {
      useConfig: true,
      senders: [
        {
          id: 'mainAudio',
          correlate: 'audio',
          history: true,
          onEvent: (event) => {
            // TODO: we don't need checks like this since it comes from the transceiver
            // refactor event linkage to use callbacks instead of events
            if (event.kind === 'audio' && event.stat === 'bytesSent') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED,
                {
                  type: mediaType.AUDIO
                }
              );
              Metrics.postEvent({
                event: eventType.SENDING_MEDIA_START,
                meeting,
                data: {
                  mediaType: mediaType.AUDIO
                }
              });
            }
            else if (event.stop && event.stat === 'bytesSent') {
              Metrics.postEvent({
                event: eventType.SENDING_MEDIA_STOP,
                meeting,
                data: {
                  mediaType: mediaType.AUDIO
                }
              });
            }
          },
          onData: () => {}
        },
        {
          id: 'mainVideo',
          correlate: 'video',
          history: true,
          onEvent: (event) => {
            if (event.kind === 'video' && event.stat === 'bytesSent') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED,
                {
                  type: mediaType.VIDEO
                }
              );
              Metrics.postEvent({
                event: eventType.SENDING_MEDIA_START,
                meeting,
                data: {
                  mediaType: mediaType.VIDEO
                }
              });
            }
            else if (event.stop && event.stat === 'bytesSent') {
              Metrics.postEvent({
                event: eventType.SENDING_MEDIA_STOP,
                meeting,
                data: {
                  mediaType: mediaType.VIDEO
                }
              });
            }
          },
          onData: () => {}
        },
        {
          id: 'mainShare',
          correlate: 'video',
          onEvent: (event) => {
            if (event.kind === 'share' && event.stat === 'bytesSent') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_LOCAL_STARTED,
                {
                  type: mediaType.SHARE
                }
              );
              Metrics.postEvent({
                event: eventType.SENDING_SHARE_START,
                meeting,
                data: {
                  mediaType: mediaType.SHARE
                }
              });
            }
            else if (event.stop && event.stat === 'bytesSent') {
              Metrics.postEvent({
                event: eventType.SENDING_SHARE_STOP,
                meeting,
                data: {
                  mediaType: mediaType.SHARE
                }
              });
            }
          },
          onData: () => {}
        }
      ],
      receivers: [
        {
          id: 'mainAudio',
          correlate: 'audio',
          history: true,
          onEvent: (event) => {
            if (event.kind === 'audio' && event.stat === 'bytesReceived') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_REMOTE_STARTED,
                {
                  type: mediaType.AUDIO
                }
              );
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_START,
                meeting,
                data: {
                  mediaType: mediaType.AUDIO
                }
              });
            }
            else if (event.stop && event.stat === 'bytesReceived') {
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_STOP,
                meeting,
                data: {
                  mediaType: mediaType.AUDIO
                }
              });
            }
          },
          onData: () => {}
        },
        {
          id: 'mainVideo',
          correlate: 'video',
          history: true,
          onEvent: (event) => {
            if (event.kind === 'video' && event.stat === 'bytesReceived') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_REMOTE_STARTED,
                {
                  type: mediaType.VIDEO
                }
              );
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_START,
                meeting,
                data: {
                  mediaType: mediaType.VIDEO
                }
              });
            }
            else if (event.stop && event.stat === 'bytesReceived') {
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_STOP,
                meeting,
                data: {
                  mediaType: mediaType.VIDEO
                }
              });
            }
          },
          onData: () => {}
        },
        {
          id: 'mainShare',
          correlate: 'video',
          onEvent: (event) => {
            if (event.kind === 'share' && event.stat === 'bytesReceived') {
              Trigger.trigger(
                meeting,
                {
                  file: 'meeting/util',
                  function: 'startInternalStats'
                },
                EVENT_TRIGGERS.MEETING_MEDIA_REMOTE_STARTED,
                {
                  type: mediaType.SHARE
                }
              );
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_START,
                meeting,
                data: {
                  mediaType: mediaType.SHARE
                }
              });
            }
            else if (event.stop && event.stat === 'bytesReceived') {
              Metrics.postEvent({
                event: eventType.RECEIVING_MEDIA_STOP,
                meeting,
                data: {
                  mediaType: mediaType.SHARE
                }
              });
            }
          },
          onData: () => {}
        }
      ]
    };

    StatsUtil.generateOptions(options, STATS.CONFIG, meeting);

    options.config = STATS.CONFIG;

    // pass the attrs and options for the webex instance
    meeting.internalStats = new WebRTCStats(meeting.attrs, meeting.options, options);
  }

  return meeting.internalStats;
};

export default MeetingUtil;
