/* eslint require-jsdoc:0 */
/* globals window */
import uuid from 'uuid';

import PeerConnectionManager from './../PeerConnectionManager';
import RoapInterface from './../roap/roap-interface.js';
import RoapAdapter from './../roap/roap-adapter.js';
import request from './request.js';
import Media from './../media';
// import PeerConnectionManager from './PeerConnectionManager';

/**
  * Events to emit
  * ==============
  * - leave
  * - join
  * - end
  * - meeting.metrics {
  *   - media
  *   - MQE
  *   - callAnalyzer
  *   - meetingEndMetrics?
  * }
  * - statusChange {
  *   - status, e.g., leaving, left, reason
  * }
  * - typeChange {
  *   - type
      - reason
  * }
  *
  * @export
  * @class Meeting
  */
export default class Meeting {
  // /**
  //  * Create an instance of Meeting
  //  *
  //  * @param {string} options.id
  //  * @param {string} options.spaceID
  //  * @param {array} options.members
  //  * @param {object} options.peerConnections
  //  * @param {object} options.health
  //  * @param {string} options.type
  //  * @param {string} options.direction
  //  * @param {object} options.pairedDevice
  //  * @param {ISOString} options.startTime
  //  * @param {ISOString} options.endTime
  //  * @memberof Meeting
  //  */
  constructor(
    options
  ) {
    this.id = uuid.v4();
    this.spark = options.spark;
    this.meetingInfo = options.meetingInfo;
    // THe passed in destination can have many ways of calling
    // sipUrl , convo Id etc we want to refer the meeting with same Ids
    // TODO: check for the destination and convert it into a sip uri if possible
    this.updateMeetingInfo(this.meetingInfo);
    this.sipUri = this.sipUri || options.destination;
    this.userId = this.spark.internal.device.userId;
    this.deviceUrl = this.spark.internal.device.url;
    this.resource = options.resourceId; // Can be a object, resource or self object
    this.roapSeq = 0;
    this.videoMuted = false;
    this.audioMuted = false;
    this.media = new Media();

    // TODO: for some reason the actual join function was not exposed outside
    this.joinMeeting = this.join;
    // this.peerConnectionManager = new PeerConnectionManager(config);
    // this.roapInterface = new RoapInterface();
    // this.stateMachine = new stateMachine(); //constants

    // this.memebers = members;
    // this.peerConnections = peerConnections;
    // this.health = health;
    // this.type = type;
    // this.direction = direction;
    // this.pairedDevice = pairedDevice;
    // this.startTime = startTime || new Date().toISOString();
    // this.endTime = endTime || new Date().toISOString();
  }

  updateMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo) {
      this.convoId = this.meetingInfo.convoId;
      this.locusUrl = this.meetingInfo.locusUrl;
      this.sipUri = this.meetingInfo.sipMeetingUri;
    }
  }

  _joinMeeting() {
    // TODO: check if the meeting is in JOINING state
    // if JOining state termintate the request as user might click multiple times
    this.correlationId = this.id;
    return request.joinMeeting({
      sipUri: this.sipUri,
      deviceUrl: this.deviceUrl,
      locusUrl: this.locusUrl,
      correlationId: this.id
    }).then((res) => {
      window.meetings.put(this, this.id);
      // TODO: was thinking to have one function for parsing
      // all updates will give a locus object and we just need to
      // update the existing locus object and send events to the UI
      this._parseLocus(res);
    }).catch((e) => {
      console.log('ERROR JOINING CALL', e);
    });
  }

  _parseLocus(res) {
    // First todo: add check for existance
    this.locus = res.body.locus;
    this.mediaConnections = res.body.mediaConnections;
    this.locusUrl = this.locus.url;
    const temp = this.locus.url.split('/');
    this.locusId = temp.pop();
    this.selfId = this.locus.self.id;

    // we need mediaId before making roap calls
    this.mediaConnections.forEach((mediaConnection) => {
      if (mediaConnection.mediaId) {
        this.mediaId = mediaConnection.mediaId;
      }
    });
  }

  updateRoapSeq(seq) {
    this.roapSeq = seq;
  }


  _addMedia(audioVideo, screen) {
    const promise = [];
    this.mediaDirection = {
      receiveAudio: true,
      receiveVideo: true
    };
    if (this.mediaDirection.receiveVideo || this.mediaDirection.receiveAudio) {
      promise.push(PeerConnectionManager.createOffer({
        receiveAudio: this.mediaDirection.receiveAudio,
        receiveVideo: this.mediaDirection.receiveVideo,
        // After you get the localStream
        audioVideo
      }));

      promise.push(PeerConnectionManager.createOffer({
        // its for screen sharing but can change in future when user wants just share with audio
        receiveAudio: false,
        receiveVideo: this.mediaDirection.receiveVideo,
        // After you get the localStream
        streams: screen
      }));
    }
    return Promise.all(promise);
  }


  getLocalMedia(options) {
    const {sendAudio, sendVideo, sendShare} = options;
    const promise = [];
    const getScreen = this.media.getScreenShare(sendShare)
      .then((screenConstraints) => this.media.getMedia(false, screenConstraints))

    promise.push(this.media.getMedia(sendAudio, sendVideo));
    promise.push(getScreen);

    return Promise.all(promise);
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @exports
   * @param {object} [options={ PairedDevice, Password }]
   * @returns {Promise}
   * @memberof Meeting
   */
  join(options) {
    // let {mediaDirection} = options;
    const mediaDirection = {
      sendAudio: true,
      sendVideo: false,
      receiveAudio: true,
      receiveVideo: false,
      pstn: false,
      sendShare: true,
      receiveShare: true
    };
    const self = this;
    return this._joinMeeting()
      // .then(() => this.getLocalMedia({
      //   sendAudio: mediaDirection.sendAudio,
      //   sendVideo: mediaDirection.sendVideo,
      //   sendShare: mediaDirection.sendShare
      // }))
      // .then(([audioVideo, screen]) => this._addMedia(audioVideo, screen)
      .then(this.media.getMedia(true, true))
      .then((streams) => this._addMedia(streams))
      .then(([mediaPc, screenPc]) => {
        // hook up callback on pc
        this.peerConnection = mediaPc;
        this.screenPc = screenPc;
        this.screenPc.sdp += 'a=content:slides\r\n';
        // receiving remote streams
        this.peerConnection.ontrack = (event) => {
          self.mediaStream = event.streams[0];
          document.getElementById('remotevideo').srcObject = self.mediaStream;
        };
        // add meeting screen streams

        this.screenPc.ontrack = (event) => {
          self.screenStream = event.streams[0];
          document.getElementById('screenvideo').srcObject = self.screenStream;
        };
        RoapAdapter.initialize();
        return RoapInterface.sendRoapMediaRequest({
          sdps: [mediaPc.sdp, screenPc.sdp],
          roapSeq: this.roapSeq,
          meeting: this // or can pass meeting ID
        })
          .then(() => {

          });
      });
  //   this.connectMedia()
  //   // TODO: pass the array or tracks or streams in future
  //   this.streams = options.streams;
  //   this.mediaDirection = {
  //     sendAudio: true,
  //     sendVideo: true,
  //     receiveAudio: true,
  //     receiveVideo: true,
  //     pstn: false,
  //     share: true
  //   };


  //   this.updateMeetingStatus();
  //   // sdps will always be an object irrespective of how many peerconnection
  //   // sdps = {audioVideo: sdp, screen: sdp}
  //   // this.peerConnectionManager.create(config).then((sdps = {}) => {
  //   //   meeting.roapInterface.join();
  //   //   meeting.roapInterface.startMedia();
  //   // })

  //   return new Promise((resolve) => resolve(options));
  }

  /**
   *
   * Move this meeting to a given device
   * only possible if you are paired with the given device
   * @param {string} deviceID
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToDevice(deviceID) {
    return new Promise((resolve) => resolve(deviceID));
  }

  /**
   *
   * Move this meeting back to the current client device, e.g., personal laptop.
   * @returns {Promise}
   * @memberof Meeting
   */
  moveToClient() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Update the audio options of this meeting
   * @param {object} [options]
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateAudio(options = {}, status) {
    return new Promise((resolve) => resolve(options, status));
  }

  /**
   *
   * Update the video option of this meeting
   * @param {string} status
   * @returns {Promise}
   * @memberof Meeting
   */
  updateVideo(status) {
    return new Promise((resolve) => resolve(status));
  }

  /**
   *
   * Update screen sharing preference of this meeting
   * @param {string} shareType
   * @returns {Promise}
   * @memberof Meeting
   */
  updateShare(shareType) {
    return new Promise((resolve) => resolve(shareType));
  }

  /**
   *
   * Alias of updateShare
   * @param {*} args
   * @returns {updateShare}
   * @memberof Meeting
   */
  share(...args) {
    this.updateShare(args);
  }

  /**
   *
   * Leave the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  leave() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Decline this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  decline() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Send this meeting to the phone system
   * @returns {Promise}
   * @memberof Meeting
   */
  sendDtmf() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Get statistics of the current meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  getStats() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Lock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  lock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Unlock this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  unlock() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * Intiate a recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  startRecording() {
    return new Promise((resolve) => resolve({}));
  }

  /**
   *
   * End the recording of this meeting
   * @returns {Promise}
   * @memberof Meeting
   */
  stopRecording() {
    return new Promise((resolve) => resolve({}));
  }
}
