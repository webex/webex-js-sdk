import uuid from 'uuid';
import {StatelessWebexPlugin} from '@webex/webex-core';

import LoggerProxy from '../common/logs/logger-proxy';
import Trigger from '../common/events/trigger-proxy';
import Roap from '../roap/index';
import Media from '../media';
import MediaProperties from '../media/properties';
import MeetingStateMachine from '../meeting/state';
import AudioStateMachine from '../meeting/audio';
import VideoStateMachine from '../meeting/video';
import LocusInfo from '../locus-info';
import PeerConnectionManager from '../peer-connection-manager';
import ReconnectionManager from '../reconnection-manager';
import MeetingRequest from '../meeting/request';
import Members from '../members/index';
import MeetingUtil from '../meeting/util';
import MediaUtil from '../media/util';
import WebRTCStats from '../stats/index';
import StatsUtil from '../stats/util';
import ReconnectionError from '../common/errors/reconnection';
import {
  MEETINGS,
  EVENT_TRIGGERS,
  EVENT_TYPES,
  EVENTS,
  FLOOR_ACTION,
  _BUSY_,
  _INCOMING_,
  ONLINE,
  _CALL_,
  CONTENT,
  ROAP_SEQ_PRE,
  LOCUSINFO,
  MEETING_STATE_MACHINE,
  _JOIN_,
  STATS
} from '../constants';

/**
  * Media Ready Event
  * Emitted when a stream is ready to be rendered
  * @event media:ready
  * @instance
  * @type {Object}
  * @property {MediaStream} stream the media stream
  * @property {String} type what type of stream, remote, local
  * @memberof Meetings
  */

/**
  * Media Stopped Event
  * Emitted when a stream has stopped sending
  * @event media:stopped
  * @instance
  * @type {Object}
  * @property {String} type what type of stream, remote, local
  * @memberof Meetings
  */

/**
  * Reconnection Success Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionSuccess
  * @instance
  * @type {Object}
  * @property {Object} reconnect
  * @memberof Meetings
  */

/**
  * Reconnection Failure Event
  * Emitted when reconnection of media to the active meeting was successful
  * @event meeting:reconnectionFailure
  * @instance
  * @type {Object}
  * @property {Error} error
  * @memberof Meetings
  */

/**
  * Ringing Event
  * Emitted when a ring should occur or stop, outgoing or incoming
  * @event meeting:reconnectionFailure
  * @instance
  * @type {Object}
  * @property {String} type indicating if it's out or in
  * @property {Boolean} ringing if it should ring or not
  * @memberof Meetings
  */

/**
 * @class Meeting
 */
export default class Meeting extends StatelessWebexPlugin {
  namespace = MEETINGS;

  /**
   * Create an instance of Meeting
   *
   * @param {Object} attrs
   * @param {Object} options
   * @constructor
   * @memberof Meeting
   */
  constructor(attrs, options) {
    super({}, options);

    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    this.attrs = attrs;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @private
     * @memberof Meeting
     */
    this.options = options;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.id = uuid.v4();

    this.correlationId = this.id;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.userId = attrs.userId;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.resource = attrs.resource;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.deviceUrl = attrs.deviceUrl;
    /**
     * @description set you -1 as default values is 0 (used to idenfify if 1st roap request was sent)
     * @instance
     * @type {Number}
     * @readonly
     * @private
     * @memberof Meeting
     */
    this.roapSeq = ROAP_SEQ_PRE;
    /**
     * @instance
     * @type {Object}
     * @readonly
     * @public
     * @todo needs to be defined as a class
     * @memberof Meeting
     */
    this.meetingInfo = {};
    /**
     * @instance
     * @type {Members}
     * @public
     * @memberof Meeting
     */
    this.members = new Members({}, {parent: this.webex});
    /**
     * @instance
     * @type {Roap}
     * @readonly
     * @private
     * @memberof Meeting
     */
    this.roap = new Roap({}, {parent: this.webex});
    /**
     * created later
     * @instance
     * @type {ReconnectionManager}
     * @readonly
     * @private
     * @memberof Meeting
     */
    this.reconnectionManager = new ReconnectionManager(this);
    /**
     * created later
     * @instance
     * @type {AudioStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.audio = null;
    /**
     * created later
     * @instance
     * @type {VideoStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.video = null;
    /**
     * @instance
     * @type {MeetingStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.meetingFSM = MeetingStateMachine.create(this);
    /**
     * @instance
     * @type {MeetingStateMachine}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.stats = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.convoId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.locusUrl = (attrs.locus && attrs.locus.url) || null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.sipUri = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.partner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.type = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.owner = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.hostId = null;
    /**
     * @instance
     * @type {String}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.policy = null;
    /**
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    this.meetingRequest = new MeetingRequest({}, options);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MeetingRequest}
     * @private
     * @memberof Meeting
     */
    this.locusInfo = new LocusInfo(this.updateMeetingObject.bind(this), attrs.locus ? attrs.locus : {}, this.webex);
    /**
     * Passing only info as we send basic info for meeting added event
     * @instance
     * @type {MediaProperties}
     * @public
     * @memberof Meeting
     */
    this.mediaProperties = new MediaProperties();
    /**
     * @instance
     * @type {Boolean}
     * @readonly
     * @public
     * @memberof Meeting
     */
    this.isSharing = false;
    this.setUpLocusInfoListeners();
  }

  /**
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setUpLocusInfoListeners() {
    // meeting update listeners
    this.setUpLocusInfoSelfListener();
    this.setUpLocusInfoMeetingListener();
    // members update listeners
    this.setUpLocusUrlListener();
    this.setUpLocusHostListener();
    this.setUpLocusSelfListener();
    this.setUpLocusParticipantsListener();
    this.setUpLocusMediaSharesListener();
  }

  /**
   * set up the locus info self listener
   * update self value for members and updates the member
   * notifies consumer with members:self:update {activeSelfId endedSelfId}
   * @returns {undefined}
   * @event {members:self:update}
   * @memberof Members
   */
  setUpLocusSelfListener() {
    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_SELF, (payload) => {
      this.members.locusSelfUpdate(payload);
    });
  }

  /**
   * set up the locus info host listener
   * update host value for members and updates the member
   * notifies consumer with members:host:update: {activeHostId, endedHostId}
   * @returns {undefined}
   * @event {members:host:update}
   * @memberof Members
   */
  setUpLocusHostListener() {
    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_HOST, (payload) => {
      this.members.locusHostUpdate(payload);
    });
  }

  /**
   * set up the locus info participants update listener
   * update members collection value for members
   * notifies consumer with members:update
   * @returns {undefined}
   * @event {members:update}
   * @memberof Members
   */
  setUpLocusParticipantsListener() {
    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS, (payload) => {
      this.members.locusParticipantsUpdate(payload);
    });
  }

  /**
   * set up the locus info media shares listener
   * update content sharing id value for members, and updates the member
   * notifies consumer with members:content:update {activeContentSharingId, endedContentSharingId}
   * @returns {undefined}
   * @event {members:content:update}
   * @memberof Members
   */
  setUpLocusMediaSharesListener() {
    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_MEDIA_SHARES, (payload) => {
      this.members.locusMediaSharesUpdate(payload);
    });
  }

  /**
   * set up the locus info self listener
   * update locus_url value for members
   * @returns {undefined}
   * @memberof Members
   */
  setUpLocusUrlListener() {
    this.locusInfo.on(EVENTS.LOCUS_INFO_UPDATE_URL, (payload) => {
      this.members.locusUrlUpdate(payload);
    });
  }

  /**
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setUpLocusInfoSelfListener() {
    this.locusInfo.on(LOCUSINFO.EVENTS.SELF_UNADMITTED_GUEST, (payload) => {
      if (payload) {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          },
          EVENT_TRIGGERS.MEETING_SELF_LOBBY_WAITING,
          {
            payload
          }
        );
      }
    });
    this.locusInfo.on(LOCUSINFO.EVENTS.SELF_ADMITTED_GUEST, (payload) => {
      if (payload) {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'setUpLocusInfoSelfListener'
          },
          EVENT_TRIGGERS.MEETING_SELF_GUEST_ADMITTED,
          {
            payload
          }
        );
      }
    });
  }

  /**
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setUpLocusInfoMeetingListener() {
    this.locusInfo.on(EVENTS.REMOTE_ANSWERED_DECLINED, (payload) => {
      this.meetingFSM.remote(payload);
    });
    this.locusInfo.on(EVENTS.DESTROY_MEETING, (payload) => {
      // if self state is NOT left

      // TODO: Handle sharing and wireless sharing when meeting end
      if (this.wirelessShare) {
        if (this.mediaProperties.shareTrack) {
          this.mediaProperties.shareTrack.onended = null;
          this.mediaProperties.shareTrack.stop();
        }
      }
      // when multiple WEB deviceType join with same user
      // and some of the devices are joined and some are left
      // when your own device is still connected you want to leave and destroy
      // else you want to just destroy
      // this looks odd because when it leaves it should destroy, but we get a
      // leave response and we should destroy it on the next event loop
      // the leave response gets parsed and we decide if we want to destroy the meeting
      // the first time we just leave it, the second time it comes it destroys it from the collection
      if (payload.shouldLeave) {
        this.leave().then(() => {
          LoggerProxy.logger.warn('meeting/index->setUpLocusInfoMeetingListener:DESTROY_MEETING#The meeting has been left, but has not been destroyed, you should see a later event for leave.');
        }).catch((error) => {
          LoggerProxy.logger.error(`meeting/index->setUpLocusInfoMeetingListener:DESTROY_MEETING#Issue with leave for meeting, meeting still in collection: ${this.meeting}, error: ${error}`);
        });
      }
      else {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'setUpLocusInfoMeetingListener'
          },
          EVENTS.DESTROY_MEETING,
          {
            response: payload,
            meetingId: this.id
          }
        );
      }
    });
  }

  /**
   * @param {Object} object
   * @returns {undefined}
   * @private
   * @memberof Meeting
   * // TODO: is this function necessary?
   */
  updateMeetingObject(object) {
    // Validate if these are valid meeting object property
    // TODO: add a check to make sure the value passed in the constructor
    // is not changed by any delta event
    LoggerProxy.logger.log(`Meeting:index->updateMeeting#Meeting updated with ${JSON.stringify(object)}`);
    if (object && Object.keys(object).length) {
      Object.keys(object).forEach((key) => {
        this[key] = object[key];
      });
    }
  }

  /**
   * invite a guest to the call that isn't normally part of this call
   * @param {Object} invitee
   * @param {String} invitee.emailAddress
   * @param {String} invitee.email
   * @param {Boolean} alertIfActive optional
   * @returns {Promise} see #members.addMember
   * @public
   * @memberof Meeting
   */
  invite(invitee, alertIfActive = true) {
    return this.members.addMember(invitee, alertIfActive);
  }

  /**
   * admit the guest(s) to the call once they are waiting
   * @param {Array} memberIds
   * @returns {Promise} see #members.admitMembers
   * @public
   * @memberof Meeting
   */
  admit(memberIds) {
    return this.members.admitMembers(memberIds);
  }

  /**
   * Reference to the Members object
   * @returns {Members}
   * @public
   * @memberof Meeting
   */
  getMembers() {
    return this.members;
  }

  /**
   * Reference to the stats builder object
   * @param {Object} options - see #createStats
   * @param {Boolean} override - override the previous getStats
   * @returns {WebRTCStats}
   * @public
   * @memberof Meeting
   */
  getStats(options, override) {
    if (!this.stats) {
      return this.createStats(options);
    }
    if (override) {
      if (this.stats) {
        LoggerProxy.logger.log('Meeting:index#getStats --> Overriding the previous stats object without destroying first can result in memory leaks.');
      }

      return this.createStats(options);
    }

    return this.stats;
  }

  /**
   * write the stats builder object and assign to meeting property
   * @param {Object} options
   * @returns {WebRTCStats}
   * @public
   * @memberof Meeting
   */
  createStats(options = {}) {
    StatsUtil.generateOptions(options, STATS.CONFIG, this);

    options.config = STATS.CONFIG;

    this.stats = new WebRTCStats(this.attrs, this.options, options);

    return this.stats;
  }

  stopStats() {
    this.stats.destroySenders();
    this.stats.destroyReceivers();
    this.stats = null;
  }

  /**
   * Convenience function to tell whether a meeting is muted
   * @returns {Boolean} if meeting audio muted or not
   * @public
   * @memberof Meeting
   */
  isAudioMuted() {
    return this.audio && this.audio.isMuted();
  }

  /**
   * Convenience function to tell if the end user last changed the audio state
   * @returns {Boolean} if audio was manipulated by the end user
   * @public
   * @memberof Meeting
   */
  isAudioSelf() {
    return this.audio && this.audio.isSelf();
  }

  /**
   * Convenience function to tell whether video is muted
   * @returns {Boolean} if meeting video is muted or not
   * @public
   * @memberof Meeting
   */
  isVideoMuted() {
    return this.video && this.video.isMuted();
  }

  /**
   * Convenience function to tell whether the end user changed the video state
   * @returns {Boolean} if meeting video is muted or not
   * @public
   * @memberof Meeting
   */
  isVideoSelf() {
    return this.video && this.video.isSelf();
  }

  /**
   * Sets the meeting info on the class instance
   * @param {Object} meetingInfo
   * @param {String} meetingInfo.convoId
   * @param {String} meetingInfo.locusUrl
   * @param {String} meetingInfo.sipUri
   * @param {Object} meetingInfo.owner
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  parseMeetingInfo(meetingInfo) {
    // MeetingInfo will be undefined for 1:1 calls
    if (meetingInfo && meetingInfo.body && !(meetingInfo.errors && meetingInfo.errors.length > 0)) {
      this.convoId = meetingInfo.body.convoId || this.convoId;
      this.locusUrl = meetingInfo.body.locusUrl || this.locusUrl;
      this.setSipUri(meetingInfo.body.sipMeetingUri || this.sipUri);
      this.owner = meetingInfo.body.owner || this.owner;
    }
  }

  /**
   * Sets the first locus info on the class instance
   * @param {Object} locus
   * @param {String} locus.url
   * @param {Array} locus.participants
   * @param {Object} locus.self
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  parseLocus(locus) {
    if (locus) {
      this.locusUrl = locus.url;
      // TODO: move this to parse participants module
      this.setLocus(locus);

      // check if we can extract this info from partner
      // Parsing of locus object must be finished at this state
      if (locus.participants && locus.self) {
        this.partner = MeetingUtil.getLocusPartner(locus.participants, locus.self);
      }

      // For webex meeting the sipUrl gets updated in info parser
      if (!this.sipUri && this.partner && this.type === _CALL_) {
        this.setSipUri(this.partner.person.sipUrl || this.partner.person.emailAddress || this.partner.person.email);
      }
    }
  }

  /**
   * Sets the sip uri on the class instance
   * uses meeting info as precedence
   * @param {String} sipUri
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setSipUri(sipUri) {
    // This can be tel no, device id or a sip uri, user Id
    this.sipUri = sipUri;
  }

  /**
   * Set the roap seq on the class instance
   * @param {Number} seq
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setRoapSeq(seq) {
    if (seq >= 0) {
      this.roapSeq = seq;
    }
  }

  /**
   * Set the locus info the class instance
   * @param {Object} locus
   * @param {Array} locus.mediaConnections
   * @param {String} locus.locusUrl
   * @param {String} locus.locusId
   * @param {String} locus.mediaId
   * @param {Object} locus.host
   * @todo change name to genertic parser
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setLocus(locus) {
    const mtgLocus = locus.locus || locus;

    // LocusInfo object saves the locus object
    // this.locus = mtgLocus;
    this.mediaConnections = locus.mediaConnections;
    this.locusUrl = locus.locusUrl || locus.url;
    this.locusId = locus.locusId;
    this.selfId = locus.selfId;
    this.mediaId = locus.mediaId;
    this.hostId = mtgLocus.host ? mtgLocus.host.id : this.hostId;
    this.locusInfo.initialSetup(mtgLocus);
  }

  /**
   * Sets the remote stream on the class instance and emits and
   * event to developers
   * @param {Object} pc The remote stream peer connection
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  setRemoteStream(pc) {
    if (!pc) {
      return;
    }
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      // eslint-disable-next-line no-warning-comments
      // TODO: It's possible for media to not be present
      // so we might need to either
      // A) wait until we have media flowing
      // B) trigger a second event when video is flowing
      LoggerProxy.logger.log(`Meeting:index->setRemoteStream/ontrack#Event received for peerConnection: ${event}`);
      // const {transceiver} = event;
      const streams = event.streams[0];

      this.mediaProperties.remoteStream = streams;

      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setRemoteStream:pc.ontrack'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.REMOTE_AUDIO,
          stream: MediaUtil.createMediaStream([this.mediaProperties.remoteStream.getAudioTracks()[0]])
        }
      );

      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setRemoteStream:pc.ontrack'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.REMOTE_VIDEO,
          stream: MediaUtil.createMediaStream([this.mediaProperties.remoteStream.getVideoTracks()[0]])
        }
      );

      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setRemoteStream:pc.ontrack'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.REMOTE_SHARE,
          stream: MediaUtil.createMediaStream([this.mediaProperties.remoteStream.getVideoTracks()[1]])
        }
      );
    };
  }

  /**
   * Removes the remote stream on the class instance and triggers an event
   * to developers
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  unsetRemoteStream() {
    this.mediaProperties.unsetRemoteStream();
  }

  /**
   * Removes the remote stream on the class instance and triggers an event
   * to developers
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  closeRemoteStream() {
    return Media.stopStream(this.mediaProperties.remoteStream).then(() => {
      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'closeRemoteStream'
        },
        EVENT_TRIGGERS.MEDIA_STOPPED,
        {
          type: EVENT_TYPES.REMOTE
        }
      );
    });
  }

  /**
   * Sets the sceen stream on the class instance and triggers and event to developers
   * @param {Object} pc a peer connection instance for the screen
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  setShareStream(pc) {
    if (!pc) {
      return;
    }
    // eslint-disable-next-line no-param-reassign
    pc.ontrack = (event) => {
      [this.mediaProperties.remoteShare] = event.streams;
      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setShareStream:pc.ontrack'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.REMOTE_SHARE,
          stream: this.mediaProperties.remoteShare
        }
      );
    };
  }

  /**
   * Sets the local media stream on the class and emits an event to the developer
   * @param {Stream} localStream the local media stream
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  setLocalTracks(localStream) {
    if (localStream) {
      this.mediaProperties.setLocalAudioTrack(MeetingUtil.getTrack(localStream).audioTrack);
      this.mediaProperties.setLocalVideoTrack(MeetingUtil.getTrack(localStream).videoTrack);
      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setLocalTracks'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.LOCAL,
          stream: localStream
        }
      );
    }
  }

  /**
   * Sets the local media stream on the class and emits an event to the developer
   * @param {Stream} localShare the local media stream
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  setLocalShareTrack(localShare) {
    if (localShare) {
      this.mediaProperties.setLocalShareTrack(MeetingUtil.getTrack(localShare).videoTrack);
      const contentTracks = this.mediaProperties.shareTrack;


      contentTracks.onended = () => {
        if (this.wirelessShare) {
          this.leave();
        }
        else {
          this.stopShare();
        }
      };

      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'setLocalShareTrack'
        },
        EVENT_TRIGGERS.MEDIA_READY,
        {
          type: EVENT_TYPES.LOCAL_SHARE,
          stream: localShare
        }
      );
    }
  }

  /**
   * Closes the local stream from the class and emits an event to the developer
   * @returns {undefined}
   * @event media:stopped
   * @public
   * @memberof Meeting
   */
  closeLocalStream() {
    return Media.stopTracks(this.mediaProperties.audioTrack)
      .then(() => Media.stopTracks(this.mediaProperties.videoTrack))
      .then(() => {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'closeLocalStream'
          },
          EVENT_TRIGGERS.MEDIA_STOPPED, {
            type: EVENT_TYPES.LOCAL
          }
        );
      });
  }

  /**
   * Closes the local stream from the class and emits an event to the developer
   * @returns {undefined}
   * @event media:stopped
   * @public
   * @memberof Meeting
   */
  closeLocalShare() {
    return Media.stopTracks(this.mediaProperties.shareTrack).then(() => {
      Trigger.trigger(
        this,
        {
          file: 'meeting/index',
          function: 'closeLocalShare'
        },
        EVENT_TRIGGERS.MEDIA_STOPPED, {
          type: EVENT_TYPES.LOCAL_SHARE
        }
      );
    });
  }

  /**
   * Removes the local stream from the class and emits an event to the developer
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  unsetLocalVideoTrack() {
    this.mediaProperties.unsetLocalVideoTrack();
  }

  /**
   * Removes the local share from the class and emits an event to the developer
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  unsetLocalShareTrack() {
    this.mediaProperties.unsetLocalShareTrack();
  }

  /**
   * Sets the peer connections on the class
   * sets up reconnection logic
   * @returns {undefined}
   * @public
   * @memberof Meeting
   * @todo remove
   * // TODO: remove??
   */
  setPeerConnections() {
    // TODO: need to test more with the triggers for reconnect, we also need to add triggers based on getStats reports
    if (this.config.reconnection.detection) {
      // Client will have a socket manager and handle reconnecting to mercury, when we reconnect to mercury
      // if the meeting has active peer connections, it should try to reconnect.
      this.webex.internal.mercury.on(ONLINE, () => {
        this.reconnect();
      });
    }
  }

  /**
   * Close the peer connections and remove them from the class. Triggers an event
   * when each is closed.
   * @returns {Promise} returns a resolved promise with an array of closed peer connections
   * @public
   * @memberof Meeting
   */
  closePeerConnections() {
    return PeerConnectionManager.close(this.mediaProperties.peerConnection);
  }

  /**
   * Unsets the peer connections on the class
   * warning DO NOT CALL WITHOUT CLOSING PEER CONNECTIONS FIRST
   * @param {PeerConnection} peerConnection
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  unsetPeerConnections() {
    this.mediaProperties.unsetPeerConnection();
    if (this.config.reconnection.detection) {
      this.webex.internal.mercury.off(ONLINE);
    }
  }

  /**
   * Convenience method to set the correlation id for the Meeting
   * @param {String} id correlation id to set on the class
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  setCorrelationId(id) {
    this.correlationId = id;
  }

  /**
   * Mute the audio for a meeting
   * @returns {Promise} resolves the data from muting audio {mute, self} or rejects if there is no audio set
   * @public
   * @memberof Meeting
   */
  muteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }

    return this.audio.toggle({
      mute: true,
      self: true
    });
  }

  /**
   * Unmute meeting audio
   * @returns {Promise} resolves data from muting audio {mute, self} or rejects if there is no audio set
   * @public
   * @memberof Meeting
   */
  unmuteAudio() {
    if (!this.audio || (this.audio && !this.audio.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }

    return this.audio.toggle({
      mute: false,
      self: true
    });
  }

  /**
   * Mute the video for a meeting
   * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
   * @public
   * @memberof Meeting
   */
  muteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no video control associated to the meeting'));
    }

    return this.video.toggle({
      mute: true,
      self: true
    });
  }

  /**
   * Unmute meeting video
   * @returns {Promise} resolves data from muting video {mute, self} or rejects if there is no video set
   * @public
   * @memberof Meeting
   */
  unmuteVideo() {
    if (!this.video || (this.video && !this.video.toggle)) {
      return Promise.reject(new Error('no audio control associated to the meeting'));
    }
    const options = {};

    options.mute = false;
    options.self = true;

    return this.video.toggle({
      mute: false,
      self: true
    });
  }

  /**
   * @param {Object} joinOptions - see #join()
   * @param {Object} mediaOptions - see #addMedia()
   * @param {Object} streamsOptions - see #getMediaStreams()
   * @param {Object} audioVideoOptions - see #getMediaStreams()
   * @returns {Promise} -- {join: see join(), media: see addMedia(), local: see getMediaStreams()}
   * @public
   * @memberof Meeting
   */
  joinWithMedia(joinOptions, mediaOptions, streamsOptions, audioVideoOptions) {
    this.join(joinOptions)
      .then((joinResponse) =>
        this.getMediaStreams(streamsOptions, audioVideoOptions).then(([localStream, localShare]) =>
          this.addMedia({
            mediaSettings: mediaOptions,
            localShare,
            localStream
          }).then((mediaResponse) => {
            Promise.resolve({
              join: joinResponse,
              media: mediaResponse,
              local: [localStream, localShare]
            });
          })))
      .catch((error) => Promise.reject(error));
  }

  /**
   * initiates the reconnection of the media in the meeting
   * @returns {Promise} resolves with {reconnect} or errors with {error}
   * @public
   * @memberof Meeting
   */
  reconnect() {
    if (!this.reconnectionManager || !this.reconnectionManager.reconnect) {
      throw new Error('Cannot reconnect, ReconnectionManager must first be defined.');
    }

    return this.reconnectionManager
      .reconnect(this)
      .then((reconnect) => {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'reconnect'
          },
          EVENT_TRIGGERS.MEETING_RECONNECTION_SUCCESS,
          {
            reconnect
          }
        );

        return Promise.resolve(reconnect);
      })
      .catch((error) => {
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'reconnect'
          },
          EVENT_TRIGGERS.MEETING_RECONNECTION_FAILURE,
          {
            error: new ReconnectionError(error)
          }
        );

        return Promise.reject(new ReconnectionError(error));
      })
      .finally((reconnect) => {
        this.reconnectionManager.reset();

        return Promise.resolve(reconnect);
      });
  }

  /**
   *
   * Specify joining via audio (option: pstn), video, screenshare
   * @param {Object} options A configurable options object for joining a meeting
   * @param {String} options.resourceId pass the deviceId
   * @param {Number} options.hostPin pass the host pin
   * @param {Boolean} options.moderator pass the moderator flag
   * @returns {Promise} the join response
   * @public
   * @memberof Meeting
   * Scenario A: Joining own claimed personal meeting room, don't pass hostPin, do pass moderator
   * Scenario B: Joining other's claimed personal meeting room, do pass hostPin (if desired to join as host, or nullify), do pass moderator
   * Scenario C: Joining an unclaimed personal meeting room, -do not- pass hostPin or moderator on first try, -do- pass hostPin and moderator
   *             if joining as host on second loop, -do not- pass hostPin do pass moderator if joining as guest on second loop
   * Scenario D: Joining any other way (sip, pstn, convoId, link just need to specify resourceId)
   */
  join(options = {}) {
    if (this.meetingFSM.state === MEETING_STATE_MACHINE.STATES.ENDED) {
      this.meetingFSM.reset();
    }
    if (this.meetingFSM.state !== MEETING_STATE_MACHINE.STATES.RINGING) {
      this.meetingFSM.ring(_JOIN_);
    }

    if (options.resourceId && this.destination && options.resourceId === this.destination) {
      this.wirelessShare = true;
    }

    return MeetingUtil.joinMeetingOptions(this, options).then((join) => {
      this.meetingFSM.join();

      return Promise.resolve(join);
    }).catch((error) => {
      this.meetingFSM.fail(error);

      return Promise.reject(error);
    });
  }

  /**
   * get local media streams based on options passed
   * @param {Object} mediaDirection A configurable options object for joining a meeting
   * @param {Object} audioVideo an optional audio/video object to set audioinput and videoinput devices, see #Media.getUserMedia
   * @returns {Promise} see #Media.getUserMedia
   * @public
   * @todo should be static, or moved so can be called outside of a meeting
   * @memberof Meeting
   */
  getMediaStreams = (mediaDirection, audioVideo = {}) => Media.getUserMedia(mediaDirection, audioVideo)
    .then((response) => {
      if (!response[0] && !response[1]) {
        return Promise.reject(new Error('Was not able to retrive media Stream'));
      }

      return Promise.resolve(response);
    });

  /**
   * get the devices from the Media module
   * @returns {Promise} resolves to an array of DeviceInfo
   * @memberof Meetings
   */
  getDevices = () => Media.getDevices();

  /**
   * Specify joining via audio (option: pstn), video, screenshare
   * @param {Object} options A configurable options object for joining a meeting
   * @param {Object} options.resourceId pass the deviceId
   * @param {MediaStream} options.localStream
   * @param {MediaStream} options.localShare
   * @returns {Promise}
   * @public
   * @memberof Meeting
   */
  addMedia(options = {}) {
    const {localStream, localShare, mediaSettings} = options;

    return MeetingUtil.validateOptions(options)
      .then(() => this.preMedia(localStream, localShare, mediaSettings))
      .then(() => Media.attachMedia(this.mediaProperties)
        .then((peerConnection) => {
          LoggerProxy.logger.log(`Meeting:index->addMedia#PeerConnection Received from attachMedia ${peerConnection}`);
          this.setRemoteStream(peerConnection);
        })
        .catch((err) => {
          this.logger.error('Meeting:index#join --> Error joining the call on roap initialization, ', err);
          throw err;
        })
        .then(() =>
          this.roap
            .sendRoapMediaRequest({
              sdp: this.mediaProperties.peerConnection.sdp,
              roapSeq: this.roapSeq,
              meeting: this // or can pass meeting ID
            })
            .catch((err) => {
              this.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
              throw err;
            }))

        .then(() => {
          if (mediaSettings && mediaSettings.sendShare && localShare) {
            return this.share();
          }

          return Promise.resolve();
        }));
  }


  updateMedia(options = {}) {
    const {localStream, localShare, mediaSettings} = options;

    MeetingUtil.validateOptions(options);
    this.preMedia(localStream, localShare, mediaSettings);

    return Media.updateMedia(this.mediaProperties, PeerConnectionManager, localStream, localShare,
      this.mediaProperties.peerConnection)
      .then((peerConnection) => {
        LoggerProxy.logger.log(`Meeting:index->updateMedia#PeerConnection received from updateMedia, ${peerConnection}`);
        this.setRemoteStream(peerConnection);
        if (mediaSettings.receiveShare || localShare) {
          PeerConnectionManager.setContentSlides(peerConnection);
        }
      })
      .catch((err) => {
        LoggerProxy.logger.error('Meeting:index#join --> Error joining the call on roap initialization, ', err);
        throw err;
      })
      .then(() =>
        this.roap
          .sendRoapMediaRequest({
            sdp: this.mediaProperties.peerConnection.sdp,
            roapSeq: this.roapSeq,
            meeting: this // or can pass meeting ID
          })
          .catch((err) => {
            LoggerProxy.logger.error('Meeting:index#join --> Error joining the call on send roap media request, ', err);
            throw err;
          }))
      .then(() => {
        // TODO check if user is already sharing (SHARING STATE)
        if (this.isSharing) {
          this.share();
        }
      });
  }

  updateTransceiver(options) {
    const {
      type,
      sendTrack,
      receiveTrack,
      track,
      transceiver,
      peerConnection,
      previousMediaDirection
    } = options;

    if ((sendTrack !== undefined && sendTrack !== previousMediaDirection.sendTrack) ||
    (receiveTrack !== undefined && receiveTrack !== previousMediaDirection.receiveTrack)) {
      return Media.updateTransceiver(peerConnection, transceiver,
        {
          track,
          type,
          receiveTrack,
          sendTrack
        })
        .then(() => this.roap
          .sendRoapMediaRequest({
            sdp: this.mediaProperties.peerConnection.sdp,
            roapSeq: this.roapSeq,
            meeting: this // or can pass meeting ID
          }))
        .catch((e) => {
          LoggerProxy.logger.error(`Meeting:index->updateTransceiver#Error updating the ${type} streams with error: ${e}`);
        });
    } if (track) {
      transceiver.sender.replaceTrack(track);

      return Promise.resolve();
    }

    return Promise.reject(new Error('update Failed: please pass valid parameter'));
  }

  // streams are optional
  updateAudio(options) {
    const {sendAudio, receiveAudio, stream} = options;
    const {audioTransceiver} = this.mediaProperties.peerConnection;
    const track = MeetingUtil.getTrack(stream).audioTrack;

    if (typeof sendAudio !== 'boolean' || typeof receiveAudio !== 'boolean') {
      return Promise.reject(new Error('Pass sendVideo and receiveVideo parameter'));
    }

    return MeetingUtil.validateOptions({sendAudio, localStream: stream})
      .then(() => this.updateTransceiver({
        type: 'audio',
        sendTrack: options.sendAudio,
        receiveTrack: options.sendVideo,
        track,
        transceiver: audioTransceiver,
        peerConnection: this.mediaProperties.peerConnection,
        previousMediaDirection: {
          sendTrack: this.mediaProperties.mediaDirection.sendAudio,
          receiveTrack: this.mediaProperties.mediaDirection.receiveAudio
        }
      }))
      .then(() => {
        this.mediaProperties.setLocalAudioTrack(track);
        this.mediaProperties.mediaDirection.sendAudio = sendAudio;
        this.mediaProperties.mediaDirection.reciveAudio = receiveAudio;
      });
  }

  updateVideo(options) {
    const {sendVideo, receiveVideo, stream} = options;
    const {videoTransceiver} = this.mediaProperties.peerConnection;
    const track = MeetingUtil.getTrack(stream).videoTrack;

    if (typeof sendVideo !== 'boolean' || typeof receiveVideo !== 'boolean') {
      return Promise.reject(new Error('Pass sendVideo and receiveVideo parameter'));
    }

    return MeetingUtil.validateOptions({sendVideo, localStream: stream})
      .then(() => this.updateTransceiver({
        type: 'video',
        sendTrack: options.sendVideo,
        receiveTrack: options.sendVideo,
        track,
        transceiver: videoTransceiver,
        peerConnection: this.mediaProperties.peerConnection,
        previousMediaDirection: {
          sendTrack: this.mediaProperties.mediaDirection.sendVideo,
          receiveTrack: this.mediaProperties.mediaDirection.receiveVideo
        }
      }))
      .then(() => {
        this.mediaProperties.setLocalVideoTrack(track);
        this.mediaProperties.mediaDirection.sendVideo = sendVideo;
        this.mediaProperties.mediaDirection.reciveVideo = receiveVideo;
      });
  }


  startStopShare(sendShare) {
    if (!this.isSharing && sendShare &&
      !this.mediaProperties.mediaDirection.sendShare) {
      // When user starts sharing
      this.share();
    }
    else if (this.isSharing && !sendShare &&
      this.mediaProperties.mediaDirection.sendShare) {
      // When user stops sharing
      this.stopShare();
    }
  }

  updateShare(options) {
    const {sendShare, receiveShare, stream} = options;
    const {shareTransceiver} = this.mediaProperties.peerConnection;
    const track = MeetingUtil.getTrack(stream).videoTrack;

    if (typeof sendShare !== 'boolean' || typeof receiveShare !== 'boolean') {
      return Promise.reject(new Error('Pass sendShare and receiveShare parameter'));
    }

    return MeetingUtil.validateOptions({sendShare, localShare: stream})
      .then(() => this.updateTransceiver({
        type: 'video',
        sendTrack: sendShare,
        receiveTrack: receiveShare,
        track,
        transceiver: shareTransceiver,
        peerConnection: this.mediaProperties.peerConnection,
        previousMediaDirection: {
          sendTrack: this.mediaProperties.mediaDirection.sendShare,
          receiveTrack: this.mediaProperties.mediaDirection.receiveShare
        }
      }))
      .then(() => {
        this.mediaProperties.setLocalShareTrack(track);
        this.startStopShare(sendShare);
        this.mediaProperties.mediaDirection.sendShare = sendShare;
        this.mediaProperties.mediaDirection.reciveShare = receiveShare;
      });
  }

  /**
   * do all the attach media pre set up before executing the actual attach
   * @param {MediaStream} localStream
   * @param {MediaStream} localShare
   * @param {MediaStream} mediaSettings
   * @returns {undefined}
   * @private
   * @memberof Meeting
   */
  preMedia(localStream, localShare, mediaSettings) {
    // eslint-disable-next-line no-warning-comments
    // TODO wire into default config. There's currently an issue with the stateless plugin or how we register
    this.mediaProperties.setMediaDirection(Object.assign(this.config.mediaSettings, mediaSettings));
    // add a setup a function move the create and setup media in future
    // TODO: delete old audio and video if stale
    this.audio = this.audio || AudioStateMachine.create(this.mediaProperties.mediaDirection, this);
    this.video = this.video || VideoStateMachine.create(this.mediaProperties.mediaDirection, this);
    // Validation is already done in addMedia so no need to check if the lenght is greater then 0
    this.setLocalTracks(localStream);
    this.setLocalShareTrack(localShare);
  }

  /**
   * acknowledge the meeting, outgoing or incoming
   * @param {String} type
   * @returns {Promise} resolve {message, ringing, response}
   * @public
   * @memberof Meeting
   */
  acknowledge(type) {
    if (!type) {
      return Promise.reject(new Error('Type must be set to acknowledge the meeting.'));
    }
    if (type === _INCOMING_) {
      return this.meetingRequest
        .acknowledgeMeeting({
          locusUrl: this.locusUrl,
          deviceUrl: this.deviceUrl,
          id: this.id
        })
        .then((response) => Promise.resolve(response))
        .then((response) => {
          this.meetingFSM.ring(type);

          return Promise.resolve({
            response
          });
        });
    }

    // TODO: outside of 1:1 incoming, and all outgoing calls
    return Promise.resolve({
      message: 'noop'
    });
  }

  /**
   * Decline this meeting
   * @param {String} reason
   * @returns {undefined}
   * @public
   * @memberof Meeting
   */
  decline(reason = _BUSY_) {
    return MeetingUtil.declineMeeting(this, reason).then((decline) => {
      this.meetingFSM.decline();

      return Promise.resolve(decline);
    }).catch((error) => {
      this.meetingFSM.fail(error);

      return Promise.reject(error);
    });
  }

  /**
   * Leave the current meeting
   * @param {Object} options An object of options
   * @param {Boolean} options.keepLocalMedia Whether to tear down the local media connections or not.
   * @returns {Promise}
   * @public
   * @memberof Meeting
   */
  leave() {
    return MeetingUtil.leaveMeeting(this)
      .then((leave) => {
        this.meetingFSM.leave();
        if (this.wirelessShare || this.guest) {
          // If screen sharing clean the meeting object
          Trigger.trigger(
            this,
            {
              file: 'meeting/index',
              function: 'leave'
            },
            EVENTS.DESTROY_MEETING,
            {
              meetingId: this.id
            }
          );
        }

        return Promise.resolve(leave);
      }).catch((error) => {
        this.meetingFSM.fail(error);

        return Promise.reject(error);
      });
  }

  /**
   * start sharing content
   * @returns {Promise} see #meetingRequest.changeMeetingFloor
   * @public
   * @memberof Meeting
   */
  share() {
    const content = this.locusInfo.mediaShares.find((element) => element.name === CONTENT);

    if (content) {
      return this.meetingRequest.changeMeetingFloor({
        disposition: FLOOR_ACTION.GRANTED,
        personUrl: this.locusInfo.self.url,
        deviceUrl: this.deviceUrl,
        uri: content.url,
        resourceUrl: this.resourceUrl
      })
        .then(() => {
          // TODO : set isSharing to true
          this.isSharing = true;
          Trigger.trigger(
            this,
            {
              file: 'meeting/index',
              function: 'share'
            },
            EVENT_TRIGGERS.MEETING_STARTED_SHARING_LOCAL,
          );
        })
        .catch((e) => {
          LoggerProxy.logger.error('Meeting/index->share#Error ', e);

          return Promise.reject(e);
        });
    }

    return Promise.reject(new Error('Cannot share without content.'));
  }

  /**
   * stops the screen share
   * @returns {Promise} see #meetingRequest.changeMeetingFloor
   * @public
   * @memberof Meeting
   */
  stopShare() {
    const content = this.locusInfo.mediaShares.find((element) => element.name === CONTENT);

    if (content) {
      Media.stopTracks(this.mediaProperties.shareTrack);

      return this.meetingRequest.changeMeetingFloor({
        disposition: FLOOR_ACTION.RELEASED,
        personUrl: this.locusInfo.self.url,
        deviceUrl: this.deviceUrl,
        uri: content.url,
        resourceUrl: this.resourceUrl
      }).then(() => {
        this.isSharing = false;
        Trigger.trigger(
          this,
          {
            file: 'meeting/index',
            function: 'stopShare'
          },
          EVENT_TRIGGERS.MEETING_STOPPED_SHARING_LOCAL,
        );
      });
    }

    return Promise.reject(new Error('Cannot stop share without content'));
  }

  // /**
  //  *
  //  * Send this meeting to the phone system
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // sendDtmf() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Lock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // lock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Unlock this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // unlock() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * Intiate a recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // startRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }

  // /**
  //  *
  //  * End the recording of this meeting
  //  * @returns {Promise}
  //  * @memberof Meeting
  //  */
  // stopRecording() {
  //   return new Promise((resolve) => resolve({}));
  // }
}
