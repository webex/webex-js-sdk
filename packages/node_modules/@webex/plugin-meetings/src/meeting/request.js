import uuid from 'uuid';
import {StatelessWebexPlugin} from '@webex/webex-core';

import LoggerProxy from '../common/logs/logger-proxy';
import {
  ALERT,
  ALTERNATE_REDIRECT_TRUE,
  CALL,
  CONTROLS,
  DECLINE,
  FLOOR_ACTION,
  HTTP_VERBS,
  LEAVE,
  LOCI,
  LOCUS,
  MEDIA,
  PARTICIPANT,
  SEND_DTMF_ENDPOINT,
  _SLIDES_
} from '../constants';

/**
 * @class MeetingRequest
 */
export default class MeetingRequest extends StatelessWebexPlugin {
  /**
   * Make a network request to join a meeting
   * @param {Object} options
   * @param {String} options.sipUri
   * @param {String} options.deviceUrl
   * @param {String} options.locusUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @param {boolean} options.ensureConversation
   * @param {boolean} options.moderator
   * @param {boolean} options.pin
   * @param {boolean} options.moveToResource
   * @param {Object} options.roapMessage
   * @returns {Promise}
   */
  async joinMeeting(options) {
    const {
      sipUri, deviceUrl, locusUrl, resourceId, correlationId, ensureConversation, moderator, pin, moveToResource, roapMessage
    } = options;

    LoggerProxy.logger.info(
      'Meeting:request#joinMeeting --> Joining a meeting',
      correlationId
    );

    let url = '';

    const body = {
      device: {
        url: deviceUrl,
        deviceType: this.config.meetings.deviceType
      },
      usingResource: resourceId || null,
      moveMediaToResource: resourceId && moveToResource || false,
      correlationId,
      respOnlySdp: true,
      allowMultiDevice: true,
      ensureConversation: ensureConversation || false,
      supportsNativeLobby: 1
    };

    if (moderator !== undefined) {
      body.moderator = moderator;
    }

    if (pin !== undefined) {
      body.pin = pin;
    }

    if (locusUrl) {
      url = `${locusUrl}/${PARTICIPANT}`;
    }
    else if (sipUri) {
      try {
        await this.webex.internal.services.waitForCatalog('postauth');
        url = `${this.webex.internal.services.get('locus')}/${LOCI}/${CALL}`;
        body.invitee = {
          address: sipUri
        };
      }
      catch (e) {
        LoggerProxy.logger.error(`Meeting:request#joinMeeting --> ${e}`);
        throw (e);
      }
    }

    // TODO: -- this will be resolved in SDK request
    url = url.concat(`?${ALTERNATE_REDIRECT_TRUE}`);

    if (resourceId === sipUri) {
      body.callPreferences = {
        requestedMedia: [_SLIDES_]
      };
    }

    if (roapMessage) {
      body.localMedias = roapMessage.localMedias;
    }

    return this.webex.request({
      method: HTTP_VERBS.POST,
      uri: url,
      body
    });
  }

  /**
   * Syns the missed delta event
   * @param {Object} options
   * @param {boolen} options.desync flag to get partial or whole locus object
   * @param {String} options.syncUrl sync url to get ht elatest locus delta
   * @returns {Promise}
   */
  syncMeeting(options) {
    /* eslint-disable no-else-return */
    const {desync} = options;
    let {syncUrl} = options;

    /* istanbul ignore else */
    if (desync) {
      // check for existing URL parameters
      syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat(`${LOCUS.SYNCDEBUG}=${desync}`);
    }

    return this.request({
      method: HTTP_VERBS.GET,
      uri: syncUrl
    }) // TODO: Handle if delta sync failed . Get the full locus object
      .catch((err) => {
        LoggerProxy.logger.error(`Meeting:request#syncMeeting --> Error syncing meeting, error ${err}`);

        return err;
      });
  }

  /**
   * Request to get the complete locus object
   * @param {Object} options
   * @param {boolen} options.desync flag to get partial or whole locus object
   * @param {String} options.locusUrl sync url to get ht elatest locus delta
   * @returns {Promise}
   */
  getFullLocus(options) {
    let {locusUrl} = options;
    const {desync} = options;

    if (locusUrl) {
      if (desync) {
        locusUrl += `?${LOCUS.SYNCDEBUG}=${desync}`;
      }

      return this.request({
        method: HTTP_VERBS.GET,
        uri: locusUrl
      }).catch((err) => {
        LoggerProxy.logger.error(`Meeting:request#getFullLocus --> Error getting full locus, error ${err}`);

        return err;
      });
    }

    return Promise.reject();
  }

  /**
   * Make a network request to leave a meeting
   * @param {Object} options
   * @param {Url} options.locusUrl
   * @param {String} options.selfId
   * @param {Url} options.deviceUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @returns {Promise}
   */
  leaveMeeting({
    locusUrl, selfId, deviceUrl: url, resourceId, correlationId
  }) {
    LoggerProxy.logger.info(
      'Meeting:request#leaveMeeting --> Leaving a meeting',
      correlationId
    );

    const uri = `${locusUrl}/${PARTICIPANT}/${selfId}/${LEAVE}`;
    const body = {
      device: {
        deviceType: this.config.meetings.deviceType,
        url
      },
      usingResource: resourceId || null,
      correlationId
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * Make a network request to acknowledge a meeting
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.id
   * @returns {Promise}
   */
  acknowledgeMeeting(options) {
    const uri = `${options.locusUrl}/${PARTICIPANT}/${ALERT}`;
    const body = {
      device: {
        deviceType: this.config.meetings.deviceType,
        url: options.deviceUrl
      },
      correlationId: options.id
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * Make a network request to acknowledge a meeting
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.id
   * @returns {Promise}
   */
  recordMeeting(options) {
    const uri = `${options.locusUrl}/${CONTROLS}`;
    const body = {
      record: {
        recording: options.recording,
        paused: options.paused
      }
    };

    return this.request({
      method: HTTP_VERBS.PATCH,
      uri,
      body
    });
  }

  lockMeeting(options) {
    const uri = `${options.locusUrl}/${CONTROLS}`;
    const body = {
      lock: {
        locked: options.lock
      }
    };

    return this.request({
      method: HTTP_VERBS.PATCH,
      uri,
      body
    });
  }

  /**
   * Make a network request to decline a meeting
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.reason
   * @returns {Promise}
   */
  declineMeeting(options) {
    const uri = `${options.locusUrl}/${PARTICIPANT}/${DECLINE}`;
    const body = {
      device: {
        deviceType: this.config.meetings.deviceType,
        url: options.deviceUrl
      },
      reason: options.reason
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * Toggle remote audio and/or video
   * @param {Object} options options for toggling
   * @param {String} options.selfId Locus self id??
   * @param {String} options.locusUrl Locus url
   * @param {String} options.deviceUrl Url of a device
   * @param {String} options.resourceId Populated if you are paired to a device
   * @param {String} options.localMedias local sdps
   * @returns {Promise}
   */
  remoteAudioVideoToggle(options) {
    const uri = `${options.locusUrl}/${PARTICIPANT}/${options.selfId}/${MEDIA}`;
    const body = {
      device: {
        deviceType: this.config.meetings.deviceType,
        url: options.deviceUrl
      },
      usingResource: options.resourceId || null,
      correlationId: options.correlationId,
      respOnlySdp: true,
      localMedias: options.localMedias
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * change the content floor grant
   * @param {Object} options options for floor grant
   * @param {String} options.disposition floor action (granted/released)
   * @param {String} options.personUrl personUrl who is requesting floor
   * @param {String} options.deviceUrl Url of a device
   * @param {String} options.resourceId Populated if you are paired to a device
   * @param {String} options.uri floor grant uri
   * @returns {Promise}
   */
  changeMeetingFloor(options) {
    let floorReq = {disposition: options.disposition};

    /* istanbul ignore else */
    if (options.disposition === FLOOR_ACTION.GRANTED) {
      floorReq = {
        beneficiary: {
          url: options.personUrl,
          devices: [
            {
              deviceType: this.config.meetings.deviceType,
              url: options.deviceUrl
            }
          ]
        },
        disposition: options.disposition,
        requester: {
          url: options.personUrl
        }
      };
    }

    return this.request({
      uri: options.uri,
      method: HTTP_VERBS.PUT,
      body: {
        floor: floorReq,
        resourceUrl: options.resourceUrl
      }
    });
  }

  /**
   * Sends a request to the DTMF endpoint to send tones
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.tones a string of one or more DTMF tones to send
   * @returns {Promise}
   */
  sendDTMF({locusUrl, deviceUrl, tones}) {
    return this.request({
      method: HTTP_VERBS.POST,
      uri: `${locusUrl}/${SEND_DTMF_ENDPOINT}`,
      body: {
        deviceUrl,
        dtmf: {
          correlationId: uuid.v4(),
          tones
        }
      }
    });
  }

  /**
   * Sends a request to the controls endpoint to set the video layout
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.layoutType a layout type that should be available in meeting constants LAYOUT_TYPES
   * @returns {Promise}
   */
  changeVideoLayout({locusUrl, deviceUrl, layoutType}) {
    return this.request({
      method: HTTP_VERBS.PUT,
      uri: `${locusUrl}/${CONTROLS}`,
      body: {
        layout: {
          deviceUrl,
          type: layoutType
        }
      }
    });
  }
}
