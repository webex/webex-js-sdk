import {StatelessWebexPlugin} from '@webex/webex-core';

import LoggerProxy from '../common/logs/logger-proxy';
import {
  PARTICIPANT,
  LOCI,
  CALL,
  LEAVE,
  MEDIA,
  FLOOR_ACTION,
  DECLINE,
  ALERT,
  HTTP_VERBS,
  LOCUS,
  ALTERNATE_REDIRECT_TRUE,
  _SLIDES_
} from '../constants';

/**
 * @class MeetingRequest
 */
export default class MeetingRequest extends StatelessWebexPlugin {
  /**
   * Make a network request to join a meeting
   * @param {Object} options
   * @param {String} options.sipUri
   * @param {String} options.deviceUrl
   * @param {String} options.locusUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @returns {Promise}
   */
  joinMeeting(options) {
    const {
      sipUri, deviceUrl, locusUrl, resourceId, correlationId, ensureConversation, moderator, hostPin
    } = options;

    let url = '';

    const body = {
      deviceUrl,
      usingResource: resourceId || null,
      correlationId,
      respOnlySdp: true,
      allowMultiDevice: true,
      ensureConversation: ensureConversation || false,
      supportsNativeLobby: 1
    };

    if (moderator !== undefined) {
      body.moderator = moderator;
    }

    if (hostPin !== undefined) {
      body.hostPIN = hostPin;
    }

    if (sipUri) {
      // eslint-lin-disable-next-line no-warning-comments
      // TODO switch to use the locus object and look into federation?
      url = `${this.webex.internal.device.services.locusServiceUrl}/${LOCI}/${CALL}`;
      body.invitee = {
        address: sipUri
      };
    }
    else if (locusUrl) {
      url = `${locusUrl}/${PARTICIPANT}`;
    }

    // TODO: -- this will be resolved in SDK request
    url = url.concat(`?${ALTERNATE_REDIRECT_TRUE}`);

    if (resourceId === sipUri) {
      body.callPreferences = {
        requestedMedia: [_SLIDES_]
      };
    }

    return this.webex.request({
      method: HTTP_VERBS.POST,
      uri: url,
      body
    });
  }

  /**
   * Syns the missed delta event
   * @param {Object} options
   * @param {boolen} options.desync flag to get partial or whole locus object
   * @param {String} options.syncUrl sync url to get ht elatest locus delta
   * @returns {Promise}
   */
  syncMeeting(options) {
    /* eslint-disable no-else-return */
    const {desync} = options;
    let {syncUrl} = options;

    /* istanbul ignore else */
    if (desync) {
      // check for existing URL parameters
      syncUrl = syncUrl.concat(syncUrl.split('?')[1] ? '&' : '?').concat(`${LOCUS.SYNCDEBUG}=${desync}`);
    }

    return this.request({
      method: HTTP_VERBS.GET,
      uri: syncUrl
    })// TODO: Handle if delta sync failed . Get the full locus object
      .catch((err) => {
        LoggerProxy.logger.error(`MeetingRequest->syncMeeting#Error syncing meeting, error ${err}`);

        return err;
      });
  }

  /**
   * Request to get the complete locus object
   * @param {Object} options
   * @param {boolen} options.desync flag to get partial or whole locus object
   * @param {String} options.locusUrl sync url to get ht elatest locus delta
   * @returns {Promise}
   */

  getFullLocus(options) {
    let {locusUrl} = options;
    const {desync} = options;

    if (locusUrl) {
      if (desync) {
        locusUrl += `?${LOCUS.SYNCDEBUG}=${desync}`;
      }

      return this.request({
        method: HTTP_VERBS.GET,
        uri: locusUrl
      })
        .catch((err) => {
          LoggerProxy.logger.error(`MeetingRequest->getFullLocus#Error getting full locus, error ${err}`);

          return err;
        });
    }

    return Promise.reject();
  }

  /**
   * Make a network request to leave a meeting
   * @param {Object} options
   * @param {String} options.deviceUrl
   * @param {String} options.resourceId,
   * @param {String} options.correlationId
   * @returns {Promise}
   */
  leaveMeeting(options) {
    const url = `${options.locusUrl}/${PARTICIPANT}/${options.selfId}/${LEAVE}`;
    const body = {
      deviceUrl: options.deviceUrl,
      usingResource: options.resourceId,
      correlationId: options.correlationId
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri: url,
      body
    });
  }

  /**
   * Make a network request to acknowledge a meeting
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.id
   * @returns {Promise}
   */
  acknowledgeMeeting(options) {
    const uri = `${options.locusUrl}/${PARTICIPANT}/${ALERT}`;
    const body = {
      deviceUrl: options.deviceUrl,
      correlationId: options.id
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * Make a network request to decline a meeting
   * @param {Object} options
   * @param {String} options.locusUrl
   * @param {String} options.deviceUrl
   * @param {String} options.reason
   * @returns {Promise}
   */
  declineMeeting(options) {
    const uri = `${options.locusUrl}/${PARTICIPANT}/${DECLINE}`;
    const body = {
      deviceUrl: options.deviceUrl,
      reason: options.reason
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri,
      body
    });
  }

  /**
   * Toggle remote audio and/or video
   * @param {Object} options options for toggling
   * @param {String} options.selfId Locus self id??
   * @param {String} options.locusUrl Locus url
   * @param {String} options.deviceUrl Url of a device
   * @param {String} options.resourceId Populated if you are paired to a device
   * @param {String} options.localMedias local sdps
   * @returns {Promise}
   */
  remoteAudioVideoToggle(options) {
    const url = `${options.locusUrl}/${PARTICIPANT}/${options.selfId}/${MEDIA}`;
    const body = {
      deviceUrl: options.deviceUrl,
      usingResource: options.resourceId || null,
      correlationId: options.correlationId,
      respOnlySdp: true,
      localMedias: options.localMedias
    };

    return this.request({
      method: HTTP_VERBS.PUT,
      uri: url,
      body
    });
  }

  /**
   * change the content floor grant
   * @param {Object} options options for floor grant
   * @param {String} options.disposition floor action (granted/released)
   * @param {String} options.personUrl personUrl who is requesting floor
   * @param {String} options.deviceUrl Url of a device
   * @param {String} options.resourceId Populated if you are paired to a device
   * @param {String} options.uri floor grant uri
   * @returns {Promise}
   */
  changeMeetingFloor(options) {
    let floorReq = {disposition: options.disposition};

    /* istanbul ignore else */
    if (options.disposition === FLOOR_ACTION.GRANTED) {
      floorReq = {
        beneficiary: {
          url: options.personUrl,
          devices: [{url: options.deviceUrl}]
        },
        disposition: options.disposition,
        requester: {
          url: options.personUrl
        }
      };
    }

    return this.request({
      uri: options.uri,
      method: HTTP_VERBS.PUT,
      body: {
        floor: floorReq,
        resourceUrl: options.resourceUrl
      }
    });
  }
}
