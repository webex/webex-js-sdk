import {SparkPlugin} from '@ciscospark/spark-core';

import {PARTICIPANT, LOCI, CALL, POST} from '../constants';

const MeetingRequest = SparkPlugin.extend({
  namespace: 'Meetings',

  joinMeeting(options) {
    const {
      sipUri, deviceUrl, locusUrl, resourceId, correlationId
    } = options;

    let url = '';

    const body = {
      deviceUrl,
      usingResource: resourceId || null,
      correlationId,
      respOnlySdp: true,
      supportsNativeLobby: 1,
      allowMultiDevice: true
    };

    if (locusUrl) {
      url = `${locusUrl}/${PARTICIPANT}`;
    }
    else if (sipUri) {
      url = `${this.spark.internal.device.services.locusServiceUrl}/${LOCI}/${CALL}`;
      body.invitee = {
        address: sipUri
      };
    }

    return this.spark.request({
      method: POST,
      uri: url,
      qs: {alternateRedirect: true}, // for handling locus URL redirections
      body
    });
  },

  sendMeetingRequest(options) {
    // let locus;
    // let {identifiers} = options;
    // const {correlationId} = identifiers;
    // const {
    //   locusUrl, resource, sipTarget, localSdp, roapMessage, hostPIN, password, moderator, moveCall
    // } = options;
    // const deviceUrl = spark.internal.device.url;
    // let url = '';
    // const isLocalMedia = resource && resource.id === MeetingConstants.devices.self.id;
    // const localMedia = [];
    // if (localSdp || roapMessage) {
    //   try {
    //     const reachabilityData = StorageAdapter.getItem('reachability.result');
    //     if (reachabilityData) {
    //       const reachabilityResult = JSON.parse(reachabilityData);
    //       if (reachabilityResult && Object.keys(reachabilityResult).length) {
    //         if (localSdp) {
    //           defaults(localSdp, {reachability: reachabilityResult});
    //         }
    //         else if (roapMessage) {
    //           defaults(roapMessage, {reachability: reachabilityResult});
    //         }
    //       }
    //     }
    //   }
    //   catch (err) {
    //     config.console.error(`Exception in parsing reachability data : ${err}`);
    //   }
    //   localMedia.push({
    //     localSdp: JSON.stringify(localSdp || roapMessage)
    //   });
    // }
    // const body = {
    //   deviceUrl,
    //   usingResource: isLocalMedia ? null : resource.id,
    //   correlationId,
    //   // localMedias: localMedia,
    //   respOnlySdp: true,
    //   supportsNativeLobby: 1,
    //   allowMultiDevice: true,
    //   moveMediaToResource: moveCall ? !isLocalMedia : false
    // };
    // if (hostPIN) {
    //   body.pin = hostPIN;
    // }
    // else if (password) {
    //   body.pin = password;
    // }
    // if (moderator !== undefined) {
    //   body.moderator = moderator;
    // }
    // if (locusUrl) {
    //   url = `${locusUrl}/participant`;
    // }
    // else if (sipTarget) {
    //   url = `${spark.internal.device.services.locusServiceUrl}/loci/call`;
    //   body.invitee = {
    //     address: sipTarget
    //   };
    // }
    // config.console.info(`Call->Locus: sending join request : ${url}`);
    // // Metric
    // CallDiagnosticUtil.sendCallDiagnosticEvent(
    //   CallDiagnosticConstants.eventType.CLIENT_LOCUS_JOIN_REQUEST,
    //   identifiers
    // );
    // return spark
    //   .request({
    //     method: 'POST',
    //     uri: url,
    //     qs: {alternateRedirect: true}, // for handling locus URL redirections
    //     body
    //   })
    //   .then((res) => {
    //     ({locus} = res.body);
    //     // always it will be the first mediaConnection Object
    //     // TODO: move this to a util file
    //     const mediaConnection
    //       = res.body.mediaConnections && res.body.mediaConnections.length > 0 && res.body.mediaConnections[0];
    //     config.console.info(
    //       `Call-sendMeetingRequest response:${JSON.stringify(mediaConnection, null, 2)}'\n StatusCode:'${
    //         res.statusCode
    //       }`
    //     );
    //     locus.roapSeq = roapMessage && roapMessage.seq;
    //     identifiers = CallDiagnosticUtil.updateIdentifiersWithResponse(identifiers, res);
    //     CallDiagnosticUtil.sendCallDiagnosticEvent(
    //       CallDiagnosticConstants.eventType.CLIENT_LOCUS_JOIN_RESPONSE,
    //       identifiers,
    //       {trigger: CallDiagnosticConstants.trigger.LOCI_UPDATE}
    //     );
    //     return res;
    //   })
    //   .catch((err) => {
    //     config.console.error('Call-sendMeetingRequest : ', err);
    //     config.console.error(`Call-sendMeetingRequest: errorBody ${JSON.stringify(body, null, 2)}`);
    //     return Promise.reject(err);
    //   });
  }
});

export default MeetingRequest;
