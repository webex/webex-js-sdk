import EventsScope from '../common/events/events-scope';
import {
  DEFAULT_EVENT_VIDEO_SEND_KEYS,
  DEFAULT_EVENT_AUDIO_SEND_KEYS,
  DEFAULT_EVENT_AUDIO_RECEIVE_KEYS,
  DEFAULT_EVENT_VIDEO_RECEIVE_KEYS,
  EVENT_TYPES,
  EVENTS,
  EVENT_STATS_MAP,
  MEETINGS,
  AUDIO,
  VIDEO
} from '../constants';

// TODO: this class needs to be refactored to take account of the
// fact that we are using transceivers rather than peer connection
// it still works with transceivers, but it is more complex than it
// needs to be now

/**
 * @param {Object} operate the filtered, parsed, converted, transformed, simplified data point to check against
 * @param {String} type - local or remote
 * @param {String} keys - the stat keys for types of stats defined by DEFAULT_TRANSFORM_REGEX
 * @param {String} stat - the accessor to get the actual stat
 * @param {String} kind - audio or video
 * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
 */
const operateEvent = (operate, type, keys, stat, kind) => {
  const foundMatch = {};

  foundMatch.found = keys.some((key) => {
    if (operate[key] && operate[key][stat] && operate[key][stat] > 0) {
      foundMatch.match = {
        type,
        key,
        data: operate[key],
        stat,
        kind
      };

      return true;
    }

    return false;
  });

  return foundMatch;
};

export default class StatsEvents extends EventsScope {
  namespace = MEETINGS;

  /**
   * constructs an instance
   */
  constructor() {
    super();
    this.sentFirstVideoBytes = null;
    this.receivedFirstVideoBytes = null;
    this.sentFirstAudioBytes = null;
    this.receivedFirstAudioBytes = null;
  }

  /**
   * handles the first audio bytes received
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  receiveEventAudio(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();

      if (operate && !this.receivedFirstAudioBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_AUDIO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);

        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.receivedFirstAudioBytes = somethingMatched.match;
          this.emit({file: 'stats/events', function: 'receiveEventAudio'}, EVENTS.STATS_UPDATE, this.receivedFirstAudioBytes);
        }
      }
    }

    return this.receivedFirstVideoBytes;
  }

  /**
   * handles the first video bytes received
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first receiveFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  receiveEventVideo(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();

      if (operate && !this.receivedFirstVideoBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.REMOTE, DEFAULT_EVENT_VIDEO_RECEIVE_KEYS, EVENT_STATS_MAP.BYTES_RECEIVED, VIDEO);

        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.receivedFirstVideoBytes = somethingMatched.match;
          this.emit({file: 'stats/events', function: 'receiveEventVideo'}, EVENTS.STATS_UPDATE, this.receivedFirstVideoBytes);
        }
      }
    }

    return this.receivedFirstVideoBytes;
  }

  /**
   * handles the first video bytes sent
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first sentFirstVideoBytes were, in the past or if it happened now, or undefined if never
   */
  sendEventVideo(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();

      if (operate && !this.sentFirstVideoBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_VIDEO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, VIDEO);

        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.sentFirstVideoBytes = somethingMatched.match;
          this.emit({file: 'stats/events', function: 'sendEventVideo'}, EVENTS.STATS_UPDATE, this.sentFirstVideoBytes);
        }
      }
    }

    return this.sentFirstVideoBytes;
  }

  /**
   * handles the first audio bytes sent
   * @param {WebRTCData} data the filtered, parsed, converted, transformed, simplified data point to check against
   * @returns {Object} always whatever the first sentFirstAudioBytes were, in the past or if it happened now, or undefined if never
   */
  sendEventAudio(data) {
    if (data && data.data && data.data.getData()) {
      const operate = data.data.getData();

      if (operate && !this.sentFirstAudioBytes) {
        const somethingMatched = operateEvent(operate, EVENT_TYPES.LOCAL, DEFAULT_EVENT_AUDIO_SEND_KEYS, EVENT_STATS_MAP.BYTES_SENT, AUDIO);

        if (somethingMatched && somethingMatched.found && somethingMatched.match) {
          this.sentFirstAudioBytes = somethingMatched.match;
          this.emit({file: 'stats/events', function: 'sendEventAudio'}, EVENTS.STATS_UPDATE, this.sentFirstAudioBytes);
        }
      }
    }

    return this.sentFirstVideoBytes;
  }

  /**
   * handles all the types of events that need to be sent when they happen from getStats API
   * @param {WebRTCData} data
   * @returns {Object}
   */
  event(data) {
    return {
      sentFirstVideoBytes: this.sendEventVideo(data),
      receivedFirstVideoBytes: this.receiveEventVideo(data),
      sentFirstAudioBytes: this.sendEventAudio(data),
      receivedFirstAudioBytes: this.receiveEventAudio(data)
    };
  }
}
