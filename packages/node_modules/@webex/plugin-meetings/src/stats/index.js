import {forEach} from 'lodash';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

import {
  MEETINGS,
  STATS
} from '../constants';
import MeetingStats from '../stats/stats';
import StatsUtil from '../stats/util';

/**
 * @class WebRTCStats
 */
export default class WebRTCStats extends StatelessSparkPlugin {
    namespace = MEETINGS;

    /**
    *
    * @param {Object} attrs
    * @param {Object} options
    * @param {Object} optionalCreateOptions
   */
    constructor(attrs, options, optionalCreateOptions) {
      super({}, options);
      this.attrs = attrs;
      this.options = options;
      this.senders = {};
      this.receivers = {};
      this.meetingRef = null;
      this.statsConfig = null;
      this.populate(optionalCreateOptions);
    }

    populate(optionalCreateOptions) {
      if (optionalCreateOptions) {
        if (optionalCreateOptions.config) {
          this.setConfig(optionalCreateOptions.config);
        }
        if (optionalCreateOptions.meeting) {
          this.associateMeeting(optionalCreateOptions.meeting);
        }
        if (optionalCreateOptions.senders) {
          this.addSenders(optionalCreateOptions.senders);
        }
        if (optionalCreateOptions.receivers) {
          this.addReceivers(optionalCreateOptions.receivers);
        }
      }

      return this;
    }

    setConfig(config) {
      this.statsConfig = config;
    }

    associateMeeting(meeting) {
      this.meetingRef = meeting;

      return this;
    }

    addSenders(senders, useConfig = false) {
      if (!senders.forEach) {
        throw new Error('Stats senders must be created with an iterable array of senders to act on.');
      }
      senders.forEach((sender) => {
        this.addSender(sender, useConfig);
      });

      return this;
    }

    addSender(sender, useConfig = false) {
      if (sender) {
        if (useConfig) {
          StatsUtil.generateSingularOptions(sender, this.statsConfig, this.meetingRef, STATS.SENDERS);
        }
        this.senders[sender.id] = new MeetingStats(this.attrs, this.options, sender);
      }

      return this;
    }

    addSenderStats(id) {
      const newSender = new MeetingStats(this.attrs, this.options);

      this.senders[id] = newSender;

      return newSender;
    }

    addReceiverStats(id) {
      const newReceiver = new MeetingStats(this.attrs, this.options);

      this.receivers[id] = newReceiver;

      return newReceiver;
    }

    addReceivers(receivers, useConfig = false) {
      if (!receivers.forEach) {
        throw new Error('Stats receivers must be created with an iterable array of receivers to act on.');
      }
      receivers.forEach((receiver) => {
        this.addReceiver(receiver, useConfig);
      });

      return this;
    }

    addReceiver(receiver, useConfig = false) {
      if (receiver) {
        if (useConfig) {
          StatsUtil.generateSingularOptions(receiver, this.statsConfig, this.meetingRef, STATS.RECEIVERS);
        }
        this.receivers[receiver.id] = new MeetingStats(this.attrs, this.options, receiver);
      }

      return this;
    }

    getReceivers() {
      return this.receivers;
    }

    getSenders() {
      return this.senders;
    }

    getSender(id) {
      return this.senders[id];
    }

    getReceiver(id) {
      return this.receivers[id];
    }

    destroySenders() {
      forEach(this.senders, (v, k) => {
        this.destroySender(k);
      });
    }

    destroyReceivers() {
      forEach(this.receivers, (v, k) => {
        this.destroyReceiver(k);
      });
    }

    destroySender(id) {
      let sender = this.getSender(id);

      if (sender) {
        if (sender.stream) {
          sender.stream.destroy();
        }
      }
      sender = null;
      delete this.receivers[id];
    }

    destroyReceiver(id) {
      let receiver = this.getReceiver(id);

      if (receiver) {
        if (receiver.stream) {
          receiver.stream.destroy();
        }
      }
      receiver = null;
      delete this.receivers[id];
    }
}
