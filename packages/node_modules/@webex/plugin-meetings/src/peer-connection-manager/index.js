/* eslint-disable */
// We need to figure out how to pass a webex logger instance to these util files

/* globals window, RTCSessionDescription */

import bowser from 'bowser';
import sdpTransform from 'sdp-transform'; // https://github.com/clux/sdp-transform

import Metrics from '../metrics';
import LoggerProxy from '../common/logs/logger-proxy';
import StaticConfig from '../common/config';
import {
  RETRY_TIMEOUT,
  ICE_TIMEOUT,
  AUDIO,
  SDP,
  MEDIA_PEER_CONNECTION_NAME,
  ICE_STATE,
  ICE_FAIL_TIMEOUT,
  PEER_CONNECTION_STATE,
  OFFER,
  QUALITY_LEVELS,
  MAX_FRAMESIZES
} from '../constants';

import {error, eventType} from '../metrics/config'

import MediaError from '../common/errors/media';
import ParameterError from '../common/errors/parameter';

/**
 * @export
 * @public
 */
const pc = {};

/**
 * munges the bandwidth limit into the sdp
 * @param {String} sdpLines
 * @param {Number} index
 * @returns {String}
 */
const insertBandwidthLimit = (sdpLines, index) => {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser
  let limit;
  if (sdpLines[index].search(AUDIO) !== -1) {
    limit = StaticConfig.meetings.bandwidth.audio;
  } else {
    limit = StaticConfig.meetings.bandwidth.video;
  }
  sdpLines.splice(index + 1, 0, `${SDP.B_LINE}:${limit}`);
  return sdpLines;
};

/**
 * needed for calliope max-fs
 * @param {String} sdp
 * @param {String} [level=QUALITY_LEVELS.HIGH] quality level for max-fs
 * @returns {String}
 */
const setMaxFs = (sdp, level = QUALITY_LEVELS.HIGH) => {
  if (!MAX_FRAMESIZES[level]) {
    throw new ParameterError(`setMaxFs: unable to set max framesize, value for level "${level}" is not defined`)
  }
  // eslint-disable-next-line no-warning-comments
  // TODO convert with sdp parser, no munging
  let replaceSdp = sdp;
  const maxFsLine = `${SDP.MAX_FS}${MAX_FRAMESIZES[level]}`
  replaceSdp = replaceSdp.replace(/(\na=fmtp:(\d+).*level-asymmetry-allowed=1.*)/gi, `$1;${maxFsLine}`)
  return replaceSdp;
};

/**
 * checks that sdp has h264 codec in it
 * @param {String} sdp
 * @returns {boolean}
 */
const checkH264Support = (sdp) => {
  // eslint-disable-next-line no-warning-comments
  // TODO convert to sdp parser to read rtp.codec
  const videoPresent = sdp.match(/\nm=video.*/g);
  const h264Present = sdp.match(/\na=rtpmap:\d+\sH264.*/g);
  if (videoPresent) {
    return !!h264Present;
  }
  return true;
};

/**
 * validates the sdp, checks port, candidates, and ice info
 * @param {String} sdp
 * @returns {Boolean}
 */
const validateSdp = (sdp) => {
  const parsedSdp = sdpTransform.parse(sdp);
  parsedSdp.media.forEach((mediaLine) => {
    if (mediaLine.candidates && mediaLine.candidates.length === 0) {
      LoggerProxy.logger.error('PeerConnectionManager->validateSdp#iceCandidate: Ice candadate never completed');
      return false;
    }
    if (SDP.BAD_MEDIA_PORTS.includes(mediaLine.port)) {
      LoggerProxy.logger.error('PeerConnectionManager->validateSdp#iceCandidate: Found invalid port number for the ice candidate');
      return false;
    }
    if (!mediaLine.icePwd || !mediaLine.iceUfrag) {
      LoggerProxy.logger.error('PeerConnectionManager->validateSdp#iceCandidate: ice ufrag and password not found');
      return false;
    }
    return true;
  });
};

/**
 * munges the bandwidth into the sdp
 * @param {String} sdp
 * @returns {String}
 */
const limitBandwidth = (sdp) => {
  // TODO convert to sdp parser
  let offerSdp = sdp;
  let sdpLines = offerSdp.split(SDP.CARRIAGE_RETURN);

  for (let i = 0; i < sdpLines.length; i += 1) {
    if (sdpLines[i].search(SDP.M_LINE) !== -1) {
      sdpLines = insertBandwidthLimit(sdpLines, i);
    }
  }
  offerSdp = sdpLines.join(SDP.CARRIAGE_RETURN);
  return offerSdp;
};

/**
 * sets up a listener for ice fails mid meeting
 * @param {RTCPeerConnection} peerConnection
 * @param {Function} fn
 * @param {Function} name - the name for logging, on the transceiver
 * @returns {undefined}
 */
pc.iceFailListener = (peerConnection, fn, name) => {
  if (!peerConnection) {
    return;
  }
  peerConnection.oniceconnectionstatechange = () => {
    switch (peerConnection.iceConnectionState) {
      case ICE_STATE.FAILED:
      case ICE_STATE.DISCONNECTED:
        LoggerProxy.logger.warn(`PeerConnectionManager->oniceconnectionstatechange#${name} Interactive Connectivity Establishment(ICE)${peerConnection.iceConnectionState} at ${new Date()}`);
        setTimeout(() => {
          switch (peerConnection.iceConnectionState) {
            case ICE_STATE.FAILED:
            case ICE_STATE.DISCONNECTED:
              // if ice is still failed after some time, do the reconnect
              // else the browser resolves the ice failure on its own
              fn();
              break;
            default:
            break;
          }
        }, ICE_FAIL_TIMEOUT);
        break;
      default:
        break;
    }
  };
};

/**
 * waits for failures and calls the reconnect function on failures
 * @param {RTCPeerConnection} peerConnection
 * @param {Function} [reconnectFn] - if not included, just prints a log
 * @returns {undefined}
 */
pc.detectFailures = (peerConnection, reconnectFn = () => {LoggerProxy.logger.error('PeerConnectionManager->reconnectFn#Ice failed, no function to reconnect with.')}) => {
  peerConnection.iceFailListener(peerConnection, reconnectFn, MEDIA_PEER_CONNECTION_NAME);
};

/**
 * makes sure the screen pc sdp has content:slides for server
 * @param {RTCPeerConnection} screenPC
 * @returns {RTCPeerConnection}
 */
pc.setContentSlides = (screenPc) => {
  if (screenPc && screenPc.sdp) {
    screenPc.sdp += `${SDP.A_CONTENT_SLIDES}${SDP.CARRIAGE_RETURN}`;
  }
  return screenPc;
};

/**
 * handles ice trickling and establishes ICE connection onto peer connection object
 * @param {Object} peerConnection
 * @param {Object} options
 * @param {String} options.remoteQualityLevel
 * @returns {RTCPeerConnection}
 */
pc.iceCandidate = (peerConnection, {remoteQualityLevel}) =>
  new Promise((resolve) => {
    // TODO: we dont need timeout as we can check the api state and validate.
    const timeout = setTimeout(() => {
      peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
      peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
      peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

      if (!validateSdp(peerConnection.sdp)) {
        setTimeout(() => {
          resolve(peerConnection);
        }, RETRY_TIMEOUT);
      } else {
        resolve(peerConnection);
      }
    }, ICE_TIMEOUT);

    peerConnection.onicecandidate = (evt) => {
      if (!evt.candidate && !peerConnection.sdp) {
        peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
        peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
        peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

        if (evt.candidate === null) {
          validateSdp(peerConnection.sdp);
          clearTimeout(timeout);
          resolve(peerConnection);
        }
      }
    };
  });

/**
 * swapping tracks
 * @param {Object} peerConnection
 * @param {Object} track
 * @returns {undefined}
 */
pc.replaceTrack = (peerConnection, track) => {
  try {
    const senders = peerConnection.getSenders();
    if (senders.length > 0) {
      senders.forEach((sender) => {
        if (sender.track && sender.track.kind === track.kind) {
          sender.replaceTrack(track);
        }
      });
    }
  } catch (err) {
    LoggerProxy.logger.error(`PeerConnectionManager->replaceTrack#Error replacing track, ${err}`);
  }
};

/**
 * adding streams to peerConnection
 * @param {Object} peerConnection
 * @param {Object} stream
 * @returns {undefined}
 */
pc.addStream = (peerConnection, stream) => {
  try {
    if (stream && !bowser.msedge) {
      const tracksPresent = peerConnection.getSenders && peerConnection.getSenders().find((sender) => sender.track != null);
      if (tracksPresent) {
        stream.getTracks().forEach((track) => {
          pc.replaceTrack(peerConnection, track);
        });
        return;
      }
      stream.getTracks().forEach((track) => {
        peerConnection.addTrack(track, stream);
      });
      // // TODO : may come back disable addTracks for chrome they are moving back to addStream
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=764414
      // // https://bugs.chromium.org/p/chromium/issues/detail?id=738918#c7
      //   peerConnection.addStream(stream);
    } else if (bowser.msedge) {
      peerConnection.addStream(stream);
    } else {
    }
  } catch (err) {
    LoggerProxy.logger.error(`peer-connection-manager->addStream#Error adding stream, error: ${error}`);
  }
};

/**
 * setting the remote description
 * @param {Object} peerConnection
 * @param {String} typeStr
 * @param {String} remoteSdp
 * @param {String} meetingId
 * @returns {undefined}
 */
pc.setRemoteSessionDetails = (peerConnection, typeStr, remoteSdp, meetingId) => {
  LoggerProxy.logger.log(`PeerConnectionManager->setRemoteSessionDetails#Setting the remote description type: ${typeStr}State: ${peerConnection.signalingState}`);
  let sdp = remoteSdp;

  sdp = sdp.replace(/\na=extmap.*/g, '');

  // making sure that the remoteDescription is only set when there is a answer for offer
  // or there is a offer from the server

  if(!sdp) {
    Metrics.postEvent({
      event: eventType.REMOTE_SDP_RECEIVED,
      meetingId: meetingId, data: {
      canProceed: false,
      errors: [Metrics.generateErrorPayload(2001, true,
        error.name.MEDIA_ENGINE, 'missing remoteSdp')]
    }})
  }
  if (peerConnection.signalingState === SDP.HAVE_LOCAL_OFFER || (peerConnection.signalingState === SDP.STABLE && typeStr === SDP.OFFER)) {
    return peerConnection.setRemoteDescription(
        new window.RTCSessionDescription({
          type: typeStr,
          sdp
        })
      )
      .then(() => Metrics.postEvent({
        event: eventType.REMOTE_SDP_RECEIVED,
        meetingId: meetingId}))
      .catch((error) => Metrics.postEvent({
        event: eventType.REMOTE_SDP_RECEIVED,
        meetingId: meetingId,
        data: {
          canProceed: false,
          errors: [Metrics.generateErrorPayload(2001, true,
          error.name.MEDIA_ENGINE, 'missing remoteSdp')]
      }}))
  }

    return Promise.reject(new MediaError('PeerConnection in wrong state'));
};

/**
 * create offer with a valid paramater
 * @param {Object} params
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {RTCPeerConnection}
 */
pc.createOffer = (peerConnection, {meetingId, remoteQualityLevel}) => {
  LoggerProxy.logger.log('PeerConnectionManager->createOffer#createOffer: creating a new offer');

  try {
    return peerConnection
      .createOffer()
      .then((description) => {
        // bug https://bugs.chromium.org/p/chromium/issues/detail?id=1020642
        // chrome currently generates RTX line irrespective of weither the server side supports it
        // we are removing apt as well because its associated with rtx line

        description.sdp = description.sdp.replace(/\r\na=rtpmap:\d+ rtx\/\d+/g, '');
        description.sdp = description.sdp.replace(/\r\na=fmtp:\d+ apt=\d+/g, '');
        peerConnection.setLocalDescription(description)
      })
      .then(() => pc.iceCandidate(peerConnection, {remoteQualityLevel}))
      .then(() => {
        peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
        peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
        if (!checkH264Support(peerConnection.sdp)) {
          throw new MediaError('openH264 is downloading please Wait. Upload logs if not working on second try');
        }
        peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');
        pc.setContentSlides(peerConnection);

        Metrics.postEvent({
          event: eventType.LOCAL_SDP_GENERATED,
          meetingId
        });
        return peerConnection;
      })
      .catch((err) => {
        Metrics.postEvent({
          event: eventType.LOCAL_SDP_GENERATED,
          meetingId,
          data: {
            canProceed: false,
             errors: [
               Metrics.generateErrorPayload(2001, true,
              error.name.MEDIA_ENGINE)]
        }});
        pc.close(peerConnection);
        throw err;
      });
  } catch (err) {
    throw err;
  }
};

/**
 * rollBack local description in peerconnection
 * @param {Object} peerConnection
 * @returns {RTCPeerConnection}
 */
pc.rollBackLocalDescription = (peerConnection) => {
  return peerConnection
    .setLocalDescription(new RTCSessionDescription({type: SDP.ROLLBACK}))
    .then(() => peerConnection)
    .catch((err) => {
      return Promise.error(err);
    });
};

/**
 * @param {Object} params {
 * @param {Boolean} params.offerToReceiveAudio
 * @param {Boolean} params.offerToReceiveVideo
 * @param {string} params.offerSdp
 * @param {MediaStream} params.stream
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {Promise.<Array>} [MediaSDP, ScreenSDP]
 */
pc.updatePeerConnection = (params, {meetingId, remoteQualityLevel}) => {
  LoggerProxy.logger.log(`PeerConnectionManager->updatePeerConnection#updating the peerConnection with params: ${params}`);

  const {peerConnection, offerSdp} = params;

  return pc.createAnswer({
    peerConnection,
      offerSdp: offerSdp[0]
    }, {meetingId, remoteQualityLevel}).then((peerconnection) => {
      // The content slides should also be set when we are sending inactive
      pc.setContentSlides(peerconnection);
    return Promise.resolve([peerconnection.sdp]);
  });
};

/**
 * @param {Object} params
 * @param {Object} params.peerConnection
 * @param {Object} params.sdpConstraints
 * @param {Object} meetingProperties
 * @param {string} meetingProperties.meetingId
 * @param {string} meetingProperties.remoteQualityLevel LOW|MEDIUM|HIGH
 * @returns {RTCPeerConnection} peerConnection
 */
pc.createAnswer = (params, {meetingId, remoteQualityLevel}) => {
  const {peerConnection} = params;

  // TODO: Some times to many mercury event comes at the same time
  // Need to maintain state of peerconnection
  if (peerConnection.signalingState === SDP.HAVE_REMOTE_OFFER) {
    return Promise.resolve(peerConnection);
  }

  return pc.setRemoteSessionDetails(peerConnection, OFFER, params.offerSdp, meetingId)
    .then(() => peerConnection.createAnswer(params.sdpConstraints))
    .then((answer) =>
      //   if (edonusHack()) {
      //     answer.sdp = answer.sdp.replace(/recvonly.*/g, 'sendrecv');
      //   }
      peerConnection.setLocalDescription(answer)
    )
    .then(() => pc.iceCandidate(peerConnection, {remoteQualityLevel}))
    .then(() => {
      peerConnection.sdp = limitBandwidth(peerConnection.localDescription.sdp);
      peerConnection.sdp = setMaxFs(peerConnection.sdp, remoteQualityLevel);
      if (!checkH264Support(peerConnection.sdp)) {
        throw new MediaError('openH264 is downloading please Wait. Upload logs if not working on second try');
      }

      peerConnection.sdp = peerConnection.sdp.replace(/\na=extmap.*/g, '');

      return peerConnection;
    })
    .catch((err) => {
      LoggerProxy.logger.error(`peer-connection-manager->setRemoteSessionDetails#Error creating remote session, error: ${error}`);
    });
};

/**
 * shut down the peer connection
 * @param {Object} peerConnection
 * @returns {undefined}
 */
pc.close = (peerConnection) => {
  // peerConnection.close() fails on firefox on network changes and gives a Dom exception
  // To avoid this we have added a try catch block.
  // Please refer to https://bugzilla.mozilla.org/show_bug.cgi?id=1274407 for more information

  if(peerConnection && peerConnection.connectionState === PEER_CONNECTION_STATE.CLOSED) {
    return Promise.resolve();
  }
  LoggerProxy.logger.log('PeerConnectionManager->close#pc: close() -> closing the mediaPeerConnection');
  return Promise.resolve()
    .then(() => {
      if (peerConnection && peerConnection.close) {
        peerConnection.close();
      }
    });
};

export default pc;
