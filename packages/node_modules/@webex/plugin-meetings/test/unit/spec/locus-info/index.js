import sinon from 'sinon';
import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import Meetings from '@webex/plugin-meetings';
import LocusInfo from '@webex/plugin-meetings/src/locus-info';
import SelfUtils from '@webex/plugin-meetings/src/locus-info/selfUtils';

import {LOCUSINFO, RECORDING_STATE} from '../../../../src/constants';

import {self, selfWithInactivity} from './selfConstant';


describe('plugin-meetings', () => {
  describe('LocusInfo index', () => {
    const updateMeeting = () => {};
    const locus = {};
    const meetingId = 'meedingId';
    let locusInfo;

    const webex = new MockWebex({
      children: {
        meetings: Meetings
      }
    });

    beforeEach(() => {
      locusInfo = new LocusInfo(
        updateMeeting, webex, meetingId
      );

      locusInfo.init(locus);

      locusInfo.parsedLocus = {
        states: [{one: 'one'}],
        fullState: {type: 'MEETING'},
        info: {sipUri: 'abc@webex.com'}
      };
    });

    describe('#updateControls', () => {
      let newControls;

      beforeEach('setup new controls', () => {
        newControls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
      });

      afterEach(() => {
        newControls = null;
      });

      it('should update the controls object', () => {
        locusInfo.updateControls(newControls);

        assert.equal(locusInfo.controls, newControls);
      });

      it('should keep the recording state to `IDLE`', () => {
        locusInfo.controls = {
          record: {
            recording: true,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.IDLE,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `RECORDING`', () => {
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.recording = true;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.RECORDING,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `PAUSED`', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.paused = true;
        newControls.record.recording = true;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.PAUSED,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `RESUMED`', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: true,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        // there must be a recording to be paused/resumed
        newControls.record.recording = true;
        newControls.record.paused = false;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.RESUMED,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `IDLE` even if `pause`status changes', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: true,
            paused: true,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.recording = false;
        newControls.record.paused = false;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.IDLE,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });
    });

    describe('#updateParticipants()', () => {
      let newParticipants;

      beforeEach('setup new participants', () => {
        newParticipants = [
          {
            person: {
              id: 1234
            },
            status: {
              audioStatus: 'testValue',
              videoSlidesStatus: 'testValue',
              videoStatus: 'testValue'
            }
          }
        ];
      });

      it('should update the deltaParticipants object', () => {
        const prev = locusInfo.deltaParticipants;

        locusInfo.updateParticipantDeltas(newParticipants);

        assert.notEqual(locusInfo.deltaParticipants, prev);
      });

      it('should update the delta property on all changed states', () => {
        locusInfo.updateParticipantDeltas(newParticipants);

        const [exampleParticipant] = locusInfo.deltaParticipants;

        assert.isTrue(exampleParticipant.delta.audioStatus);
        assert.isTrue(exampleParticipant.delta.videoSlidesStatus);
        assert.isTrue(exampleParticipant.delta.videoStatus);
      });

      it('should include the person details of the changed participant', () => {
        locusInfo.updateParticipantDeltas(newParticipants);

        const [exampleParticipant] = locusInfo.deltaParticipants;

        assert.equal(exampleParticipant.person, newParticipants[0].person);
      });

      it('should clear deltaParticipants when no changes occured', () => {
        locusInfo.participants = [...newParticipants];

        locusInfo.updateParticipantDeltas(locusInfo.participants);

        assert.isTrue(locusInfo.deltaParticipants.length === 0);
      });
    });

    describe('#updateSelf', () => {
      it('should trigger MEDIA_INACTIVITY on server media inactivity', () => {
        locusInfo.self = self;

        locusInfo.webex.internal.device.url = selfWithInactivity.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithInactivity, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.MEDIA_INACTIVITY,
        SelfUtils.getMediaStatus(selfWithInactivity.mediaSessions));
      });

      it('should trigger SELF_MUTED_BY_OTHERS on othersMuted', () => {
        // TODO: rewrite this similar to above one
        SelfUtils.getSelves = sinon.stub().returns({
          current: {state: 'JOINED'},
          updates: {
            isMutedByOthers: true
          }
        });

        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(self, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_MUTED_BY_OTHERS,
        self);
      });
    });
  });
});
