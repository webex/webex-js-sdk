import sinon from 'sinon';
import {cloneDeep} from 'lodash';
import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import Meetings from '@webex/plugin-meetings';
import LocusInfo from '@webex/plugin-meetings/src/locus-info';
import SelfUtils from '@webex/plugin-meetings/src/locus-info/selfUtils';
import LocusDeltaParser from '@webex/plugin-meetings/src/locus-info/parser';

import {
  LOCUSINFO,
  RECORDING_STATE,
  LOCUSEVENT,
  EVENTS
} from '../../../../src/constants';

import {self, selfWithInactivity} from './selfConstant';


describe('plugin-meetings', () => {
  describe('LocusInfo index', () => {
    const updateMeeting = () => {};
    const locus = {};
    const meetingId = 'meedingId';
    let locusInfo;

    const webex = new MockWebex({
      children: {
        meetings: Meetings
      }
    });

    beforeEach(() => {
      locusInfo = new LocusInfo(
        updateMeeting, webex, meetingId
      );

      locusInfo.init(locus);

      locusInfo.parsedLocus = {
        states: [{one: 'one'}],
        fullState: {type: 'MEETING'},
        info: {
          sipUri: 'abc@webex.com',
          isUnlocked: true,
          isLocked: false,
          displayHints: {
            joined: ['ROSTER_IN_MEETING', 'LOCK_STATUS_UNLOCKED'],
            moderator: []
          }
        }
      };
    });

    describe('#updateControls', () => {
      let newControls;

      beforeEach('setup new controls', () => {
        newControls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
      });

      afterEach(() => {
        newControls = null;
      });

      it('should update the controls object', () => {
        locusInfo.updateControls(newControls);

        assert.equal(locusInfo.controls, newControls);
      });

      it('should not trigger the CONTROLS_RECORDING_UPDATED event', () => {
        locusInfo.controls = {};
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateControls(newControls);

        locusInfo.emitScoped.getCalls().forEach((x) => {
          // check that no calls in emitScoped are for CONTROLS_RECORDING_UPDATED
          assert.notEqual(x.args[1], LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED);
        });
      });

      it('should keep the recording state to `IDLE`', () => {
        locusInfo.controls = {
          record: {
            recording: true,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.IDLE,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `RECORDING`', () => {
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.recording = true;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.RECORDING,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `PAUSED`', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: false,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.paused = true;
        newControls.record.recording = true;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.PAUSED,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `RESUMED`', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: false,
            paused: true,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        // there must be a recording to be paused/resumed
        newControls.record.recording = true;
        newControls.record.paused = false;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.RESUMED,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });

      it('should update the recording state to `IDLE` even if `pause`status changes', () => {
        locusInfo.emitScoped = sinon.stub();
        locusInfo.controls = {
          lock: {},
          meetingFull: {},
          record: {
            recording: true,
            paused: true,
            meta: {
              lastModified: 'TODAY',
              modifiedBy: 'George Kittle'
            }
          },
          shareControl: {},
          transcribe: {}
        };
        newControls.record.recording = false;
        newControls.record.paused = false;
        locusInfo.updateControls(newControls);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateControls'
        },
        LOCUSINFO.EVENTS.CONTROLS_RECORDING_UPDATED,
        {
          state: RECORDING_STATE.IDLE,
          modifiedBy: 'George Kittle',
          lastModified: 'TODAY'
        });
      });
    });

    describe('#updateParticipants()', () => {
      let newParticipants;

      beforeEach('setup new participants', () => {
        newParticipants = [
          {
            person: {
              id: 1234
            },
            status: {
              audioStatus: 'testValue',
              videoSlidesStatus: 'testValue',
              videoStatus: 'testValue'
            }
          }
        ];
      });

      it('should assert that the correct recordingId, selfIdentity, selfId, and hostId are being set and emitted from updateParticipants', () => {
        locusInfo.parsedLocus = {
          controls: {
            record: {
              modifiedBy: '1'
            }
          },
          self: {
            selfIdentity: '123',
            selfId: '2'
          },
          host: {
            hostId: '3'
          }
        };
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateParticipants({});

        // if this assertion fails, double-check the attributes used in
        // the updateParticipants function in locus-info/index.js
        assert.calledWith(locusInfo.emitScoped,
          {
            file: 'locus-info',
            function: 'updateParticipants'
          },
          EVENTS.LOCUS_INFO_UPDATE_PARTICIPANTS,
          {
            participants: {},
            recordingId: '1',
            selfIdentity: '123',
            selfId: '2',
            hostId: '3'
          });
        // note: in a real use case, recordingId, selfId, and hostId would all be the same
        // for this specific test, we are double-checking that each of the id's
        // are being correctly grabbed from locusInfo.parsedLocus within updateParticipants
      });

      it('should update the deltaParticipants object', () => {
        const prev = locusInfo.deltaParticipants;

        locusInfo.updateParticipantDeltas(newParticipants);

        assert.notEqual(locusInfo.deltaParticipants, prev);
      });

      it('should update the delta property on all changed states', () => {
        locusInfo.updateParticipantDeltas(newParticipants);

        const [exampleParticipant] = locusInfo.deltaParticipants;

        assert.isTrue(exampleParticipant.delta.audioStatus);
        assert.isTrue(exampleParticipant.delta.videoSlidesStatus);
        assert.isTrue(exampleParticipant.delta.videoStatus);
      });

      it('should include the person details of the changed participant', () => {
        locusInfo.updateParticipantDeltas(newParticipants);

        const [exampleParticipant] = locusInfo.deltaParticipants;

        assert.equal(exampleParticipant.person, newParticipants[0].person);
      });

      it('should clear deltaParticipants when no changes occured', () => {
        locusInfo.participants = [...newParticipants];

        locusInfo.updateParticipantDeltas(locusInfo.participants);

        assert.isTrue(locusInfo.deltaParticipants.length === 0);
      });
    });

    describe('#updateSelf', () => {
      it('should trigger MEDIA_INACTIVITY on server media inactivity', () => {
        locusInfo.self = self;

        locusInfo.webex.internal.device.url = selfWithInactivity.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithInactivity, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.MEDIA_INACTIVITY,
        SelfUtils.getMediaStatus(selfWithInactivity.mediaSessions));
      });

      it('should trigger SELF_REMOTE_MUTE_STATUS_UPDATED when muted on entry', () => {
        // usually "previous self" is just undefined when we get first self from locus with remote mute
        locusInfo.self = undefined;
        const selfWithMutedByOthers = cloneDeep(self);

        selfWithMutedByOthers.controls.audio.muted = true;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithMutedByOthers, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED,
        {muted: true, unmuteAllowed: true});

        // but sometimes "previous self" is defined, but without controls.audio.muted, so we test this here:
        locusInfo.self = cloneDeep(self);
        locusInfo.self.controls.audio = {};

        locusInfo.updateSelf(selfWithMutedByOthers, []);
        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED,
        {muted: true, unmuteAllowed: true});
      });

      it('should not trigger SELF_REMOTE_MUTE_STATUS_UPDATED when not muted on entry', () => {
        locusInfo.self = undefined;
        const selfWithMutedByOthersFalse = cloneDeep(self);

        selfWithMutedByOthersFalse.controls.audio.muted = false;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithMutedByOthersFalse, []);

        // we might get some calls to emitScoped, but we need to check that none of them are for SELF_REMOTE_MUTE_STATUS_UPDATED
        locusInfo.emitScoped.getCalls().forEach((x) => {
          assert.notEqual(x.args[1], LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED);
        });
      });

      it('should not trigger SELF_REMOTE_MUTE_STATUS_UPDATED when being removed from meeting', () => {
        const selfWithMutedByOthers = cloneDeep(self);

        selfWithMutedByOthers.controls.audio.muted = true;

        locusInfo.self = selfWithMutedByOthers;

        // when user gets removed from meeting we receive a Locus DTO without any self.controls
        const selfWithoutControls = cloneDeep(self);

        selfWithoutControls.controls = undefined;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithoutControls, []);

        // we might get some calls to emitScoped, but we need to check that none of them are for SELF_REMOTE_MUTE_STATUS_UPDATED
        locusInfo.emitScoped.getCalls().forEach((x) => {
          assert.notEqual(x.args[1], LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED);
        });
      });

      it('should trigger SELF_REMOTE_MUTE_STATUS_UPDATED on othersMuted', () => {
        locusInfo.self = self;
        const selfWithMutedByOthers = cloneDeep(self);

        selfWithMutedByOthers.controls.audio.muted = true;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithMutedByOthers, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED,
        {muted: true, unmuteAllowed: true});
      });

      it('should trigger SELF_REMOTE_MUTE_STATUS_UPDATED if muted and disallowUnmute changed', () => {
        locusInfo.self = self;
        const selfWithMutedByOthersAndDissalowUnmute = cloneDeep(self);

        // first simulate remote mute
        selfWithMutedByOthersAndDissalowUnmute.controls.audio.muted = true;
        selfWithMutedByOthersAndDissalowUnmute.controls.audio.disallowUnmute = true;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithMutedByOthersAndDissalowUnmute, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED,
        {muted: true, unmuteAllowed: false});

        // now change only disallowUnmute
        const selfWithMutedByOthers = cloneDeep(self);

        selfWithMutedByOthers.controls.audio.muted = true;
        selfWithMutedByOthers.controls.audio.disallowUnmute = false;

        locusInfo.updateSelf(selfWithMutedByOthers, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.SELF_REMOTE_MUTE_STATUS_UPDATED,
        {muted: true, unmuteAllowed: true});
      });

      it('should trigger LOCAL_UNMUTE_REQUIRED on localAudioUnmuteRequired', () => {
        locusInfo.self = self;
        const selfWithLocalUnmuteRequired = cloneDeep(self);

        selfWithLocalUnmuteRequired.controls.audio.muted = false;
        selfWithLocalUnmuteRequired.controls.audio.localAudioUnmuteRequired = true;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithLocalUnmuteRequired, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUIRED,
        {
          muted: false,
          unmuteAllowed: true
        });
      });

      it('should trigger LOCAL_UNMUTE_REQUESTED when receiving requestedToUnmute=true', () => {
        locusInfo.self = self;
        const selfWithRequestedToUnmute = cloneDeep(self);

        selfWithRequestedToUnmute.controls.audio.requestedToUnmute = true;

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateSelf(selfWithRequestedToUnmute, []);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED,
        {});

        // now change requestedToUnmute back to false -> it should NOT trigger LOCAL_UNMUTE_REQUESTED
        const selfWithoutRequestedToUnmute = cloneDeep(selfWithRequestedToUnmute);

        selfWithoutRequestedToUnmute.controls.audio.requestedToUnmute = false;

        locusInfo.emitScoped.resetHistory();
        locusInfo.updateSelf(selfWithoutRequestedToUnmute, []);

        assert.neverCalledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateSelf'
        },
        LOCUSINFO.EVENTS.LOCAL_UNMUTE_REQUESTED,
        {});
      });
    });

    describe('#updateMeetingInfo', () => {
      let meetingInfo;

      beforeEach('setup meeting info', () => {
        meetingInfo = {
          displayHints: {
            joined: ['ROSTER_IN_MEETING', 'LOCK_STATUS_UNLOCKED'],
            moderator: []
          }
        };
      });


      it('should trigger MEETING_LOCKED/UNLOCKED when meeting gets locked/unlocked', () => {
        const meetingInfoLocked = cloneDeep(meetingInfo);

        const idx = meetingInfoLocked.displayHints.joined.indexOf('LOCK_STATUS_UNLOCKED');

        if (idx !== -1) {
          meetingInfoLocked.displayHints.joined[idx] = 'LOCK_STATUS_LOCKED';
        }

        locusInfo.webex.internal.device.url = self.deviceUrl;
        locusInfo.emitScoped = sinon.stub();
        locusInfo.updateMeetingInfo(meetingInfoLocked, self);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateMeetingInfo'
        },
        LOCUSINFO.EVENTS.MEETING_LOCKED,
        meetingInfoLocked);

        // now unlock the meeting and verify that we get the right event
        const meetingInfoUnlocked = cloneDeep(meetingInfo); // meetingInfo already is "unlocked"

        locusInfo.updateMeetingInfo(meetingInfoUnlocked, self);

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'updateMeetingInfo'
        },
        LOCUSINFO.EVENTS.MEETING_UNLOCKED,
        meetingInfoUnlocked);
      });
    });

    describe('#LocusDeltaEvents', () => {
      const fakeMeeting = 'fakeMeeting';
      let sandbox = null;
      let locusParser = null;
      let fakeLocus = null;

      beforeEach(() => {
        locusParser = locusInfo.locusParser;
        sandbox = sinon.createSandbox();

        fakeLocus = {
          meeting: true,
          participants: true
        };
      });

      afterEach(() => {
        sandbox.restore();
        sandbox = null;
      });


      it('handles locus delta events', () => {
        sandbox.stub(locusInfo, 'handleLocusDelta');

        const data = {
          eventType: LOCUSEVENT.DIFFERENCE,
          locus: fakeLocus
        };

        locusInfo.parse(fakeMeeting, data);

        assert.calledWith(locusInfo.handleLocusDelta, fakeLocus, fakeMeeting);
      });


      it('should queue delta event with internal locus parser', () => {
        sandbox.stub(locusParser, 'onDeltaEvent');

        const data = {
          eventType: LOCUSEVENT.DIFFERENCE,
          locus: fakeLocus
        };

        locusInfo.parse(fakeMeeting, data);

        // queues locus delta event
        assert.calledWith(locusParser.onDeltaEvent, fakeLocus);
      });


      it('should assign a function to onDeltaAction', () => {
        sandbox.stub(locusParser, 'onDeltaEvent');
        assert.isNull(locusParser.onDeltaAction);

        locusInfo.handleLocusDelta(fakeLocus, fakeMeeting);

        assert.isFunction(locusParser.onDeltaAction);
      });


      it('onFullLocus() updates the working-copy of locus parser', () => {
        const eventType = 'fakeEvent';

        sandbox.stub(locusInfo, 'updateParticipantDeltas');
        sandbox.stub(locusInfo, 'updateLocusInfo');
        sandbox.stub(locusInfo, 'updateParticipants');
        sandbox.stub(locusInfo, 'isMeetingActive');
        sandbox.stub(locusInfo, 'handleOneOnOneEvent');

        locusInfo.onFullLocus(fakeLocus, eventType);

        assert.equal(fakeLocus, locusParser.workingCopy);
      });


      it('onDeltaAction applies locus delta data to meeting', () => {
        const action = 'fake action';
        const parsedLoci = 'fake loci';

        sandbox.stub(locusParser, 'onDeltaEvent');
        locusInfo.handleLocusDelta(fakeLocus, fakeMeeting);
        sandbox.spy(locusInfo, 'applyLocusDeltaData');

        locusParser.onDeltaAction(action, parsedLoci);

        assert.calledWith(locusInfo.applyLocusDeltaData, action, parsedLoci, fakeMeeting);
      });


      it('applyLocusDeltaData handles USE_INCOMING action correctly', () => {
        const {USE_INCOMING} = LocusDeltaParser.loci;
        const meeting = {
          locusInfo: {
            onDeltaLocus: sandbox.stub()
          }
        };

        locusInfo.applyLocusDeltaData(USE_INCOMING, fakeLocus, meeting);

        assert.calledWith(meeting.locusInfo.onDeltaLocus, fakeLocus);
      });


      it('applyLocusDeltaData gets full locus on DESYNC action', () => {
        const {DESYNC} = LocusDeltaParser.loci;
        const meeting = {
          meetingRequest: {
            getFullLocus: sandbox.stub().resolves(true)
          },
          locusInfo: {
            onFullLocus: sandbox.stub()
          }
        };

        locusInfo.locusParser.resume = sandbox.stub();
        locusInfo.applyLocusDeltaData(DESYNC, fakeLocus, meeting);

        assert.calledOnce(meeting.meetingRequest.getFullLocus);
      });

      it('getFullLocus handles DESYNC action correctly', () => {
        const {DESYNC} = LocusDeltaParser.loci;
        const meeting = {
          meetingRequest: {
            getFullLocus: sandbox.stub().resolves({body: true})
          },
          locusInfo
        };

        locusInfo.onFullLocus = sandbox.stub();

        // Since we have a promise inside a function we want to test that's not returned,
        // we will wait and stub it's last function to resolve this waiting promise.
        // Also ensures .onFullLocus() is called before .resume()
        return new Promise((resolve) => {
          locusInfo.locusParser.resume = sandbox.stub().callsFake(() => resolve());
          locusInfo.applyLocusDeltaData(DESYNC, fakeLocus, meeting);
        }).then(() => {
          assert.calledOnce(meeting.locusInfo.onFullLocus);
          assert.calledOnce(locusInfo.locusParser.resume);
        });
      });
    });

    describe('#handleOneonOneEvent', () => {
      beforeEach(() => {
        locusInfo.emitScoped = sinon.stub();
      });
      it('emits `REMOTE_RESPONSE`', () => {
        // 'locus.participant_joined'

        locusInfo.parsedLocus.fullState.type = 'SIP_BRIDGE';
        locusInfo.handleOneOnOneEvent('locus.participant_declined');

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'handleOneonOneEvent'
        },
        'REMOTE_RESPONSE',
        {
          remoteDeclined: true,
          remoteAnswered: false
        });


        locusInfo.parsedLocus.fullState.type = 'SIP_BRIDGE';
        locusInfo.handleOneOnOneEvent('locus.participant_joined');

        assert.calledWith(locusInfo.emitScoped, {
          file: 'locus-info',
          function: 'handleOneonOneEvent'
        },
        'REMOTE_RESPONSE',
        {
          remoteDeclined: false,
          remoteAnswered: true
        });
      });
    });
  });
});
