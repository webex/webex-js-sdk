import sinon from 'sinon';
import {assert} from '@webex/test-helper-chai';
import MeetingUtil from '@webex/plugin-meetings/src/meeting/util';
import LoggerProxy from '@webex/plugin-meetings/src/common/logs/logger-proxy';
import LoggerConfig
  from '@webex/plugin-meetings/src/common/logs/logger-config';


describe('plugin-meetings/utils', () => {
  const sandbox = sinon.createSandbox();


  const meeting = {};

  beforeEach(() => {
    const logger = {
      info: sandbox.stub(),
      log: sandbox.stub(),
      error: sandbox.stub(),
      warn: sandbox.stub()
    };

    LoggerConfig.set({
      verboseEvents: true,
      enable: true
    });
    LoggerProxy.set(logger);

    meeting.closeLocalStream = sandbox.stub()
      .returns(Promise.resolve());
    meeting.closeLocalShare = sandbox.stub()
      .returns(Promise.resolve());
    meeting.closeRemoteTracks = sandbox.stub()
      .returns(Promise.resolve());
    meeting.closePeerConnections = sandbox.stub()
      .returns(Promise.resolve());

    meeting.unsetLocalVideoTrack = sandbox.stub();
    meeting.unsetLocalShareTrack = sandbox.stub();
    meeting.unsetRemoteTracks = sandbox.stub();
    meeting.unsetPeerConnections = sandbox.stub();
    meeting.cleanMQAInterval = sandbox.stub();
    meeting.reconnectionManager = {cleanUp: sandbox.stub()};
    meeting.roap = {stop: sandbox.stub()};
  });

  afterEach(() => {
    sandbox.restore();
    console.log('after each');
    // sinon.stub.reset();
  });

  describe('Meeting utils function', () => {
    describe('#cleanup', () => {
      it('do clean up on meeting object', async () => {
        await MeetingUtil.cleanUp(meeting);
        assert.calledOnce(meeting.closeLocalStream);
        assert.calledOnce(meeting.closeLocalStream);
        assert.calledOnce(meeting.closeLocalShare);
        assert.calledOnce(meeting.closeRemoteTracks);
        assert.calledOnce(meeting.closePeerConnections);

        assert.calledOnce(meeting.unsetLocalVideoTrack);
        assert.calledOnce(meeting.unsetLocalShareTrack);
        assert.calledOnce(meeting.unsetRemoteTracks);
        assert.calledOnce(meeting.unsetPeerConnections);
        assert.calledOnce(meeting.cleanMQAInterval);
        assert.calledOnce(meeting.reconnectionManager.cleanUp);
        assert.calledOnce(meeting.roap.stop);
      });
    });

    describe('logging', () => {
      const fakeDevice = sinon.fake.returns({
        deviceId: 'device-1'
      });

      const mockTrack = {
        getSettings: fakeDevice
      };

      it('#log - should log [info, warn, error, log] to console', () => {
        LoggerProxy.logger.log('test log');
        assert.calledOnce(LoggerProxy.logger.log);

        LoggerProxy.logger.info('test info');
        assert.calledOnce(LoggerProxy.logger.info);

        LoggerProxy.logger.error('test error');
        assert.calledOnce(LoggerProxy.logger.error);

        LoggerProxy.logger.warn('test warn');
        assert.calledOnce(LoggerProxy.logger.warn);
      });

      describe('#handleAudioLogging', () => {
        it('should not log if called without track', () => {
          MeetingUtil.handleAudioLogging();
          assert(!LoggerProxy.logger.log.called, 'log not called');
        });

        it('should log audioTrack settings', () => {
          assert(MeetingUtil.handleAudioLogging, 'method is defined');
          MeetingUtil.handleAudioLogging(mockTrack);
          assert(LoggerProxy.logger.log.called, 'log called');
        });
      });

      describe('#handleVideoLogging', () => {
        it('should not log if called without track', () => {
          MeetingUtil.handleVideoLogging(null);
          assert(!LoggerProxy.logger.log.called, 'log not called');
        });

        it('should log videoTrack settings', () => {
          assert(MeetingUtil.handleVideoLogging, 'method is defined');
          MeetingUtil.handleVideoLogging(mockTrack);
          assert(LoggerProxy.logger.log.called, 'log called');
        });
      });

      describe('#handleDeviceLogging', () => {
        it('should not log if called without devices', () => {
          MeetingUtil.handleDeviceLogging();
          assert(!LoggerProxy.logger.log.called, 'log not called');
        });

        it('should log device settings', () => {
          const mockDevices = [
            {deviceId: 'device-1'},
            {deviceId: 'device-2'}
          ];

          assert(MeetingUtil.handleDeviceLogging, 'is defined');
          MeetingUtil.handleDeviceLogging(mockDevices);
          assert(LoggerProxy.logger.log.called, 'log called');
        });
      });
    });
  });
});

