/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@webex/test-helper-chai';
import sinon from 'sinon';
import MockWebex from '@webex/test-helper-mock-webex';
import Device from '@webex/internal-plugin-device';
import Mercury from '@webex/internal-plugin-mercury';
import Meetings from '@webex/plugin-meetings/src/meetings';
import {
  _MEETING_ID_,
  _PERSONAL_ROOM_
} from '@webex/plugin-meetings/src/constants';
import MeetingInfo, {MeetingInfoV2PasswordError, MeetingInfoV2CaptchaError} from '@webex/plugin-meetings/src/meeting-info/meeting-info-v2';
import MeetingInfoUtil from '@webex/plugin-meetings/src/meeting-info/utilv2';

describe('plugin-meetings', () => {
  let webex;
  let meetingInfo = null;

  describe('Meeting Info V2', () => {
    beforeEach(() => {
      webex = new MockWebex({
        children: {
          device: Device,
          mercury: Mercury,
          meetings: Meetings
        }
      });

      Object.assign(webex.internal, {
        device: {
          deviceType: 'FAKE_DEVICE',
          register: sinon.stub().returns(Promise.resolve()),
          unregister: sinon.stub().returns(Promise.resolve()),
          userId: '01824b9b-adef-4b10-b5c1-8a2fe2fb7c0e'
        },
        mercury: {
          connect: sinon.stub().returns(Promise.resolve()),
          disconnect: sinon.stub().returns(Promise.resolve()),
          on: () => {},
          off: () => {}
        }
      });


      meetingInfo = new MeetingInfo(webex);
    });

    describe('#fetchMeetingInfo', () => {
      it('should fetch meeting info for the destination type', async () => {
        sinon.stub(MeetingInfoUtil, 'getDestinationType').returns(Promise.resolve({type: 'MEETING_ID', destination: '123456'}));
        sinon.stub(MeetingInfoUtil, 'getRequestBody').returns(Promise.resolve({meetingKey: '1234323'}));

        await meetingInfo.fetchMeetingInfo({
          type: _MEETING_ID_,
          destination: '1234323'
        });

        assert.calledWith(webex.request, {
          method: 'POST', service: 'webex-appapi-service', resource: 'meetingInfo', body: {meetingKey: '1234323'}
        });

        MeetingInfoUtil.getDestinationType.restore();
        MeetingInfoUtil.getRequestBody.restore();
      });
      it('should fetch meeting info for the personal meeting room  type', async () => {
        sinon.stub(MeetingInfoUtil, 'getDestinationType').returns(Promise.resolve({type: 'MEETING_ID', destination: '123456'}));
        sinon.stub(MeetingInfoUtil, 'getRequestBody').returns(Promise.resolve({meetingKey: '1234323'}));

        await meetingInfo.fetchMeetingInfo({
          type: _PERSONAL_ROOM_
        });

        assert.calledWith(webex.request, {
          method: 'POST', service: 'webex-appapi-service', resource: 'meetingInfo', body: {meetingKey: '1234323'}
        });

        MeetingInfoUtil.getDestinationType.restore();
        MeetingInfoUtil.getRequestBody.restore();
      });

      it('should fetch meeting info with provided password and captcha code', async () => {
        await meetingInfo.fetchMeetingInfo('1234323', _MEETING_ID_, 'abc', {id: '999', code: 'aabbcc11'});

        assert.calledWith(webex.request, {
          method: 'POST',
          service: 'webex-appapi-service',
          resource: 'meetingInfo',
          body: {
            supportHostKey: true,
            meetingKey: '1234323',
            password: 'abc',
            captchaID: '999',
            captchaVerifyCode: 'aabbcc11'
          }
        });
      });

      it('should throw MeetingInfoV2PasswordError for 403 response', async () => {
        const FAKE_MEETING_INFO = {blablabla: 'some_fake_meeting_info'};

        webex.request = sinon.stub().rejects({statusCode: 403, body: {code: 403000, data: {meetingInfo: FAKE_MEETING_INFO}}});

        try {
          await meetingInfo.fetchMeetingInfo('1234323', _MEETING_ID_, 'abc', {id: '999', code: 'aabbcc11'});
          assert.fail('fetchMeetingInfo should have thrown, but has not done that');
        }
        catch (err) {
          assert.instanceOf(err, MeetingInfoV2PasswordError);
          assert.deepEqual(err.meetingInfo, FAKE_MEETING_INFO);
          assert.equal(err.wbxAppApiCode, 403000);
        }
      });

      describe('should throw MeetingInfoV2CaptchaError for 423 response', () => {
        const runTest = async (wbxAppApiCode, expectedIsPasswordRequired) => {
          webex.request = sinon.stub().rejects(
            {
              statusCode: 423,
              body: {
                code: wbxAppApiCode,
                captchaID: 'fake_captcha_id',
                verificationImageURL: 'fake_image_url',
                verificationAudioURL: 'fake_audio_url',
                refreshURL: 'fake_refresh_url'
              }
            }
          );
          try {
            await meetingInfo.fetchMeetingInfo('1234323', _MEETING_ID_, 'abc', {id: '999', code: 'aabbcc11'});
            assert.fail('fetchMeetingInfo should have thrown, but has not done that');
          }
          catch (err) {
            assert.instanceOf(err, MeetingInfoV2CaptchaError);
            assert.deepEqual(err.captchaInfo, {
              captchaId: 'fake_captcha_id',
              verificationImageURL: 'fake_image_url',
              verificationAudioURL: 'fake_audio_url',
              refreshURL: 'fake_refresh_url'
            });
            assert.equal(err.wbxAppApiCode, wbxAppApiCode);
            assert.equal(err.isPasswordRequired, expectedIsPasswordRequired);
          }
        };

        it('should throw MeetingInfoV2CaptchaError for 423 response (wbxappapi code 423005)', async () => {
          await runTest(423005, true);
        });

        it('should throw MeetingInfoV2CaptchaError for 423 response (wbxappapi code 423001)', async () => {
          await runTest(423001, false);
        });
      });
    });
  });
});
