/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import Device from '@ciscospark/internal-plugin-wdm';
import Mercury from '@ciscospark/internal-plugin-mercury';
import Meetings from '@webex/plugin-meetings/src/meetings';
import PersonalMeetingRoom from '@webex/plugin-meetings/src/personal-meeting-room';
import Reachability from '@webex/plugin-meetings/src/reachability';
import MeetingCollection from '@webex/plugin-meetings/src/meetings/collection';
import MeetingsUtil from '@webex/plugin-meetings/src/meetings/util';
import Meeting from '@webex/plugin-meetings/src/meeting';
import uuid from 'uuid';


describe('plugin-meetings', () => {
  let spark;
  let uuid1;
  let url1;
  let test1;
  let test2;
  describe('meetings index', () => {
    beforeEach(() => {
      uuid1 = uuid.v4();
      url1 = `https://example.com/${uuid.v4()}`;
      test1 = `test-${uuid.v4()}`;
      test2 = `test2-${uuid.v4()}`;
      spark = new MockSpark({
        children: {
          device: Device,
          mercury: Mercury,
          meetings: Meetings
        }
      });
    });
    it('has a spark instance with a meetings property', () => {
      assert.exists(spark, 'spark was initialized with children');
      assert.exists(spark.meetings, 'meetings child was set up on the spark instance');
    });
    describe('Public API Contracts', () => {
      describe('gets', () => {
        describe('#getReachability', () => {
          it('should have #getReachability', () => {
            assert.exists(spark.meetings.getReachability);
          });
          describe('before #setReachability', () => {
            it('does not get a reachability instance', () => {
              const reachability = spark.meetings.getReachability();
              assert.notExists(reachability, 'reachability is undefined because #setReachability has not been called');
            });
          });
          describe('after #setReachability', () => {
            beforeEach(() => {
              spark.meetings.setReachability();
              const reachabilityMocker = spark.meetings.getReachability();
              sinon.stub(reachabilityMocker, 'gatherReachability').returns(true);
            });
            it('gets the reachability data instance from spark.meetings', () => {
              const reachability = spark.meetings.getReachability();
              assert.exists(reachability, 'reachability is defined because #setReachability has been called');
              assert.instanceOf(reachability, Reachability, 'should be a reachability instance');
            });
          });
        });
        describe('#getPersonalMeetingRoom', () => {
          it('should have #getPersonalMeetingRoom', () => {
            assert.exists(spark.meetings.getPersonalMeetingRoom);
          });
          it('gets the personal meeting room instance from spark.meetings', () => {
            const personalMeetingRoom = spark.meetings.getPersonalMeetingRoom();
            assert.exists(personalMeetingRoom, 'personal meeting room instance is set up at object creation');
            assert.instanceOf(personalMeetingRoom, PersonalMeetingRoom, 'should be a personal meeting room instance');
          });
        });
        describe('Static shortcut proxy methods', () => {
          describe('MeetingCollection getByKey proxies', () => {
            beforeEach(() => {
              spark.meetings.meetingCollection.getByKey = sinon.stub().returns(true);
            });
            it('should have #getMeetingByType', () => {
              assert.exists(spark.meetings.getMeetingByType);
            });
            describe('#getMeetingByType', () => {
              it('gets the Meeting instance from MeetingCollection using type and value', () => {
                spark.meetings.getMeetingByType(test1, test2);
                assert.calledOnce(spark.meetings.meetingCollection.getByKey);
                assert.calledWith(spark.meetings.meetingCollection.getByKey, test1, test2);
              });
            });
          });
          describe('MeetingCollection getAll proxies', () => {
            beforeEach(() => {
              spark.meetings.meetingCollection.getAll = sinon.stub().returns(true);
            });
            it('should have #getAllMeetings', () => {
              assert.exists(spark.meetings.getAllMeetings);
            });
            describe('#getAllMeetings', () => {
              it('calls MeetingCollection to get all meetings with supplied options', () => {
                spark.meetings.getAllMeetings({test: test1});
                assert.calledOnce(spark.meetings.meetingCollection.getAll);
                assert.calledWith(spark.meetings.meetingCollection.getAll, {test: test1});
              });
            });
          });
        });
      });
      describe('#syncMeetings', () => {
        it('should have #syncMeetings', () => {
          assert.exists(spark.meetings.syncMeetings);
        });
        describe('succesful requests', () => {
          beforeEach(() => {
            spark.meetings.request.getActiveMeetings = sinon.stub().returns(Promise.resolve({loci: [{url: url1}]}));
          });
          describe('when meeting is returned', () => {
            let onFullLocus;
            beforeEach(() => {
              onFullLocus = sinon.stub().returns(true);
              spark.meetings.meetingCollection.getByKey = sinon.stub().returns({locusInfo: {onFullLocus}});
            });
            it('tests the sync meeting calls for existing meeting', async () => {
              await spark.meetings.syncMeetings();
              assert.calledOnce(spark.meetings.request.getActiveMeetings);
              assert.calledOnce(spark.meetings.meetingCollection.getByKey);
              assert.calledOnce(onFullLocus);
              assert.calledWith(spark.meetings.request.getActiveMeetings);
              assert.calledWith(spark.meetings.meetingCollection.getByKey, 'locusUrl', url1);
              assert.calledWith(onFullLocus, {url: url1});
            });
          });
          describe('when meeting is not returned', () => {
            let initialSetup;
            beforeEach(() => {
              initialSetup = sinon.stub().returns(true);
              spark.meetings.meetingCollection.getByKey = sinon.stub().returns(null);
              spark.meetings.create = sinon.stub().returns(Promise.resolve({locusInfo: {initialSetup}}));
            });
            it('tests the sync meeting calls for not existing meeting', async () => {
              await spark.meetings.syncMeetings();
              assert.calledOnce(spark.meetings.request.getActiveMeetings);
              assert.calledOnce(spark.meetings.meetingCollection.getByKey);
              assert.calledOnce(initialSetup);
              assert.calledOnce(spark.meetings.create);
              assert.calledWith(spark.meetings.request.getActiveMeetings);
              assert.calledWith(spark.meetings.meetingCollection.getByKey, 'locusUrl', url1);
              assert.calledWith(spark.meetings.create, {url: url1}, 'LOCUS_ID');
              assert.calledWith(initialSetup, {url: url1});
            });
          });
        });
      });
      describe('#create', () => {
        it('should have #create', () => {
          assert.exists(spark.meetings.create);
        });
        beforeEach(() => {
          spark.meetings.createMeeting = sinon.stub().returns(Promise.resolve(true));
        });
        it('calls createMeeting and returns its promise', async () => {
          const create = spark.meetings.create(test1, test2);
          assert.exists(create.then);
          await create;
          assert.calledOnce(spark.meetings.createMeeting);
          assert.calledWith(spark.meetings.createMeeting, test1, test2);
        });
      });
    });
    describe('Private Detailed API and Helpers', () => {
      describe('#handleLocusMercury', () => {
        beforeEach(() => {
          spark.meetings.handleLocusEvent = sinon.stub().returns(true);
        });
        it('doesnt call handle locus mercury for a locus roap event', () => {
          spark.meetings.handleLocusMercury({data: {eventType: 'locus.message.roap'}});
          assert.notCalled(spark.meetings.handleLocusEvent);
        });
        it('doesnt call handle locus mercury for an undefined eventType', () => {
          spark.meetings.handleLocusMercury({data: {}});
          assert.notCalled(spark.meetings.handleLocusEvent);
        });
        it('calls handle locus mercury for all locus events', () => {
          spark.meetings.handleLocusMercury({data: {eventType: test1}});
          assert.calledOnce(spark.meetings.handleLocusEvent);
          assert.calledWith(spark.meetings.handleLocusEvent, {eventType: test1});
        });
      });
      describe('#handleLocusEvent', () => {
        describe('there was a meeting', () => {
          let parse;
          beforeEach(() => {
            parse = sinon.stub().returns(true);
            spark.meetings.meetingCollection.getByKey = sinon.stub().returns({locusInfo: {parse}});
          });
          it('should parse the meeting info', () => {
            spark.meetings.handleLocusEvent({locusUrl: url1});
            assert.calledOnce(spark.meetings.meetingCollection.getByKey);
            assert.calledWith(spark.meetings.meetingCollection.getByKey, 'locusUrl', url1);
            assert.calledOnce(parse);
            assert.calledWith(parse, {locusInfo: {parse}}, {locusUrl: url1});
          });
        });
        describe('there was not a meeting', () => {
          let initialSetup;
          beforeEach(() => {
            initialSetup = sinon.stub().returns(true);
            spark.meetings.meetingCollection.getByKey = sinon.stub().returns(undefined);
            spark.meetings.create = sinon.stub().returns(Promise.resolve({locusInfo: {initialSetup}}));
          });
          it('should setup the meeting by difference event', async () => {
            await spark.meetings.handleLocusEvent({locus: {id: uuid1}, eventType: 'locus.difference', locusUrl: url1});
            assert.calledOnce(spark.meetings.meetingCollection.getByKey);
            assert.calledWith(spark.meetings.meetingCollection.getByKey, 'locusUrl', url1);
            assert.calledOnce(initialSetup);
            assert.calledWith(initialSetup, {id: uuid1}, undefined);
          });
          it('should setup the meeting by a not difference event', async () => {
            await spark.meetings.handleLocusEvent({locus: {id: uuid1}, eventType: test1, locusUrl: url1});
            assert.calledOnce(spark.meetings.meetingCollection.getByKey);
            assert.calledWith(spark.meetings.meetingCollection.getByKey, 'locusUrl', url1);
            assert.calledOnce(initialSetup);
            assert.calledWith(initialSetup, {id: uuid1});
          });
        });
      });
      describe('#createMeeting', () => {
        beforeEach(() => {
          spark.meetings.trigger = sinon.stub().returns(true);
          spark.internal.device.userId = uuid1;
          spark.internal.device.url = url1;
          MeetingCollection.set = sinon.stub().returns(true);
          MeetingsUtil.getMeetingAddedType = sinon.stub().returns('test');
          MeetingsUtil.extractDestination = sinon.stub().returns('test');
        });
        describe('successful MeetingInfo.#fetchMeetingInfo', () => {
          beforeEach(() => {
            spark.meetings.meetingInfo.fetchMeetingInfo = sinon.stub().returns(Promise.resolve(true));
          });
          it('creates the meeting from a successful meeting info fetch promise testing', async () => {
            const meeting = spark.meetings.createMeeting('test', 'test');
            assert.exists(meeting.then);
            await meeting;
            assert.calledOnce(spark.meetings.meetingInfo.fetchMeetingInfo);
            assert.calledOnce(MeetingsUtil.extractDestination);
            assert.calledOnce(MeetingsUtil.getMeetingAddedType);
            assert.calledOnce(spark.meetings.trigger);
            assert.calledWith(spark.meetings.meetingInfo.fetchMeetingInfo, 'test');
            assert.calledWith(MeetingsUtil.extractDestination, 'test', 'test');
            assert.calledWith(MeetingsUtil.getMeetingAddedType, 'test');
          });

          it('creates the meeting from a successful meeting info fetch meeting resolve testing', async () => {
            const meeting = await spark.meetings.createMeeting('test', 'test');
            assert.instanceOf(meeting, Meeting, 'createMeeting should eventually resolve to a Meeting Object');
            assert.calledOnce(spark.meetings.meetingInfo.fetchMeetingInfo);
            assert.calledOnce(MeetingsUtil.extractDestination);
            assert.calledOnce(MeetingsUtil.getMeetingAddedType);
            assert.calledOnce(spark.meetings.trigger);
            assert.calledWith(spark.meetings.meetingInfo.fetchMeetingInfo, 'test');
            assert.calledWith(MeetingsUtil.extractDestination, 'test', 'test');
            assert.calledWith(MeetingsUtil.getMeetingAddedType, 'test');
            assert.calledWith(spark.meetings.trigger, 'meeting:added', {meeting: sinon.match.instanceOf(Meeting), type: 'test'});
          });
        });
        describe('rejected MeetingInfo.#fetchMeetingInfo', () => {
          beforeEach(() => {
            console.error = sinon.stub().returns(false);
            spark.meetings.meetingInfo.fetchMeetingInfo = sinon.stub().returns(Promise.reject(new Error('test')));
          });
          it('creates the meeting from a rejected meeting info fetch', async () => {
            const meeting = await spark.meetings.createMeeting('test', 'test');
            assert.instanceOf(meeting, Meeting, 'createMeeting should eventually resolve to a Meeting Object');
            assert.calledOnce(spark.meetings.meetingInfo.fetchMeetingInfo);
            assert.calledOnce(MeetingsUtil.extractDestination);
            assert.calledOnce(MeetingsUtil.getMeetingAddedType);
            assert.calledOnce(spark.meetings.trigger);
            assert.calledWith(spark.meetings.meetingInfo.fetchMeetingInfo, 'test');
            assert.calledWith(MeetingsUtil.extractDestination, 'test', 'test');
            assert.calledWith(MeetingsUtil.getMeetingAddedType, 'test');
            assert.calledWith(spark.meetings.trigger, 'meeting:added', {meeting: sinon.match.instanceOf(Meeting), type: 'test'});
          });
        });
      });
    });
    describe('Public Event Triggers', () => {
      describe('#destroy', () => {
        it('should have #destroy', () => {
          assert.exists(spark.meetings.destroy);
        });
        beforeEach(() => {
          spark.meetings.meetingCollection.remove = sinon.stub().returns(true);
          spark.meetings.trigger = sinon.stub().returns(true);
        });
        describe('correctly established meeting', () => {
          it('tests the destroy removal from the collection', () => {
            const response = spark.meetings.destroy({id: uuid1}, test1, test2);
            assert.calledOnce(spark.meetings.meetingCollection.remove);
            assert.calledWith(spark.meetings.meetingCollection.remove, uuid1);
            assert.equal(response, test1);
            assert.calledOnce(spark.meetings.trigger);
            assert.calledWith(spark.meetings.trigger, 'meeting:removed', {meeting: {id: uuid1}, response: test1, type: test2});
          });
        });
        describe('incorrectly established meeting', () => {
          it('tests the destroy removal from the collection, and should throw an error without a meeting', () => {
            assert.throws(() => spark.meetings.destroy(null, 'test', 'test'), Error, 'Cannot remove a meeting without an id from the MeetingCollection.');
          });
          it('tests the destroy removal from the collection, and should throw an error without a meeting.id', () => {
            assert.throws(() => spark.meetings.destroy({}, 'test', 'test'), Error, 'Cannot remove a meeting without an id from the MeetingCollection.');
          });
        });
      });
    });
  });
});
