/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint-disable camelcase */

import sinon from '@webex/test-helper-sinon';
import {assert} from '@webex/test-helper-chai';
import {browserOnly, nodeOnly} from '@webex/test-helper-mocha';
import Logger from '@webex/plugin-logger';
import MockWebex from '@webex/test-helper-mock-webex';
import {
  AuthInterceptor,
  config,
  Credentials,
  WebexHttpError,
  Token
} from '@webex/webex-core';
import {cloneDeep} from 'lodash';

describe('webex-core', () => {
  describe('Interceptors', () => {
    describe('AuthInterceptor', () => {
      let interceptor, webex;

      beforeEach(() => {
        webex = new MockWebex({
          children: {
            credentials: Credentials,
            logger: Logger
          },
          config: cloneDeep(config)
        });

        webex.credentials.supertoken = new Token({
          access_token: 'ST1',
          token_type: 'Bearer'
        }, {parent: webex});

        interceptor = Reflect.apply(AuthInterceptor.create, webex, []);
      });

      describe('#onRequest()', () => {
        it('does not replace the auth header if one has been provided', () => interceptor.onRequest({
          uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
          headers: {
            authorization: 'Bearer Alternate'
          }
        })
          .then((result) => assert.deepEqual(result, {
            uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
            headers: {
              authorization: 'Bearer Alternate'
            }
          })));

        [undefined, null, false].forEach((falsey) => {
          it(`does not add an auth header if ${falsey} has been provided`, () => interceptor.onRequest({
            uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
            headers: {
              authorization: falsey
            }
          })
            .then((result) => assert.deepEqual(result, {
              uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
              headers: {}
            })));
        });


        describe('when the wdm plugin has not been loaded', () => {
          it('adds an auth header to hydra requests', () => interceptor.onRequest({
            uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`
          })
            .then((result) => assert.deepEqual(result, {
              uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
              headers: {
                authorization: 'Bearer ST1'
              }
            })));
        });

        describe('when the wdm plugin has been loaded', () => {
          beforeEach(() => {
            const services = {
              hydraServiceUrl: 'https://hydra-a.wbx.com',
              exampleServiceUrl: 'https://service.example.com'
            };

            webex.config.device.validateDomains = true;
            webex.internal.device = {
              isSpecificService(service, uri) {
                return Promise.resolve(services[service] && uri.includes(services[service]));
              },

              isService(service) {
                return !!services[`${service}ServiceUrl`];
              },

              isServiceUrl(uri) {
                return Promise.resolve(Object.keys(services).reduce((acc, key) => acc || uri.includes(services[key]), false));
              },
              services
            };
          });

          it('adds an auth header to hydra requests', () => Promise.all([
            interceptor.onRequest({
              uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`
            })
              .then((result) => assert.deepEqual(result, {
                uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://hydra-a.wbx.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://hydra-a.wbx.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              service: 'hydra',
              resource: 'ping'
            })
              .then((result) => assert.deepEqual(result, {
                service: 'hydra',
                resource: 'ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              }))
          ]));

          it('adds an auth header to service catalog requests', () => Promise.all([
            interceptor.onRequest({
              uri: 'https://service.example.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://service.example.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://not-a-s-ervice.example.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                headers: {},
                uri: 'https://not-a-s-ervice.example.com/ping'
              }))
          ]));
        });

        describe('#requiresCredentials', () => {
          beforeEach(() => {
            webex.config.device.validateDomains = true;
            webex.internal.device = {
              isSpecificService() {
                return Promise.resolve(false);
              },

              isServiceUrl() {
                return Promise.resolve(false);
              }
            };
          });

          it('adds an auth header to urls with whitelisted domains', () => Promise.all([
            interceptor.onRequest({
              uri: 'https://not-a-service.wbx2.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                uri: 'https://not-a-service.wbx2.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.wbx3.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                uri: 'https://not-a-service.wbx3.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.ciscospark.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                uri: 'https://not-a-service.ciscospark.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.webex.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                uri: 'https://not-a-service.webex.com/ping',
                headers: {
                  authorization: 'Bearer ST1'
                }
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.sample.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                addAuthHeader: true,
                uri: 'https://not-a-service.sample.com/ping',
                headers: {} // doesn't add auth token for non-whitelisted domain
              }))
          ]));
          it('doesnt add authHeader if `addAuthHeader:false`', () => Promise.all([
            interceptor.onRequest({
              addAuthHeader: false,
              uri: 'https://not-a-service.ciscospark.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://not-a-service.ciscospark.com/ping',
                addAuthHeader: false,
                headers: {}
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.webex.com/ping',
              addAuthHeader: false
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://not-a-service.webex.com/ping',
                addAuthHeader: false,
                headers: {}
              })),
            interceptor.onRequest({
              uri: 'https://not-a-service.sample.com/ping',
              addAuthHeader: false
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://not-a-service.sample.com/ping',
                addAuthHeader: false,
                headers: {} // doesn't add auth token for non-whitelisted domain
              }))
          ]));

          it('dont add header if `validatedomain` is false', () => {
            webex.config.device.validateDomains = false;

            return interceptor.onRequest({
              uri: 'https://not-a-service.wbx2.com/ping'
            })
              .then((result) => assert.deepEqual(result, {
                uri: 'https://not-a-service.wbx2.com/ping',
                headers: {}
              }));
          });
        });
      });

      describe('#onResponseError', () => {
        describe('when the server responds with 401', () => {
          nodeOnly(it)('refreshes the access token and replays the request', () => {
            webex.request.onCall(0).returns(Promise.resolve({
              body: {
                access_token: 'ST2'
              }
            }));

            webex.credentials.supertoken = new Token({
              access_token: 'ST1',
              refresh_token: 'RT1'
            }, {parent: webex});

            const err = new WebexHttpError.Unauthorized({
              statusCode: 401,
              options: {
                headers: {
                  trackingid: 'blarg'
                },
                uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`
              },
              body: {
                error: 'fake error'
              }
            });

            assert.notCalled(webex.request);

            return interceptor.onResponseError(err.options, err)
              .then(() => {
                // once for refresh, once for replay
                assert.calledTwice(webex.request);
                assert.equal(webex.credentials.supertoken.access_token, 'ST2');
                assert.equal(webex.request.args[1][0].replayCount, 1);
              });
          });

          browserOnly(it)('refreshes the access token and replays the request', () => {
            webex.config.credentials.refreshCallback = sinon.stub().returns(Promise.resolve({
              access_token: 'ST2'
            }));

            webex.credentials.supertoken = new Token({
              access_token: 'ST1',
              refresh_token: 'RT1'
            }, {parent: webex});

            const err = new WebexHttpError.Unauthorized({
              statusCode: 401,
              options: {
                headers: {
                  trackingid: 'blarg'
                },
                uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`
              },
              body: {
                error: 'fake error'
              }
            });

            assert.notCalled(webex.request);

            return interceptor.onResponseError(err.options, err)
              .then(() => {
                // once for replay
                assert.calledOnce(webex.request);
                assert.equal(webex.credentials.supertoken.access_token, 'ST2');
                assert.equal(webex.request.args[0][0].replayCount, 1);
              });
          });

          describe('when the access token is not refreshable', () => {
            it('responds with the original error', () => {
              webex.credentials.supertoken = new Token({
                access_token: 'ST1'
              }, {parent: webex});

              const err = new WebexHttpError.Unauthorized({
                statusCode: 401,
                options: {
                  headers: {
                    trackingid: 'blarg'
                  },
                  uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`
                },
                body: {
                  error: 'fake error'
                }
              });

              assert.notCalled(webex.request);

              return assert.isRejected(interceptor.onResponseError(err.options, err))
                .then((err2) => {
                  assert.equal(err2, err);
                });
            });
          });

          it('does not refresh if shouldRefreshAccessToken was false', () => {
            webex.config.credentials.refreshCallback = sinon.stub().returns(Promise.resolve({
              access_token: 'ST2'
            }));

            webex.credentials.supertoken = new Token({
              access_token: 'ST1',
              refresh_token: 'RT1'
            }, {parent: webex});

            const err = new WebexHttpError.Unauthorized({
              statusCode: 401,
              options: {
                headers: {
                  trackingid: 'blarg'
                },
                uri: `${config.device.preDiscoveryServices.hydraServiceUrl}/ping`,
                shouldRefreshAccessToken: false
              },
              body: {
                error: 'fake error'
              }
            });

            assert.notCalled(webex.request);

            return assert.isRejected(interceptor.onResponseError(err.options, err))
              .then((err2) => {
                assert.equal(err2, err);
              });
          });
        });
      });
    });
  });
});
