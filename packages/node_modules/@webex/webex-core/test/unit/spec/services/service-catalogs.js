import {assert} from '@webex/test-helper-chai';
import {ServiceCatalogs, serviceConstants} from '@webex/webex-core';

const {SERVICE_CATALOGS, SERVICE_CATALOGS_ENUM_TYPES: SCET} = serviceConstants;

describe('webex-core', () => {
  describe('ServiceCatalogs', () => {
    let fixture;
    let fixtureHosts;
    let serviceCatalogs;

    before('generate fixture', () => {
      fixture = {
        serviceLinks: {
          'example-service-a-name': 'http://example-service-a.com/',
          'example-service-b-name': 'http://example-service-b.com/'
        },
        hostCatalog: {
          'example-service-a': [
            {
              host: 'example-service-a-h1.com',
              id: 'head:group:cluster-a-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-a-h2.com',
              id: 'head:group:cluster-a-h2:example-service-a-name',
              priority: 3
            }
          ],
          'example-service-b': [
            {
              host: 'example-service-b-h1.com',
              id: 'head:group:cluster-b-h1:example-service-b-name',
              priority: 5
            },
            {
              host: 'example-service-b-h2.com',
              id: 'head:group:cluster-b-h2:example-service-b-name',
              priority: 3
            }
          ],
          'example-service-c': [
            {
              host: 'example-service-c-h1.com',
              id: 'head:group:cluster-c-h1:example-service-a-name',
              priority: 5
            },
            {
              host: 'example-service-c-h2.com',
              id: 'head:group:cluster-c-h2:example-service-a-name',
              priority: 3
            }
          ]
        }
      };

      fixtureHosts = Object.keys(fixture.hostCatalog)
        .reduce((output, key) => {
          output.push(...fixture.hostCatalog[key]);

          return output;
        }, []);
    });

    beforeEach('initialize a service catalog', () => {
      serviceCatalogs = new ServiceCatalogs();
    });

    describe('class members', () => {
      describe('#hosts', () => {
        it('should be an array', () => {
          assert.isArray(serviceCatalogs.hosts);
        });
      });
    });

    describe('#filterActive()', () => {
      let hostList;
      let failedHost;
      let filteredHosts;

      beforeEach('generate the service host class objects', () => {
        hostList = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        });

        serviceCatalogs.load(hostList);
        failedHost = serviceCatalogs.hosts[0];
        failedHost.setStatus({failed: true, replaced: true});
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterActive();

        assert.equal(filteredHosts.length, hostList.length);
      });

      it('should return only active hosts when called with true', () => {
        filteredHosts = serviceCatalogs.filterActive(true);

        assert.isBelow(filteredHosts.length, hostList.length);
        assert.notInclude(filteredHosts, failedHost);
      });

      it('should return only inactive hosts when active is false', () => {
        filteredHosts = serviceCatalogs.filterActive(false);

        assert.equal(filteredHosts.length, 1);
        assert.include(filteredHosts[0], failedHost);
      });
    });

    describe('#filterCatalog()', () => {
      let filteredHosts;
      let hostsCustomA;
      let hostsCustomB;

      beforeEach('generate the service host class objects', () => {
        hostsCustomA = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        });

        hostsCustomB = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[1],
          ...fixture
        });

        serviceCatalogs.load(hostsCustomA);
        serviceCatalogs.load(hostsCustomB);
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterCatalog();

        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });

      it('should return only service hosts in the specific catalog', () => {
        filteredHosts = serviceCatalogs.filterCatalog(SERVICE_CATALOGS[0]);

        assert.equal(filteredHosts.length, hostsCustomA.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.catalog === SERVICE_CATALOGS[0]
        ));
      });

      it('should return service hosts for an array of catalogs', () => {
        filteredHosts = serviceCatalogs.filterCatalog(
          [SERVICE_CATALOGS[0], SERVICE_CATALOGS[1]]
        );

        assert.equal(
          filteredHosts.length,
          (hostsCustomA.length + hostsCustomB.length)
        );

        assert.isTrue(filteredHosts.every(
          (host) => [SERVICE_CATALOGS[0], SERVICE_CATALOGS[1]].includes(
            host.catalog
          )
        ));
      });

      it('should return only service hosts from valid catalogs', () => {
        filteredHosts = serviceCatalogs.filterCatalog(
          [SERVICE_CATALOGS[0], 'invalid', -1]
        );

        assert.equal(filteredHosts.length, hostsCustomA.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.catalog === SERVICE_CATALOGS[0]
        ));
      });
    });

    describe('#filterLocal()', () => {
      let filteredHosts;
      let remoteHosts;
      let localHosts;

      beforeEach('generate the service host class objects', () => {
        serviceCatalogs.load(
          ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          })
        );

        remoteHosts = fixture.hostCatalog['example-service-c'];
        localHosts = [
          ...fixture.hostCatalog['example-service-a'],
          ...fixture.hostCatalog['example-service-b']
        ];
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterLocal();

        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });

      it('should return only local hosts when called with true', () => {
        filteredHosts = serviceCatalogs.filterLocal(true);

        assert.equal(filteredHosts.length, localHosts.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.local === true
        ));
      });

      it('should return only hosts remote hosts when called with false', () => {
        filteredHosts = serviceCatalogs.filterLocal(false);

        assert.equal(filteredHosts.length, remoteHosts.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.local === false
        ));
      });
    });

    describe('#filterPriority()', () => {
      let filteredHosts;
      let priorityHosts;

      beforeEach('generate the service host class objects', () => {
        serviceCatalogs.load(
          ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          })
        );

        priorityHosts = [
          fixture.hostCatalog['example-service-a'][0],
          fixture.hostCatalog['example-service-b'][0],
          fixture.hostCatalog['example-service-c'][0]
        ];
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterPriority();

        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });

      it('should return only priority hosts when called with true', () => {
        filteredHosts = serviceCatalogs.filterPriority(true);

        assert.equal(filteredHosts.length, priorityHosts.length);
      });

      it('should not return inactive hosts when called with true', () => {
        filteredHosts = serviceCatalogs.filterPriority(true);
        filteredHosts[0].setStatus({failed: true});

        const failedHost = filteredHosts[0];

        filteredHosts = serviceCatalogs.filterPriority(true);

        assert.notInclude(filteredHosts, failedHost);
      });

      it('should return all hosts when called with false', () => {
        filteredHosts = serviceCatalogs.filterPriority(false);

        assert.deepEqual(filteredHosts, serviceCatalogs.hosts);
      });
    });

    describe('#filterService()', () => {
      let filteredHosts;
      let otherHosts;
      let otherServiceName;
      let serviceHosts;
      let serviceName;

      beforeEach('generate the service host class objects', () => {
        serviceCatalogs.load(
          ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          })
        );

        otherHosts = [
          ...fixture.hostCatalog['example-service-b']
        ];

        serviceHosts = [
          ...fixture.hostCatalog['example-service-a'],
          ...fixture.hostCatalog['example-service-c']
        ];

        otherServiceName = 'example-service-b-name';
        serviceName = 'example-service-a-name';
      });

      it('should return all hosts when called without params', () => {
        filteredHosts = serviceCatalogs.filterService();

        assert.equal(filteredHosts.length, serviceCatalogs.hosts.length);
      });

      it('should return hosts that belong to a service', () => {
        filteredHosts = serviceCatalogs.filterService(serviceName);

        assert.equal(filteredHosts.length, serviceHosts.length);
        assert.isTrue(filteredHosts.every(
          (host) => host.service === serviceName
        ));
      });

      it('should return all hosts that belong to an array of services', () => {
        filteredHosts = serviceCatalogs.filterService([
          otherServiceName,
          serviceName
        ]);

        assert.equal(
          filteredHosts.length,
          [...otherHosts, ...serviceHosts].length
        );

        assert.isTrue(filteredHosts.every(
          (host) => [otherServiceName, serviceName].includes(host.service)
        ));
      });

      it('should return no hosts with an invalid service', () => {
        filteredHosts = serviceCatalogs.filterService('invalid');

        assert.equal(filteredHosts.length, 0);
      });
    });

    describe('#load()', () => {
      it('should amend all provided hosts to the hosts array', () => {
        serviceCatalogs.load(ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        }));

        assert.equal(serviceCatalogs.hosts.length, fixtureHosts.length);
      });

      it('should ignore unloadable hosts', () => {
        const unloadables = ServiceCatalogs.mapRemoteCatalog({
          catalog: SERVICE_CATALOGS[0],
          ...fixture
        }).map((unloadable) => ({...unloadable, catalog: 'invalid'}));

        serviceCatalogs.load(unloadables);

        assert.equal(serviceCatalogs.hosts.length, 0);
      });

      it('should return itself', () => {
        assert.equal(serviceCatalogs.load([]), serviceCatalogs);
      });
    });

    describe('static methods', () => {
      describe('#mapCatalogName()', () => {
        let index;
        let name;

        beforeEach(() => {
          index = 0;
          name = SERVICE_CATALOGS[index];
        });

        it('should map an index to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.STRING}),
            name
          );
        });

        it('should map an index to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: index, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching index', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.NUMBER}),
            index
          );
        });

        it('should map a name to the matching name', () => {
          assert.equal(
            ServiceCatalogs.mapCatalogName({id: name, type: SCET.STRING}),
            name
          );
        });

        it('should return undefined if an index doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: -1, type: SCET.NUMBER})
          );
        });

        it('should return undefined if a name doesn\'t exist', () => {
          assert.isUndefined(
            ServiceCatalogs.mapCatalogName({id: 'invalid', type: SCET.NUMBER})
          );
        });
      });

      describe('#mapRemoteCatalog()', () => {
        it('should return an array', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          });

          assert.isArray(mappedHosts);
        });

        it('should include all provided hosts', () => {
          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: SERVICE_CATALOGS[0],
            ...fixture
          });

          assert.equal(mappedHosts.length, fixtureHosts.length);
        });

        it('should not map using an invalid catalog name', () => {
          assert.throws(() => ServiceCatalogs.mapRemoteCatalog({
            catalog: 'invalid',
            ...fixture
          }));
        });

        it('should map catalog indexes to catalog names', () => {
          const catalogIndex = 4;

          const mappedHosts = ServiceCatalogs.mapRemoteCatalog({
            catalog: catalogIndex,
            ...fixture
          });

          assert.equal(
            mappedHosts[0].catalog,
            SERVICE_CATALOGS[catalogIndex]
          );
        });
      });
    });
  });
});
