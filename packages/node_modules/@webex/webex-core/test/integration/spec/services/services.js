/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';

import {assert} from '@webex/test-helper-chai';
import {flaky} from '@webex/test-helper-mocha';
import WebexCore, {ServiceUrl} from '@webex/webex-core';
import testUsers from '@webex/test-helper-test-users';
import uuid from 'uuid';

/* eslint-disable no-underscore-dangle */
describe('webex-core', () => {
  describe('Services', () => {
    let webexUser;
    let webexUserEU;
    let webex;
    let webexEU;
    let services;
    let servicesEU;
    let catalog;

    before('create users', () => Promise.all([
      testUsers.create({count: 1}),
      testUsers.create({count: 1, orgId: process.env.EU_PRIMARY_ORG_ID})
    ])
      .then(([[user], [userEU]]) => new Promise((resolve) => {
        setTimeout(() => {
          webexUser = user;
          webexUserEU = userEU;
          webex = new WebexCore({credentials: {supertoken: user.token}});
          webexEU = new WebexCore({credentials: {supertoken: userEU.token}});
          services = webex.internal.services;
          servicesEU = webexEU.internal.services;
          catalog = services._getCatalog();
          resolve();
        }, 3000);
      }))
      .then(() => webex.internal.device.register())
      .then(() => services.waitForCatalog('postauth', 10))
      .then(() => services.updateServices({
        from: 'limited',
        query: {userId: webexUser.id}
      })));

    describe('#_getCatalog()', () => {
      it('returns a catalog', () => {
        const localCatalog = services._getCatalog();

        assert.equal(localCatalog.namespace, 'ServiceCatalog');
      });
    });

    describe('#list()', () => {
      it('matches the values in serviceUrl', () => {
        let serviceList = services.list();

        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], catalog._getUrl(key).get());
        });

        serviceList = services.list(true);
        Object.keys(serviceList).forEach((key) => {
          assert.equal(serviceList[key], catalog._getUrl(key).get(true));
        });
      });
    });

    describe('#get()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });

      it('returns a valid string when name is specified', () => {
        const url = services.get(testUrlTemplate.name);

        assert.typeOf(url, 'string');
        assert.equal(url, testUrlTemplate.defaultUrl);
      });

      it('returns undefined if url doesn\'t exist', () => {
        const s = services.get('invalidUrl');

        assert.typeOf(s, 'undefined');
      });

      it('gets a service from a specific serviceGroup', () => {
        assert.isDefined(services.get(testUrlTemplate.name, false, 'preauth'));
      });

      it('fails to get a service if serviceGroup isn\'t accurate', () => {
        assert.isUndefined(services.get(testUrlTemplate.name,
          false, 'discovery'));
      });
    });

    describe('#getClusterId()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5,
              id: 'exampleClusterId'
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3,
              id: 'exampleClusterId'
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('returns a clusterId when found with default url', () => {
        assert.equal(services.getClusterId(testUrlTemplate.defaultUrl),
          testUrlTemplate.hosts[0].id);
      });

      it('returns a clusterId when found with priority host url', () => {
        assert.equal(services.getClusterId(testUrl.get(true)),
          testUrlTemplate.hosts[0].id);
      });

      it('returns a clusterId when found with resource-appended url', () => {
        assert.equal(
          services.getClusterId(`${testUrl.get()}example/resource/value`),
          testUrlTemplate.hosts[0].id
        );
      });

      it('returns undefined when the url doesn\'t exist in catalog', () => {
        assert.isUndefined(
          services.getClusterId('http://not-a-known-url.com/')
        );
      });

      it('returns undefined when the string isn\'t a url', () => {
        assert.isUndefined(services.getClusterId('not a url'));
      });
    });

    describe('#getServiceFromClusterId()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5,
              id: 'exampleClusterId'
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3,
              id: 'exampleClusterId'
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('finds a valid service url from only a clusterId', () => {
        const serviceFound = services.getServiceFromClusterId({
          clusterId: testUrlTemplate.hosts[0].id,
          priorityHost: false
        });

        assert.equal(serviceFound.name, testUrl.name);
        assert.equal(serviceFound.url, testUrl.defaultUrl);
      });

      it('finds a valid priority service url', () => {
        const serviceFound = services.getServiceFromClusterId({
          clusterId: testUrlTemplate.hosts[0].id,
          priorityHost: true
        });

        assert.equal(serviceFound.name, testUrl.name);
        assert.equal(serviceFound.url, catalog.get('exampleValid', true));
      });

      it('finds a valid service when a service group is defined', () => {
        const serviceFound = catalog.findServiceFromClusterId({
          clusterId: testUrlTemplate.hosts[0].id,
          priorityHost: false,
          serviceGroup: 'preauth'
        });

        assert.equal(serviceFound.name, testUrl.name);
        assert.equal(serviceFound.url, testUrl.defaultUrl);
      });

      it('fails to find a valid service when it\'s not in a group', () => {
        assert.isUndefined(
          services.getServiceFromClusterId({
            clusterId: testUrlTemplate.hosts[0].id,
            serviceGroup: 'signin'
          })
        );
      });

      it('returns undefined when service doesn\'t exist', () => {
        assert.isUndefined(
          services.getServiceFromClusterId({clusterId: 'not a clusterId'})
        );
      });
    });

    describe('#getServiceFromUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5,
              id: 'exampleClusterId'
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3,
              id: 'exampleClusterId'
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });

      it('gets a valid service object from an existing service', () => {
        const serviceObject = services
          .getServiceFromUrl(testUrlTemplate.defaultUrl);

        assert.isDefined(serviceObject);
        assert.hasAllKeys(serviceObject, ['name', 'defaultUrl', 'priorityUrl']);

        assert.equal(testUrlTemplate.name, serviceObject.name);
        assert.equal(testUrlTemplate.defaultUrl, serviceObject.defaultUrl);
        assert.equal(testUrl.get(true), serviceObject.priorityUrl);
      });

      it('returns undefined when the service url doesn\'t exist', () => {
        const serviceObject = services
          .getServiceFromUrl('http://www.not-real.com/');

        assert.isUndefined(serviceObject);
      });
    });

    describe('#hasService()', () => {
      it('returns a boolean', () => {
        assert.isBoolean(services.hasService('some-url'));
      });

      it('validates that a service exists', () => {
        const service = Object.keys(services.list())[0];

        assert.isTrue(services.hasService(service));
      });
    });

    describe('#isServiceUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5,
              id: 'exampleClusterId'
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3,
              id: 'exampleClusterId'
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('returns true if url is a service url', () => {
        assert.isTrue(services.isServiceUrl(testUrlTemplate.defaultUrl));
      });

      it('returns true for priority host urls', () => {
        assert.isTrue(services.isServiceUrl(testUrl.get(true)));
      });

      it('returns undefined if the url doesn\'t exist', () => {
        assert.isFalse(services.isServiceUrl('https://na.com/'));
      });

      it('returns undefined if the param is not a url', () => {
        assert.isFalse(services.isServiceUrl('not a url'));
      });
    });

    describe('#isAllowedDomainUrl()', () => {
      let list;

      beforeEach(() => {
        catalog.setAllowedDomains([
          'some-domain-a',
          'some-domain-b'
        ]);

        list = catalog.getAllowedDomains();
      });

      it('returns a boolean', () => {
        assert.isBoolean(services.isAllowedDomainUrl(''));
      });

      it('returns true if the url contains an allowed domain', () => {
        assert.isTrue(services.isAllowedDomainUrl(`https://${list[0]}/resource`));
      });

      it('returns false if the url does not contain an allowed domain', () => {
        assert.isFalse(services.isAllowedDomainUrl('https://bad-domain/resource'));
      });
    });

    describe('#convertUrlToPriorityUrl', () => {
      let testUrl;
      let testUrlTemplate;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example.com/api/v1',
          hosts: [
            {
              host: 'www.example-p5.com',
              ttl: -1,
              priority: 5,
              id: 'exampleClusterId'
            },
            {
              host: 'www.example-p3.com',
              ttl: -1,
              priority: 3,
              id: 'exampleClusterId'
            }
          ],
          name: 'exampleValid'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      it('converts the url to a priority host url', () => {
        const resource = 'path/to/resource';
        const url = `${testUrlTemplate.defaultUrl}/${resource}`;

        const convertUrl = services.convertUrlToPriorityHostUrl(url);

        assert.isDefined(convertUrl);
        assert.equal(convertUrl,
          `https://${testUrlTemplate.hosts[1].host}/api/v1/${resource}`);
      });

      it('throws an exception if not a valid service', () => {
        assert.throws(services.convertUrlToPriorityHostUrl, Error);

        assert.throws(
          services.convertUrlToPriorityHostUrl
            .bind(services, 'not-a-valid-service'),
          Error
        );
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });
    });

    describe('#markFailedUrl()', () => {
      let testUrlTemplate;
      let testUrl;

      beforeEach('load test url', () => {
        testUrlTemplate = {
          defaultUrl: 'https://www.example-phr.com/api/v1',
          hosts: [
            {
              host: 'www.example-phr-p5.com',
              ttl: -1,
              priority: 5
            },
            {
              host: 'www.example-phr-p3.com',
              ttl: -1,
              priority: 3
            }
          ],
          name: 'exampleValid-phr'
        };
        testUrl = new ServiceUrl({...testUrlTemplate});
        catalog._loadServiceUrls('preauth', [testUrl]);
      });

      afterEach('unload test url', () => {
        catalog._unloadServiceUrls('preauth', [testUrl]);
      });

      it('marks a host as failed and removes from host list', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);
        const originalServiceUrlHostLength = testUrl.hosts.length;

        services.markFailedUrl(priorityUrl);

        assert.isBelow(testUrl.hosts.length, originalServiceUrlHostLength);
      });

      it('returns the next priority url', () => {
        const priorityUrl = services.get(testUrlTemplate.name, true);

        const nextPriorityUrl = services.markFailedUrl(priorityUrl);

        assert.notEqual(priorityUrl, nextPriorityUrl);
      });
    });

    describe('#updateServices()', () => {
      it('returns a Promise that and resolves on success', (done) => {
        const servicesPromise = services.updateServices();

        assert.typeOf(servicesPromise, 'Promise');

        servicesPromise.then(() => {
          Object.keys(services.list()).forEach((key) => {
            assert.typeOf(key, 'string');
            assert.typeOf(services.list()[key], 'string');
          });

          done();
        });
      });

      it('updates the services list', (done) => {
        catalog.serviceGroups.postauth = [];

        services.updateServices()
          .then(() => {
            assert.isAbove(catalog.serviceGroups.postauth.length, 0);
            done();
          });

        services.updateServices();
      });

      it('updates the limited catalog when email is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices({
          from: 'limited',
          query: {email: webexUser.email}
        })
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });

      it('updates the limited catalog when userId is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices({
          from: 'limited',
          query: {userId: webexUser.id}
        })
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });

      it('updates the limited catalog when orgId is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices({
          from: 'limited',
          query: {orgId: webexUser.orgId}
        })
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });
      it('updates the limited catalog when query param mode is provided', (done) => {
        catalog.serviceGroups.preauth = [];

        services.updateServices({
          from: 'limited',
          query: {mode: 'DEFAULT_BY_PROXIMITY'}
        })
          .then(() => {
            assert.isAbove(catalog.serviceGroups.preauth.length, 0);
            done();
          });
      });
      it('does not update the limited catalog when nothing is provided', () => {
        catalog.serviceGroups.preauth = [];

        return services.updateServices({from: 'limited'})
          .then(() => {
            assert(false, 'resolved, should have thrown');
          })
          .catch(() => {
            assert(true);
          });
      });
    });

    describe('#validateUser()', () => {
      const unauthWebex = new WebexCore();
      const unauthServices = unauthWebex.internal.services;

      it('returns a rejected promise when no email is specified', () => unauthServices.validateUser({})
        .then(() => {
          assert(false, 'resolved, should have thrown');
        })
        .catch(() => {
          assert(true);
        }));

      it('validates an authorized user and webex instance', () => services.validateUser({email: webexUser.email})
        .then((r) => {
          assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
          assert.equal(r.activated, true);
          assert.equal(r.exists, true);
        }));

      it('validates an authorized EU user and webex instance', () => servicesEU.validateUser({email: webexUserEU.email})
        .then((r) => {
          assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
          assert.equal(r.activated, true);
          assert.equal(r.exists, true);
        }));

      it('returns a rejected promise if the provided email isn\'t valid', () => unauthServices.validateUser({email: 'not an email'})
        .then(() => {
          assert(false, 'resolved, should have thrown');
        })
        .catch(() => {
          assert(true);
        }));

      it('validates a non-existing user', () => unauthServices.validateUser({email: `Collabctg+webex-js-sdk-${uuid.v4()}@gmail.com`})
        .then((r) => {
          assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
          assert.equal(r.activated, false);
          assert.equal(r.exists, false);
          assert.isAbove(Object.keys(unauthServices.list(false, 'preauth')).length, 0);
          assert.equal(Object.keys(unauthServices.list(false, 'signin')).length, 0);
          assert.equal(Object.keys(unauthServices.list(false, 'postauth')).length, 0);
        }));

      it('validates an inactive user', () => {
        // This will be changed to utilize a new test user generation
        // method that can create a user without activating it. Currently,
        // this will throw an error if too many requests to Atlas are triggered
        // to send activation emails. A solution was to append a `skipEmail`
        // parameter key to allow bypassing the email request when necessary.
        const inactive = 'webex.web.client+nonactivated@gmail.com';

        return unauthServices.validateUser({email: inactive, skipEmail: true})
          .then((r) => {
            assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
            assert.equal(r.activated, false, 'activated');
            assert.equal(r.exists, true, 'exists');
            assert.isAbove(Object.keys(unauthServices.list(false, 'preauth')).length, 0);
            assert.equal(Object.keys(unauthServices.list(false, 'signin')).length, 0);
            assert.equal(Object.keys(unauthServices.list(false, 'postauth')).length, 0);
          });
      });

      it('validates an existing user', () => unauthServices.validateUser({email: webexUser.email})
        .then((r) => {
          assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
          assert.equal(r.activated, true);
          assert.equal(r.exists, true);
          assert.isAbove(Object.keys(unauthServices.list(false, 'preauth')).length, 0);
          assert.isAbove(Object.keys(unauthServices.list(false, 'signin')).length, 0);
          assert.equal(Object.keys(unauthServices.list(false, 'postauth')).length, 0);
        }));

      it('validates an existing EU user', () => unauthServices.validateUser({email: webexUserEU.email})
        .then((r) => {
          assert.hasAllKeys(r, ['activated', 'exists', 'user', 'details']);
          assert.equal(r.activated, true);
          assert.equal(r.exists, true);
          assert.isAbove(Object.keys(unauthServices.list(false, 'preauth')).length, 0);
          assert.isAbove(Object.keys(unauthServices.list(false, 'signin')).length, 0);
          assert.equal(Object.keys(unauthServices.list(false, 'postauth')).length, 0);
        }));
    });

    describe('#collectPreauthCatalog()', () => {
      const unauthWebex = new WebexCore({config: {credentials: {federation: true}}});
      const unauthServices = unauthWebex.internal.services;

      it('updates the preauth catalog without email', () => unauthServices.collectPreauthCatalog()
        .then(() => {
          assert.isAbove(Object.keys(unauthServices.list()).length, 0);
        }));

      it('updates the preauth catalog with email', () => unauthServices.collectPreauthCatalog({email: webexUser.email})
        .then(() => {
          assert.isAbove(Object.keys(unauthServices.list()).length, 0);
        }));
    });

    describe('#collectSigninCatalog()', () => {
      const unauthWebex = new WebexCore({config: {credentials: {federation: true}}});
      const unauthServices = unauthWebex.internal.services;

      it('requires an email as the parameter', () => unauthServices.collectPreauthCatalog()
        .catch((e) => {
          assert(true, e);
        }));

      it('requires a token as the parameter', () => unauthServices.collectPreauthCatalog({email: 'email@website.com'})
        .catch((e) => {
          assert(true, e);
        }));

      it('updates the preauth catalog', () => unauthServices.collectPreauthCatalog({email: webexUser.email})
        .then(() => {
          assert.isAbove(Object.keys(unauthServices.list()).length, 0);
        }));
    });

    flaky(describe, process.env.SKIP_FLAKY_TESTS)('#_fetchNewServiceHostmap()', () => {
      let fullRemoteHM;
      let limitedRemoteHM;

      before('collect remote catalogs', () => Promise.all([
        services._fetchNewServiceHostmap(),
        services._fetchNewServiceHostmap({
          from: 'limited',
          query: {userId: webexUser.id}
        })
      ])
        .then(([fRHM, lRHM]) => {
          fullRemoteHM = fRHM;
          limitedRemoteHM = lRHM;
        }));

      it('resolves to an authed u2c hostmap when no params specified', () => {
        assert.typeOf(fullRemoteHM, 'array');
        assert.isAbove(fullRemoteHM.length, 0);
      });

      it('resolves to a limited u2c hostmap when params specified', () => {
        assert.typeOf(limitedRemoteHM, 'array');
        assert.isAbove(limitedRemoteHM.length, 0);
      });

      it('rejects if the params provided are invalid', () => (
        services._fetchNewServiceHostmap({
          from: 'limited',
          query: {userId: 'notValid'}
        })
          .then(() => {
            assert.isTrue(false, 'should have rejected');
          })
          .catch((e) => {
            assert.typeOf(e, 'Error');
          })
      ));
    });
  });
});
/* eslint-enable no-underscore-dangle */
