import {
  SERVICE_CATALOGS,
  SERVICE_CATALOGS_ENUM_TYPES
} from './constants';
import ServiceHost from './service-host';

/**
 * The parameter transfer object for {@link ServiceCatalogs#mapRemoteCatalog}.
 * This object is shaped to match the object returned from the **U2C** service.
 *
 * @typedef {Record<string, string>} RSL
 * @typedef {Record<string, Array<Record<string, number | string>>>} RHC
 *
 * @typedef {Object} MapRemoteCatalogPTO
 * @property {string} MapRemoteCatalogPTO.catalog - Service catalog name.
 * @property {RSL} MapRemoteCatalogPTO.serviceLinks - Service links.
 * @property {RHC} MapRemoteCatalogPTO.hostCatalog - Service host catalog.
 */

/**
 * @class
 * @classdesc - Manages a collection of {@link ServiceHost} class objects.
 */
export default class ServiceCatalogs {
  /**
   * Generate a new {@link ServiceHost}.
   *
   * @public
   * @constructor
   * @memberof ServiceHost
   */
  constructor() {
    /**
     * The collection of managed {@link ServiceHost}s.
     *
     * @instance
     * @type {Array<ServiceHost>}
     * @private
     * @memberof ServiceCatalogs
     */
    this.hosts = [];
  }

  /**
   * Filter the {@link ServiceCatalogs#hosts} array against their active states.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {boolean} [active] - Filter for the host state.
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterActive(active) {
    // Filter the host array if the active requirement is true.
    return (typeof active === 'boolean') ?
      this.hosts.filter((host) => host.active === active) :
      [...this.hosts];
  }

  /**
   * Filter the {@link ServiceCatalogs#hosts} array against their assigned
   * catalog values.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {Array<string> | string} [catalog] - Catalogs to filter.
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterCatalog(catalog = []) {
    // Generate a catalog names array based on the provided catalog param.
    const catalogs = (Array.isArray(catalog) ? catalog : [catalog])
      .map((catalogId) => ServiceCatalogs.mapCatalogName({
        id: catalogId,
        type: SERVICE_CATALOGS_ENUM_TYPES.STRING
      }) || catalogId);

    // Filter the host array against the catalog names array.
    return (catalogs.length > 0) ?
      this.hosts.filter((host) => catalogs.includes(host.catalog)) :
      [...this.hosts];
  }

  /**
   * Filter the {@link ServiceCatalogs#hosts} array against their assigned
   * cluster values.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {Array<string> | string} [cluster] - Clusters to filter for.
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterCluster(cluster = []) {
    // Generate an array of clusters regardless of parameter type.
    const clusters = (Array.isArray(cluster) ? cluster : [cluster]);

    // Filter the host array against the provided clusters.
    return (clusters.length > 0) ?
      this.hosts.filter((host) => clusters.includes(host.id)) :
      [...this.hosts];
  }

  /**
   * Filter the {@link ServiceCatalogs#hosts} array against their location in
   * reference to the authenticated user.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {boolean} [local] - Filter for the host location.
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterLocal(local) {
    return (typeof local === 'boolean') ?
      this.hosts.filter((host) => host.local === local) :
      [...this.hosts];
  }

  /**
   * Filter the `{@link ServiceCatalogs#hosts} array for the highest priority
   * hosts for each specific service.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {boolean} [priority] - Filter for the highest priority
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterPriority(priority) {
    return (priority) ?
      this.hosts.reduce(
        (filteredHosts, currentHost) => {
          // Validate that the current host is not active.
          if (!currentHost.active) {
            return filteredHosts;
          }

          // Determine if the filtered hosts array contains a host from the same
          // host group.
          const foundHost = filteredHosts.find(
            (host) => host.hostGroup === currentHost.hostGroup
          );

          // Validate if a host was found.
          if (!foundHost) {
            filteredHosts.push(currentHost);

            return filteredHosts;
          }

          // Map the found host's catalog to its priority value.
          const foundHostCatalogPriority = ServiceCatalogs.mapCatalogName({
            id: foundHost.catalog,
            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER
          });

          // Map the current host's catalog to its priority value.
          const currentHostCatalogPriority = ServiceCatalogs.mapCatalogName({
            id: currentHost.catalog,
            type: SERVICE_CATALOGS_ENUM_TYPES.NUMBER
          });

          // Validate if the found host has a lower priority than the current
          // host.
          if (
            foundHostCatalogPriority < currentHostCatalogPriority ||
            foundHost.priority < currentHost.priority
          ) {
            filteredHosts.splice(filteredHosts.indexOf(foundHost, 1));
            filteredHosts.push(currentHost);
          }

          return filteredHosts;
        }, []
      ) : [...this.hosts];
  }

  /**
   * Filter the `{@link ServiceCatalogs#hosts} array for a host with a specified
   * set of service names.
   *
   * @private
   * @memberof ServiceCatalogs
   * @param {Array<string> | string} [service] - Services to filter.
   * @returns {Array<ServiceHost>} - The filtered host array.
   */
  filterService(service = []) {
    // Generate an array of clusters regardless of parameter type.
    const services = (Array.isArray(service) ? service : [service]);

    // Filter the host array against the provided clusters.
    return (services.length > 0) ?
      this.hosts.filter((host) => service.includes(host.service)) :
      [...this.hosts];
  }

  /**
   * Load a formatted array of {@link ServiceHost} constructor parameter
   * transfer objects as instances of {@link ServiceHost} class objects to the
   * {@link ServiceCatalogs#hosts} array.
   *
   * @public
   * @memberof ServiceCatalogs
   * @param {Array<ServiceHost.ConstructorPTO>} hosts
   * @returns {this}
   */
  load(hosts = []) {
    // Validate that the provided hosts are eligible to be loaded.
    const validHosts = hosts.filter((host) => !!(
      ServiceCatalogs.mapCatalogName({
        id: host.catalog,
        type: SERVICE_CATALOGS_ENUM_TYPES.STRING
      })));

    // Load the eligible hosts.
    this.hosts.push(
      ...validHosts.map((loadableHost) => new ServiceHost(loadableHost))
    );

    return this;
  }

  /**
   * Convert a {@link SERVICE_CATALOGS} identifier or value to its associated
   * idenfier or value.
   *
   * @public
   * @static
   * @memberof ServiceCatalogs
   * @param {Object} pto - The parameter transfer object.
   * @property {string | number} pto.id - The identifier to convert in the enum.
   * @property {SERVICE_CATALOGS_ENUM_TYPES} pto.type - The desired output.
   * @returns {string|number} - The matching enum value or index.
   */
  static mapCatalogName({id, type}) {
    // Validate that the id is a number.
    if (typeof id === 'number') {
      // Validate that the desired type is a number.
      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
        return (SERVICE_CATALOGS[id] !== undefined) ? id : undefined;
      }

      // Validate that the desired type is a string.
      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {
        return SERVICE_CATALOGS[id];
      }
    }

    // Validate that the id is a string.
    if (typeof id === 'string') {
      // Validate that the desired type is a string.
      if (type === SERVICE_CATALOGS_ENUM_TYPES.STRING) {
        return SERVICE_CATALOGS.includes(id) ? id : undefined;
      }

      // Validate that the desired type is a number.
      if (type === SERVICE_CATALOGS_ENUM_TYPES.NUMBER) {
        return (SERVICE_CATALOGS.includes(id)) ?
          SERVICE_CATALOGS.indexOf(id) :
          undefined;
      }
    }

    return undefined;
  }

  /**
   * Generate a formatted array based on the object received from the **U2C**
   * service for usage in the {@link ServiceCatalogs#load} method.
   *
   * @public
   * @static
   * @memberof ServiceCatalogs
   * @param {MapRemoteCatalogPTO} pto - The parameter transfer object.
   * @throws - If the target catalog does not exist.
   * @returns {Array<ServiceHost#ServiceHostConstructorPTO>}
   */
  static mapRemoteCatalog({catalog, hostCatalog, serviceLinks}) {
    // Collect the service catalog name if needed.
    const catalogIndex = ServiceCatalogs.mapCatalogName({
      id: catalog,
      type: SERVICE_CATALOGS_ENUM_TYPES.STRING
    });

    // Validate that the target catalog exists.
    if (!SERVICE_CATALOGS.includes(catalogIndex)) {
      throw new Error(`service-catalogs: '${catalog}' is not a valid catalog`);
    }

    // Map the remote catalog to a mountable host array.
    return Object.keys(hostCatalog).reduce((output, key) => {
      output.push(
        ...hostCatalog[key].map((host) => ({
          catalog: catalogIndex,
          defaultUri: serviceLinks[host.id.split(':')[3]],
          hostGroup: key,
          id: host.id,
          priority: host.priority,
          uri: host.host
        }))
      );

      return output;
    }, []);
  }
}
