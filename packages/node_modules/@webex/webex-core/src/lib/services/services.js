import Url from 'url';

import {base64} from '@webex/common';

import WebexPlugin from '../webex-plugin';

import ServiceCatalog from './service-catalog';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const Services = WebexPlugin.extend({
  namespace: 'Services',

  _catalogs: new WeakMap(),

  /**
   * @private
   * Get the current catalog based on the assocaited
   * webex instance.
   * @returns {ServiceCatalog}
   */
  _getCatalog() {
    return this._catalogs.get(this.webex);
  },

  /**
   * Get a service url from the current services list by name
   * from the associated instance catalog.
   * @param {string} name
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {string|undefined}
   */
  get(name, priorityHost, serviceGroup) {
    const catalog = this._getCatalog();

    return catalog.get(name, priorityHost, serviceGroup);
  },

  /**
   * Generate a service catalog as an object from
   * the associated instance catalog.
   * @param {boolean} [priorityHost] - use highest priority host if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  list(priorityHost, serviceGroup) {
    const catalog = this._getCatalog();

    return catalog.list(priorityHost, serviceGroup);
  },

  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl(url, noPriorityHosts) {
    const catalog = this._getCatalog();

    return catalog.markFailedUrl(url, noPriorityHosts);
  },

  /**
   * Update a list of `serviceUrls` to the most current
   * catalog via the defined `discoveryUrl` then returns the current
   * list of services.
   * @param {object} [param]
   * @param {string} [param.from] - This accepts `limited` or `signin`
   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values
   * @param {string} [param.query.email] - must be a standard-format email
   * @param {string} [param.query.orgId] - must be an organization id
   * @param {string} [param.query.userId] - must be a user id
   * @param {string} [param.token] - used for signin catalog
   * @returns {Promise<object>}
   */
  updateServices({from, query, token} = {}) {
    const catalog = this._getCatalog();
    let formattedQuery, serviceGroup;

    // map catalog name to service group name.
    switch (from) {
      case 'limited': serviceGroup = 'preauth'; break;
      case 'signin': serviceGroup = 'signin'; break;
      default: serviceGroup = 'postauth'; break;
    }

    // confirm catalog update for group is not in progress.
    if (catalog.status[serviceGroup].collecting) {
      return this.waitForCatalog(serviceGroup);
    }

    catalog.status[serviceGroup].collecting = true;

    // encode email when query key is email
    if (serviceGroup === 'preauth' || serviceGroup === 'signin') {
      const queryKey = Object.keys(query)[0];

      formattedQuery = {};
      formattedQuery[queryKey] = queryKey === 'email' ?
        base64.encode(query.email) : query[queryKey];
    }

    return this._fetchNewServiceHostmap({
      from,
      token,
      query: formattedQuery
    })
      .then((serviceHostMap) => {
        catalog.updateServiceUrls(serviceGroup, serviceHostMap);
        this.updateCredentialsConfig();
        catalog.status[serviceGroup].collecting = false;
      })
      .catch(() => {
        catalog.status[serviceGroup].collecting = false;

        return Promise.reject();
      });
  },

  /**
   * Validate if a user, by email, is activated or not. This also returns
   * an object that contains the atlas user details if available.
   * @param {object} param
   * @param {string} param.email - must be a standard-format email
   * @param {string} [param.reqId] - request id
   * @returns {Promise<object>} - { activated: boolean, details: string, user: object }
   */
  validateUser({email, reqId = 'WEBCLIENT'} = {}) {
    if (!email) {
      return Promise.reject(new Error('`email` is required'));
    }

    const {canAuthorize, canRefresh} = this.webex.credentials;

    // This conditional statement exists as a logical
    // fallback in the event that the user is already
    // authorized via a user token.
    if (canAuthorize && !canRefresh) {
      return this.updateServices()
        .then(() => ({
          activated: true,
          details: 'user is authorized via user token',
          user: {}
        }));
    }

    // Scoped function for sending the atlas
    // activation request.
    const sendUserActivation = (token) =>
      this.request({
        service: 'atlas',
        resource: 'users/activations',
        method: 'POST',
        headers: {
          accept: 'application/json',
          authorization: token.toString(),
          'x-prelogin-userid': undefined
        },
        body: {email, reqId},
        shouldRefreshAccessToken: false
      });

    // Begin unauth user signin process.
    /* eslint-disable camelcase */
    const {client_id, client_secret} = this.webex.credentials.config;

    if (!client_id || !client_secret) {
      return Promise.reject(
        new Error('`client_id` or `client_secret` is not defined')
      );
    }
    /* eslint-enable camelcase */

    let token, output;

    return this.collectPreauthCatalog({email})
      .then(() => this.webex.credentials.getClientToken({
        // Core doesn't utilize the service plugin by default.
        // Inject the required uri via string literal.
        uri: `${this.get('idbroker', true, 'preauth')}idb/oauth2/v1/access_token`,
        scope: 'webexsquare:admin webexsquare:get_conversation Identity:SCIM'
      }))
      .then((tokenObj) => {
        token = tokenObj;

        return this.collectSigninCatalog({email, token: token.toString()});
      })
      // If signin catalog does not return 2xx
      .catch(() => {
        output = {
          activated: false,
          details: 'user does not exist or is not activated'
        };
      })
      // send activation / signin
      .then(() => {
        output = output || {
          activated: true,
          details: 'user exists and is activated'
        };

        return sendUserActivation(token);
      })
      .then(({body}) => ({...output, user: body}));
  },


  /**
   * simplified method to update the preauth catalog via email
   * @param {object} param
   * @param {string} param.email - must be a standard-format email
   * @returns {Promise<void>}
   */
  collectPreauthCatalog({email} = {}) {
    if (!email) {
      return Promise.reject(new Error('`email` is required'));
    }

    return this.updateServices({from: 'limited', query: {email}});
  },

  /**
   * simplified method to update the signin catalog via email and token
   * @param {object} param
   * @param {string} param.email - must be a standard-format email
   * @param {string} param.token - must be a client token
   * @returns {Promise<void>}
   */
  collectSigninCatalog({email, token} = {}) {
    if (!email) {
      return Promise.reject(new Error('`email` is required'));
    }
    if (!token) {
      return Promise.reject(new Error('`token` is required'));
    }

    return this.updateServices({from: 'signin', query: {email}, token});
  },

  /**
   * Updates credentials config to utilize u2c catalog
   * urls.
   * @returns {void}
   */
  updateCredentialsConfig() {
    const {idbroker, identity} = this.list(true);

    if (idbroker && identity) {
      this.webex.setConfig({
        credentials: {
          idbroker: {
            url: idbroker.slice(0, -1) // remove trailing slash
          },
          identity: {
            url: identity.slice(0, -1) // remove trailing slash
          }
        }
      });
    }
  },

  /**
   * Wait until the service catalog is available,
   * or reject afte ra timeout of 60 seconds.
   * @param {string} serviceGroup
   * @param {number} [timeout] - in seconds
   * @returns {Promise<void>}
   */
  waitForCatalog(serviceGroup, timeout) {
    const catalog = this._getCatalog();

    if (serviceGroup === 'postauth' &&
      this.webex.credentials.canAuthorize &&
      !catalog.status.postauth.collecting
    ) {
      return this.updateServices();
    }

    return catalog.waitForCatalog(serviceGroup, timeout);
  },

  /**
   * @private
   * Organize a received hostmap from a service
   * catalog endpoint.
   * @param {object} serviceHostmap
   * @returns {object}
   */
  _formatReceivedHostmap(serviceHostmap) {
    const output = [];
    let item = {};

    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {
      item = {};

      item.name = key;
      item.defaultUrl = serviceHostmap.serviceLinks[key];
      item.hosts = serviceHostmap.hostCatalog[Url.parse(item.defaultUrl).host];

      output.push(item);
    });

    return output;
  },

  /**
   * Get the clusterId associated with a URL string.
   * @param {string} url
   * @returns {string} - Cluster ID of url provided
   */
  getClusterId(url) {
    const catalog = this._getCatalog();

    return catalog.findClusterId(url);
  },

  /**
   * Get a service value from a provided clusterId. This method will
   * return an object containing both the name and url of a found service.
   * @param {object} params
   * @param {string} params.clusterId - clusterId of found service
   * @param {boolean} [params.priorityHost] - returns priority host url if true
   * @param {string} [params.serviceGroup] - specify service group
   * @returns {object} - {name: string, url: string}
   */
  getServiceFromClusterId(params) {
    const catalog = this._getCatalog();

    return catalog.findServiceFromClusterId(params);
  },

  /**
   * Verify that a provided url exists in the service
   * catalog.
   * @param {string} url
   * @returns {boolean} - true if exists, false otherwise
   */
  isServiceUrl(url) {
    const catalog = this._getCatalog();

    return !!(catalog.findServiceUrlFromUrl(url));
  },

  /**
   * @private
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @param {object} [param]
   * @param {string} [param.from] - This accepts `limited` or `signin`
   * @param {object} [param.query] - This accepts `email`, `orgId` or `userId` key values
   * @param {string} [param.query.email] - must be a standard-format email
   * @param {string} [param.query.orgId] - must be an organization id
   * @param {string} [param.query.userId] - must be a user id
   * @param {string} [param.token] - used for signin catalog
   * @returns {Promise<object>}
   */
  _fetchNewServiceHostmap({from, query, token} = {}) {
    const service = 'u2c';
    const resource = from ? `/${from}/catalog` : '/catalog';
    const qs = {...query, format: 'hostmap'};

    const requestObject = {
      method: 'GET', service, resource, qs
    };

    if (token) {
      requestObject.headers = {authorization: token};
    }

    return this.request(requestObject)
      .then(({body}) => this._formatReceivedHostmap(body));
  },

  /**
   * Initializer
   *
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize() {
    this._catalogs.set(this.webex, new ServiceCatalog());

    this.listenToOnce(this.webex, 'ready', () => {
      /* eslint-disable camelcase */
      if (this.webex.credentials.canAuthorize) {
        this.updateServices();
      }
      else if (this.webex.config.email) {
        this.updateServices({
          catalog: 'limited',
          query: {email: this.webex.config.email}
        });
      }
      /* eslint-enable camelcase */
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default Services;
