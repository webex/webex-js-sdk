/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {Interceptor} from '@webex/http-core';

const trailingSlashes = /(?:^\/)|(?:\/$)/;

/**
 * @class
 */
export default class ServiceInterceptor extends Interceptor {
  /**
   * @returns {ServiceInterceptor}
   */
  static create() {
    /* eslint no-invalid-this: [0] */
    return new ServiceInterceptor({webex: this});
  }

  /* eslint-disable no-param-reassign */
  /**
   * @see Interceptor#onRequest
   * @param {Object} options
   * @returns {Object}
   */
  onRequest(options) {
    const {services} = this.webex.internal;
    let service;

    // Populate option object's tag key.
    // A later PR will handle generating these tags at
    // request construction. These tags are used to validate
    // if a request has already been handled by a specific
    // interceptor. This is useful when multiple interceptors
    // operate on the same options object keys.
    if (!options.tags) { options.tags = {}; }

    // If an operation hasn't been made via
    // this interceptor...
    if (!options.tags.serviceInterceptor) {
      options.tags.serviceInterceptor = true;

      // Some plugins are sending requests directly via the
      // `uri` key. To not conflict with the `internal-plugin-wdm`
      // interceptors, we need to check the following two key values
      // to confirm an operation needs to be made.
      if (!options.service && !options.resource) {
        return options;
      }

      service = services.get(options.service, true, options.catalog);

      if (service) {
        this.validateOptions(options);

        options.uri = this.generateUrl(service, options.resource);

        return options;
      }

      if (this.webex.credentials.canAuthorize) {
        return services.waitForCatalog('postauth', 20)
          .then(() => {
            this.validateOptions(options);

            service = services.get(options.service, true, options.catalog);
            if (!service && options.uri) {
              return options;
            }

            if (!service) {
              throw new Error(`\`${options.service}\` is not a known service`);
            }

            options.uri = this.generateUrl(service, options.resource);

            return Promise.resolve(options);
          })
          .catch((e) => Promise.reject(e));
      }
    }

    return options;
  }
  /* eslint-enable no-param-reassign */

  /* eslint-disable class-methods-use-this */
  /**
   * Verify that all required parameters have been specified.
   * @param {object} options
   * @param {string} options.resource
   * @returns {void}
   */
  validateOptions(options) {
    // Validate a resource is present in the options object.
    if (!options.resource) {
      throw new Error('a `resource` parameter is required');
    }

    // Validate either uri or service is present in the options object.
    if (!options.service && !options.uri) {
      throw new Error('a valid `service` or `uri` parameter is required');
    }
  }

  /**
   * Safely generate a usable request uri string.
   * @param {string} service
   * @param {string} resource
   * @returns {boolean}
   */
  generateUrl(service, resource) {
    const formattedService = service.replace(trailingSlashes, '');
    const formattedResource = resource.replace(trailingSlashes, '');

    return `${formattedService}/${formattedResource}`;
  }
  /* eslint-enable class-methods-use-this */
}
