/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import bowser from 'bowser';
import '@webex/internal-plugin-lyra';
import {assert} from '@webex/test-helper-chai';
import retry from '@ciscospark/test-helper-retry';
import testUsers from '@ciscospark/test-helper-test-users';
// FIXME
// eslint-disable-next-line import/no-unresolved
import {generateRandomString} from '@ciscospark/test-users-legacy';
import CiscoSpark from '@webex/webex-core';
import '@webex/internal-plugin-locus';

describe('plugin-lyra', function () {
  this.timeout(30000);
  describe('Space', () => {
    let participants;
    let lyraMachine;
    let lyraSpace; // space with details of lyra URIs
    let spock;
    let conversation;

    before('create lyra machine', function () {
      this.timeout(retry.timeout(20000));

      return retry(() => testUsers.create({
        count: 1,
        config: {
          machineType: 'LYRA_SPACE',
          type: 'MACHINE',
          password: `${generateRandomString(32)}d_wA*`
        }
      }))
        .then((machines) => {
          lyraMachine = machines[0];
          lyraMachine.spark = new CiscoSpark({
            credentials: {
              authorization: lyraMachine.token
            }
          });

          // binding to conversation only works with spark board device
          lyraMachine.spark.internal.device.config.defaults.deviceType = 'SPARK_BOARD';
          lyraMachine.spark.internal.device.config.defaults.model = 'SparkBoard Test';
          lyraMachine.spark.internal.device.config.defaults.localizedModel = 'SparkJSSDKTest';
          lyraMachine.spark.internal.device.config.defaults.systemVersion = 'SparkJSSDKTest';
          lyraMachine.spark.internal.device.config.defaults.systemName = 'Darling';

          return lyraMachine.spark.internal.mercury.connect();
        })
        .then(() => lyraMachine.spark.internal.lyra.space.get({id: lyraMachine.id}))
        .then((space) => {
          lyraMachine.space = space;
          lyraSpace = Object.assign({}, space, {url: `/spaces/${space.identity.id}`});
        });
    });

    before('create users', () => testUsers.create({count: 2})
      .then((users) => {
        participants = users;
        spock = participants[0];

        return Promise.all(Array.map(participants, (participant) => {
          participant.spark = new CiscoSpark({
            credentials: {
              authorization: participant.token
            }
          });

          return participant.spark.internal.mercury.connect();
        }));
      }));

    before('create conversation', () => retry(() => participants[0].spark.internal.conversation.create({
      displayName: 'Test Lyra Conversation',
      participants
    }))
      .then((c) => {
        conversation = c;

        return conversation;
      }));

    describe('#list()', () => {
      before('ensure participant joined space', () => spock.spark.internal.lyra.space.join(lyraSpace));

      it('returns spaces', () => spock.spark.internal.lyra.space.list()
        .then((spaces) => {
          assert.lengthOf(spaces, 1);
          assert.deepEqual(spaces[0].identity, lyraMachine.space.identity);
        }));
    });

    describe('#get()', () => {
      it('returns space info', () => spock.spark.internal.lyra.space.get(lyraMachine.space)
        .then((lyraSpace) => assert.deepEqual(lyraMachine.space.identity, lyraSpace.identity)));
    });

    describe('#join()', () => {
      it('adds the current user to lyra space', () => spock.spark.internal.lyra.space.join(lyraSpace)
        .then(() => lyraMachine.spark.internal.lyra.space.get(lyraMachine.space))
        .then((lyraSpace) => {
          assert.lengthOf(lyraSpace.occupants.items, 1);
          assert.equal(lyraSpace.occupants.items[0].identity.id, spock.id);
        }));
    });

    describe('#leave()', () => {
      it('removes the current user from lyra space', () => spock.spark.internal.lyra.space.join(lyraSpace)
        .then(() => spock.spark.internal.lyra.space.leave(lyraSpace))
        .then(() => lyraMachine.spark.internal.lyra.space.get(lyraMachine.space))
        .then((lyraSpace) => assert.lengthOf(lyraSpace.occupants.items, 0)));

      describe('when a user has multiple devices in the space', () => {
        before('add another device', () => {
          spock.spark2 = new CiscoSpark({
            credentials: {
              authorization: spock.token
            }
          });

          return spock.spark2.internal.device.register()
            .then(() => spock.spark.internal.lyra.space.join(lyraSpace))
            .then(() => spock.spark2.internal.lyra.space.join(lyraSpace));
        });

        it('removes all devices from lyra space', () => spock.spark.internal.lyra.space.leave(lyraSpace, {
          removeAllDevices: true
        })
          .then(() => lyraMachine.spark.internal.lyra.space.get(lyraMachine.space))
          .then((lyraSpace) => assert.lengthOf(lyraSpace.occupants.items, 0)));
      });
    });


    describe('#bindConversation()', () => {
      before('ensure participant joined space', () => spock.spark.internal.lyra.space.join(lyraSpace)
        .then(() => lyraMachine.spark.internal.lyra.space.verifyOccupant(lyraMachine.space, spock.id))
        .then(() => spock.spark.internal.lyra.space.bindConversation(lyraSpace, conversation)));

      after('remove binding', () => spock.spark.internal.lyra.space.unbindConversation(lyraSpace, conversation)
        // After hooks shouldn't be able to break tests
        .catch((err) => console.error(err)));

      it('binds conversation and lyra space', () => spock.spark.internal.lyra.space.getCurrentBindings(lyraMachine.space)
        .then(({bindings}) => {
          assert.lengthOf(bindings, 1);
          assert.equal(bindings[0].conversationUrl, conversation.url);
        }));
    });

    describe('#unbindConversation()', () => {
      before('ensure participant joined space', () => spock.spark.internal.lyra.space.join(lyraSpace)
        .then(() => lyraMachine.spark.internal.lyra.space.verifyOccupant(lyraMachine.space, spock.id))
        .then(() => spock.spark.internal.lyra.space.bindConversation(lyraSpace, conversation))
        .then(() => spock.spark.internal.lyra.space.getCurrentBindings(lyraMachine.space))
        .then(({bindings}) => assert.lengthOf(bindings, 1)));

      // Skip this feature in IE. We do not support it at this time.
      (bowser.msie ? it.skip : it)('removes the binding between conversation and lyra space', () => spock.spark.internal.lyra.space.unbindConversation(lyraSpace, conversation)
        .then(() => spock.spark.internal.lyra.space.getCurrentBindings(lyraMachine.space))
        .then(({bindings}) => assert.lengthOf(bindings, 0)));
    });

    describe('#deleteBinding()', () => {
      let bindingId;

      before('ensure participant joined space', () => spock.spark.internal.lyra.space.join(lyraSpace)
        .then(() => lyraMachine.spark.internal.lyra.space.verifyOccupant(lyraMachine.space, spock.id))
        .then(() => spock.spark.internal.lyra.space.bindConversation(lyraSpace, conversation))
        .then(() => spock.spark.internal.lyra.space.getCurrentBindings(lyraMachine.space))
        .then(({bindings}) => {
          assert.lengthOf(bindings, 1);
          bindingId = bindings[0].bindingUrl.split('/').pop();
        }));

      // Skip this feature in IE. We do not support it at this time.
      (bowser.msie ? it.skip : it)('removes the binding between conversation and lyra space', () => spock.spark.internal.lyra.space.deleteBinding(lyraMachine.space, {kmsResourceObjectUrl: conversation.kmsResourceObjectUrl, bindingId})
        .then(() => spock.spark.internal.lyra.space.getCurrentBindings(lyraMachine.space))
        .then(({bindings}) => assert.lengthOf(bindings, 0)));
    });
  });
});
