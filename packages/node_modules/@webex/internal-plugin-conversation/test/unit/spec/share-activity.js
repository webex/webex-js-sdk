/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@webex/test-helper-chai';
import {ShareActivity} from '@webex/internal-plugin-conversation';
import Conversation from '@webex/internal-plugin-avatar';
import sinon from 'sinon';
import MockWebex from '@webex/test-helper-mock-webex';
import sha256 from 'crypto-js/sha256';
import fh from '@webex/test-helper-file';
import testUsers from '@webex/test-helper-test-users';
import {browserOnly, flaky, nodeOnly} from '@webex/test-helper-mocha';
import WebexCore from '@webex/webex-core';
import * as helperImage from '@webex/helper-image';
import config from '@webex/internal-plugin-conversation/src/config';


describe('plugin-conversation', () => {
  describe('ShareActivity', () => {
    describe('#_determineContentCategory', () => {
      let sa;

      beforeEach(() => {
        sa = new ShareActivity();
      });
      
      it('returns "documents" when not all files have a mimeType', () => {
        const items = [
          {mimeType: 'image/png'},
          {}
        ];

        assert.equal(sa._determineContentCategory(items), 'documents');
      });

      it('returns "documents" for non-homogenous mimeTypes', () => {
        const items = [
          {mimeType: 'image/png'},
          {mimeType: 'video/h264'}
        ];

        assert.equal(sa._determineContentCategory(items), 'documents');
      });

      it('returns "documents" if the potentially homogenous mimeType is not image or video', () => {
        const items = [
          {mimeType: 'application/xml'},
          {mimeType: 'application/xml'}
        ];

        assert.equal(sa._determineContentCategory(items), 'documents');
      });

      it('returns "image" if all mimeTypes are image', () => {
        const items = [
          {mimeType: 'image/png'},
          {mimeType: 'image/jpg'}
        ];

        assert.equal(sa._determineContentCategory(items), 'images');
      });

      it('returns "video" if all mimeTypes are video', () => {
        const items = [
          {mimeType: 'video/h264'},
          {mimeType: 'video/vp8'}
        ];

        assert.equal(sa._determineContentCategory(items), 'videos');
      });

      it('returns "documents" if a whiteboard mimeType is found in item.actions', () => {
        const items = [
          {
            mimeType: 'image/png',
            actions: [{
              mimeType: 'application/x-cisco-webex-whiteboard',
              type: 'edit',
              url: 'https://boards.example.com/boards/1'
            }]
          }
        ];

        assert.equal(sa._determineContentCategory(items), 'documents');
      });
    });
    describe('#upload', () => {
      let webex;
      const fakeURL = 'https://encryption-a.wbx2.com/encryption/api/v1/keys/8a7d3d78-ce75-48aa-a943-2e8acf63fbc9';

      before(() => {
        webex = new MockWebex({
          upload: sinon.stub().returns(Promise.resolve({body: {downloadUrl: fakeURL}}))
        });
      });

      it('checks whether filehash is sent in body while making a call to /finish API', () => {
        const spy = sinon.spy(webex.upload);
        const fileSize = 3333;
        const fileHash = sha256(fakeURL).toString();

        const inputData = {
          phases: {
            initialize: {
              fileSize
            },
            finalize: {
              body: {
                fileSize,
                fileHash
              }
            }
          }
        };

        spy(inputData);

        assert.isTrue(spy.calledWith(inputData));
      });
    });

    describe('#addGif', () => {
      let buffer, blob, shareActivity;//, webex;

      /*beforeEach(() => {
        webex = new MockWebex({
          children: {
            conversation: Conversation
          }
        });
        //webex.config.conversation = config.conversation;
      });*/

      beforeEach(() => {
        shareActivity = new ShareActivity();
      });
      

      it('if the giphy already exists, then do not add to this.uploads', () => {
        const fakeGif = {name: 'happy gif.gif'};

        shareActivity.uploads.set(fakeGif, {}); // add fake gif preemptively, mocking that we already added a gif
        shareActivity.addGif(fakeGif); // attemp to add the same gif again

        // check that the gif was not added via addGif
        assert.isTrue(shareActivity.uploads.size === 1);
      });

      browserOnly(before)(() => fh.fetch('happy best gif GIF.gif')
        .then((file) => {
          blob = file;

          return new Promise((resolve) => {
            /* global FileReader */
            const fileReader = new FileReader();

            fileReader.onload = function () {
              buffer = this.result;
              resolve();
            };
            fileReader.readAsArrayBuffer(blob);
          });
        }));

      nodeOnly(before)(() => fh.fetch('happy best gif GIF.gif')
        .then((file) => {
          buffer = file;
      }));

      browserOnly(it)('if the giphy does not exist, then we check it gets added to this.uploads', (done) => {
        const file = new File([buffer], blob.name, {type: 'image/gif'});
        Object.defineProperty(file, 'giphyURL', {value: 'https://media1.giphy.com/media/nXxOjZrbnbRxS/giphy.gif'});
        Object.defineProperty(file, 'thumbnailURL', {value: 'https://media1.giphy.com/media/nXxOjZrbnbRxS/giphy_s.gif'});

        // eslint-disable-line
        debugger;
        assert.isTrue(shareActivity.uploads.size === 0);
        shareActivity.addGif(file);
        console.log(shareActivity.uploads);
        assert.isTrue(shareActivity.uploads.size === 1);
        done();
      });
    });
  });
});
