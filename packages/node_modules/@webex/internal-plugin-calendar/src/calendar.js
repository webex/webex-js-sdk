/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

/**
   * Calendar Item Create Event
   * Emitted when a calendar item has been added
   * @event calendar:meeting:create
   * @instance
   * @memberof Calendar
   */

/**
   * Calendar Item Update Event
   * Emitted when a calendar item has been updated
   * @event calendar:meeting:update
   * @instance
   * @memberof Calendar
   */

/**
   * Calendar Item Update Event
   * Emitted when a calendar item has been deleted
   * @event calendar:meeting:delete
   * @instance
   * @memberof Calendar
   */

import {WebexPlugin} from '@webex/webex-core';

import CalendarCollection from './collection';

const Calendar = WebexPlugin.extend({
  namespace: 'Calendar',

  /**
   * registers for calendar events through mercury
   * @returns {undefined}
   */
  register() {
    // Calendar mercury events listener
    this.webex.internal.mercury.on('event:calendar.meeting.create', (envelope) => {
      this._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update', (envelope) => {
      this._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.create.minimal', (envelope) => {
      this._handleCreate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.update.minimal', (envelope) => {
      this._handleUpdate(envelope.data);
    });
    this.webex.internal.mercury.on('event:calendar.meeting.delete', (envelope) => {
      this._handleDelete(envelope.data);
    });
  },

  /**
   * handles update events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleUpdate(data) {
    const id = CalendarCollection.set(data.calendarMeetingExternal);

    this.trigger('calendar:meeting:update', CalendarCollection.get(id));
  },

  /**
   * handles create events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleCreate(data) {
    const id = CalendarCollection.set(data.calendarMeetingExternal);

    this.trigger('calendar:meeting:create', CalendarCollection.get(id));
  },

  /**
   * handles delete events, triggers after collection updates
   * @param {Object} data
   * @returns {undefined}
   * @private
   */
  _handleDelete(data) {
    const item = CalendarCollection.remove(data.calendarMeetingExternal.id);

    this.trigger('calendar:meeting:delete', item);
  },

  /**
   * Retrieves a collection of meetings based on the request parameters
   * Defaults to 1 day before and 7 days ahead
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of meetings
   */
  populate(options = {fromDate: this.config.fromDate, toDate: this.config.toDate}) {
    this.list({fromDate: options.fromDate, toDate: options.toDate}).then((res) => {
      CalendarCollection.setAll(res);
    });
  },

  /**
   * bucket meetings by date
   * @todo
   * @returns {undefined}
   */
  sortByDate() {
    // TODO:
  },

  /**
   * get the calendar item that has a matching value
   * @param {String} key meeting property
   * @param {Any} value the meeting property to match
   * @returns {Object}
   */
  getByType(key, value) {
    if (['spaceURI', 'spaceMeetURL', 'conversationId'].includes(key)) {
      return CalendarCollection.getBy(key, value);
    }
    throw new Error('key must be one of, spaceURI, spaceMeetURL, or conversationId');
  },

  /**
   * gets all the calendar items that have been populated
   * @returns {Object}
   */
  getAll() {
    return CalendarCollection.getAll();
  },

  /**
   * Decrypts an encrypted incoming calendar event
   * @param {Object} event
   * @returns {Promise} Resolves with a decrypted calendar event
   */
  processMeetingEvent(event) {
    return this.webex.transform('inbound', event)
      .then(() => event);
  },

  /**
   * Retrieves a collection of meetings based on the request parameters
   * @param {Object} options
   * @param {Date} options.fromDate the start of the time range
   * @param {Date} options.toDate the end of the time range
   * @returns {Promise} Resolves with an array of meetings
   */
  list(options) {
    options = options || {};

    return this.webex.request({
      method: 'GET',
      service: 'calendar',
      resource: 'calendarEvents',
      qs: options
    })
      .then((res) => res.body.items);
  }
});

export default Calendar;
