/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {get} from 'lodash';
import {oneFlight} from '@webex/common';
import {WebexPlugin} from '@webex/webex-core';

const Search = WebexPlugin.extend({
  namespace: 'Search',

  people(options) {
    options = options || {};

    if (!options.queryString && options.query) {
      options.queryString = options.query;
      Reflect.deleteProperty(options, 'query');
    }

    if (!options.queryString) {
      return Promise.reject(new Error('`options.query` is required'));
    }

    return this.request({
      api: 'argonaut',
      resource: 'directory',
      method: 'POST',
      body: options
    })
      .then((res) => res.body);
  },

  @oneFlight
  bindSearchKey() {
    return this.webex.internal.encryption.kms.createUnboundKeys({count: 1})
      .then(([key]) => this.webex.internal.encryption.kms.createResource({
        key,
        userIds: [this.webex.internal.device.userId]
      })
        .then(() => this.webex.internal.device.set('searchEncryptionKeyUrl', key.uri)));
  },

  search(options) {
    /* eslint max-nested-callbacks: [0] */
    options = options || {};

    let promise = Promise.resolve();

    if (!this.webex.internal.device.searchEncryptionKeyUrl) {
      promise = this.bindSearchKey();
    }

    return promise
      .then(() => this.webex.request({
        service: 'argonaut',
        resource: 'search',
        method: 'POST',
        body: Object.assign(options, {
          searchEncryptionKeyUrl: this.webex.internal.device.searchEncryptionKeyUrl
        })
      }))
      .then((res) => {
        const resActivities = get(res, 'body.activities.items', []);

        return (options.breadcrumbsEnabled ? {
          activities: resActivities,
          breadcrumbs: get(res, 'body.breadcrumbs', {})
        } : resActivities);
      });
  }

});

export default Search;
