/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {oneFlight} from '@webex/common';
import {safeSetTimeout} from '@webex/common-timers';
import {omit, find} from 'lodash';
import util from 'util';
import FeaturesModel from './features-model';
import ServiceCollection from './service-collection';
import {persist, waitForValue, WebexPlugin} from '@webex/webex-core';
import Url from 'url';


/**
 * Decides if this device should be persisted to boundedStorage, based on
 * this.config.ephemeral.
 * @returns {Boolean}
 */
function decider() {
  return !this.config.ephemeral;
}

const Device = WebexPlugin.extend({
  children: {
    features: FeaturesModel
  },

  collections: {
    serviceCatalog: ServiceCollection
  },

  idAttribute: 'url',

  namespace: 'Device',

  props: {
    /**
     * Notifies the client if giphys are enabled.
     * Currently, the values for it are:
     * - ALLOW
     * - BLOCK
     * @instance
     * @memberof Device
     * @type {string}
     */
    clientMessagingGiphy: 'string',
    customerCompanyName: 'string',
    customerLogoUrl: 'string',
    // deviceType doesn't have any real value, but we need to send it during
    // device refresh to make sure we don't get back an ios device url
    deviceType: 'string',
    helpUrl: 'string',
    intranetInactivityDuration: 'number',
    intranetInactivityCheckUrl: 'string',
    inNetworkInactivityDuration: 'number', // Newly added duration for internal network inactivity
    /**
     * Is ECM (external content management) enabled for the whole org
     * @instance
     * @memberof Device
     * @type {boolean}
     */
    ecmEnabledForAllUsers: {
      type: 'boolean',
      default: () => false
    },
    /**
     * What ECM providers are available
     * @instance
     * @memberof Device
     * @type {string[]}
     */
    ecmSupportedStorageProviders: {
      type: 'array',
      default: () => []
    },
    modificationTime: 'string',
    partnerCompanyName: 'string',
    partnerLogoUrl: 'string',
    peopleInsightsEnabled: 'boolean',
    reportingSiteDesc: 'string',
    reportingSiteUrl: 'string',
    searchEncryptionKeyUrl: 'string',
    // services is obsoleted and will be deprecated
    services: {
      // Even though @jodykstr will tell you the docs claim you don't need to
      // initialize `object` properties, the docs lie.
      default() {
        return {};
      },
      type: 'object'
    },
    serviceHostMap: {
      default() {
        return {
          serviceLinks: {},
          hostCatalog: {}
        };
      },
      type: 'object'
    },
    showSupportText: 'boolean',
    supportProviderCompanyName: 'string',
    supportProviderLogoUrl: 'string',
    url: 'string',
    userId: 'string',
    /**
     * Notifies the client if file sharing is disabled.
     * Currently, the values for it are:
     * - BLOCK_BOTH
     * - BLOCK_UPLOAD
     * @instance
     * @memberof Device
     * @type {string}
     */
    webFileShareControl: 'string',
    webSocketUrl: 'string',
    /**
     * Notifies the client if whiteboarding should be allowed
     * regardless of webFileShareControl settings.
     * Currently, the values for it are:
     * - ALLOW
     * - BLOCK
     * @instance
     * @memberof Device
     * @type {string}
     */
    whiteboardFileShareControl: 'string'
  },

  derived: {
    registered: {
      deps: ['url'],
      fn() {
        return Boolean(this.url);
      }
    }
  },

  session: {
    // Fun Fact: setTimeout returns a Timer object instead of a Number in Node 6
    // or later
    logoutTimer: 'any',
    lastUserActivityDate: 'number',
    isReachabilityChecked: 'boolean', // To prevent url reachabilty from being called more than once on successful check.
    isInMeeting: 'boolean', // Boolean for checking user is in meeting to prevent in advertent timeout due to inactivity
    isInNetwork: 'boolean' // Boolean to ensure _resetLogoutTimer isn't called repeatedly once its known client is connected to org's internal network
  },

  @waitForValue('@')
  determineService(url) {
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      for (const key of Object.keys(this.serviceHostMap.serviceLinks)) {
        const serviceUrl = this.serviceHostMap.serviceLinks[key];

        if (url.startsWith(serviceUrl)) {
          return Promise.resolve(key);
        }
      }
    }
    else {
      for (const key of Object.keys(this.services)) {
        const serviceUrl = this.services[key];

        if (url.startsWith(serviceUrl)) {
        // "ServiceUrl" is 10 characters
          return Promise.resolve(key.substr(0, key.length - 10));
        }
      }
    }

    return Promise.reject(new Error(`${url} does not reflect a known service`));
  },

@waitForValue('@')
  getServiceUrl(service) {
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      return this._getServiceUrl(this.serviceHostMap.serviceLinks, service)
        .then((isServiceUrl) => isServiceUrl || this.getPreDiscoveryServiceUrl(service));
    }

    return this._getServiceUrl(this.services, service)
      .then((isServiceUrl) => isServiceUrl || this.getPreDiscoveryServiceUrl(service));
  },

  getPreDiscoveryServiceUrl(service) {
  // The Promise.resolve here is temporary. A future PR will make the
  // corresponding _ method async to allow for lazy device registration
    return Promise.resolve(this._getServiceUrl(this.config.preDiscoveryServices, service));
  },

  getWebSocketUrl() {
    return this.useServiceCatalogUrl(this.webSocketUrl);
  },

  useServiceCatalogUrl(uri) {
    return this.serviceCatalog.inferServiceFromUrl(uri)
      .then((s) => s.replaceUrlWithCurrentHost(uri));
  },

  markUrlFailedAndGetNew(url) {
    if (!url) {
      return Promise.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info(`device: marking ${url} as failed`);

    return this.serviceCatalog.markFailedAndCycleUrl(url)
      .then((uri) => {
        this.webex.internal.metrics.submitClientMetrics('web-ha', {
          tags: {
            action: 'replace_url',
            failedUrl: url,
            newUrl: uri
          }
        });

        return uri;
      })
    // it's likely we fail here because we've cycled though all hosts,
    // reset all hosts and then retry connecting
      .catch(() => this._resetAllAndRetry(url));
  },

  _resetAllAndRetry(url) {
    if (!url) {
      return Promise.reject(new Error('`url` is a required parameter'));
    }

    this.logger.info(`device: reset available hosts and retry ${url}`);

    return this.serviceCatalog.resetAllAndRetry(url);
  },

  // this function is exposed beyond the device file
  fetchNewUrls(url) {
  // we want to get the current service first, just in case the
  // refreshed catalog has different host names
    return new Promise((resolve) => this.serviceCatalog.inferServiceFromUrl(url)
      .then((s) => {
        this.logger.info(`device: refresh to ${s.service} get new urls`);
        this.refresh();
        this.on('serviceCatalogUpdated', () => resolve(s.url));
      }));
  },

@persist('@', decider)
  initialize(...args) {
    Reflect.apply(WebexPlugin.prototype.initialize, this, args);

    // Propagate change(:[attribute]) events from collections
    ['developer', 'entitlement', 'user'].forEach((collectionName) => {
      this.features.on(`change:${collectionName}`, (model, value, options) => {
        this.trigger('change', this, options);
        this.trigger('change:features', this, this.features, options);
      });
    });

    // Initialize it to false.
    this.isReachabilityChecked = false;

    this.on('change:serviceHostMap', this._updateServiceCatalog);

    this.listenToAndRun(this, 'change:intranetInactivityCheckUrl', () => { this.testNetworkReachability(); });
    this.listenToAndRun(this, 'change:intranetInactivityDuration', () => { this.testNetworkReachability(); });
    this.listenToAndRun(this, 'change:inNetworkInactivityDuration', () => { this.testNetworkReachability(); });
    this.listenTo(this.webex, 'user-activity', () => {
      this.lastUserActivityDate = Date.now();
    });
    /**
   * Meeting started and ended event listenrs
   * When client enters into the meeting set isInMeeting to true
   * This tells also triggers both the timers inturn un-setting the timers until meeting ends
   * On meeting end/clean-up the timers are reset.
   */
    this.listenTo(this.webex, 'meeting started', () => {
      this.isInMeeting = true;
      this._resetLogoutTimer();
    });
    this.listenTo(this.webex, 'meeting ended', () => {
      this.isInMeeting = false;
      this._resetLogoutTimer();
    });
  },

  /**
 * Don't log the features object
 * @param {number} depth
 * @returns {Object}
 */
  inspect(depth) {
    return util.inspect(omit(this.serialize(), 'features'), {depth});
  },

  isPreDiscoveryService(service) {
  // The Promise.resolve here is temporary. A future PR will make the
  // corresponding _ method async to allow for lazy device registration
    return Promise.resolve(this._isService(this.config.preDiscoveryServices, service));
  },

  /**
 * Meeting started and Meeting Ended
 * These are device.internal functions that can be accessible from web-client
 * These are used to trigger the events for meeting start/end from within web client.
 * @returns {boolean}
 */
  meetingStarted() {
    this.webex.trigger('meeting started');
  },
  /**
 * Meeting started and Meeting Ended
 * These are device.internal functions that can be accessible from web-client
 * These are used to trigger the events for meeting start/end from within web client.
 * @returns {boolean}
 */
  meetingEnded() {
    this.webex.trigger('meeting ended');
  },

  testNetworkReachability() {
    if (this.isReachabilityChecked) {
      return this._resetLogoutTimer();
    }

    if (!this.intranetInactivityCheckUrl) {
      this.isInNetwork = false;

      return this._resetLogoutTimer();
    }

    this.isReachabilityChecked = true;
    this.webex.request({
      headers: {
        'cisco-no-http-redirect': null,
        'spark-user-agent': null,
        trackingid: null
      },
      method: 'GET',
      uri: this.intranetInactivityCheckUrl
    })
      .then(() => {
        this.isInNetwork = true;

        return this._resetLogoutTimer();
      })
      .catch(() => {
        this.logger.info('device: did not reach internal ping endpoint; Setting off-network timer');
        this.isInNetwork = false;

        return this._resetLogoutTimer();
      });

    // Added due to eslint error.
    return true;
  },

  isPreDiscoveryServiceUrl(uri) {
    if (!uri) {
      return Promise.reject(new Error('`uri` is a required parameter'));
    }

    // The Promise.resolve here is temporary. A future PR will make the
    // corresponding _ method async to allow for lazy device registration
    return Promise.resolve(this._isServiceUrl(this.config.preDiscoveryServices, uri));
  },

@waitForValue('@')
  isService(service) {
    if (service === 'idbroker') {
      return Promise.resolve(false);
    }
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      return this._isService(this.serviceHostMap.serviceLinks, service)
        .then((_isService) => _isService || this.isPreDiscoveryService(service));
    }

    return this._isService(this.services, service)
      .then((_isService) => _isService || this.isPreDiscoveryService(service));
  },

@waitForValue('@')
  isServiceUrl(uri) {
  // The Promise.resolve here is temporary. A future PR will make the
  // corresponding _ method async to allow for lazy device registration
    if (!uri) {
      return Promise.reject(new Error('`uri` is a required parameter'));
    }
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      if (this._isServiceUrl(this.serviceHostMap.serviceLinks, uri) ||
      this._isServiceUrlFromCatalog(this.serviceHostMap.hostCatalog, uri)) {
        return Promise.resolve(true);
      }

      return Promise.resolve(false);
    }

    return Promise.resolve(this._isServiceUrl(this.services, uri));
  },

@waitForValue('@')
  isSpecificService(service, key) {
    if (key === service) {
      return Promise.resolve(true);
    }

    return this.getServiceUrl(service)
      .then((serviceUrl) => key.includes(serviceUrl));
  },

  _getServiceUrl(target, service) {
  /* istanbul ignore if */
    if (!service) {
      return Promise.reject(new Error('`service` is a required parameter'));
    }

    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      const s = this.serviceCatalog.get(service);

      if (s) {
        return Promise.resolve(s.url);
      }
    }

    if (!target) {
      return Promise.reject(new Error('`target` is a required parameter'));
    }

    return Promise.resolve(target[`${service}ServiceUrl`]);
  },

  _isService(target, service) {
    return this._getServiceUrl(target, service)
      .then((url) => Boolean(url));
  },

  _isServiceUrl(target, uri) {
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      for (const key of Object.keys(target)) {
        const serviceUrl = target[key];

        if (key !== 'idbroker' && uri.startsWith(serviceUrl)) {
          return true;
        }
      }
    }
    else {
      for (const value of Object.values(target)) {
        if (value && uri.startsWith(value)) {
          return Promise.resolve(true);
        }
      }
    }

    return false;
  },

  _isServiceUrlFromCatalog(hostCatalog, uri) {
    const hostName = Url.parse(uri).hostname;

    if (hostName && !hostName.includes('idbroker') &&
    find(hostCatalog, (service) => find(service, (availableHost) => availableHost.host === hostName))) {
      return true;
    }

    return false;
  },

@oneFlight
@waitForValue('@')
  refresh() {
    this.logger.info('device: refreshing');

    if (!this.registered) {
      this.logger.info('device: device not registered, registering');

      return this.register();
    }

    const body = omit(this.serialize(), 'features', 'mediaClusters');

    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'PUT',
      uri: this.url,
      body
    })
      .then((res) => this._processRegistrationSuccess(res))
      .catch((reason) => {
        if (reason.statusCode === 404) {
        // If we get a 404, it means the device is no longer valid and we need
        // to register a new one.
          this.logger.info('device: refresh failed with 404, attempting to register new device');
          this.clear();

          return this.register();
        }

        return Promise.reject(reason);
      });
  },

@oneFlight
@waitForValue('@')
  register() {
  /* eslint no-invalid-this: [0] */
    this.logger.info('device: registering');

    if (this.registered) {
      this.logger.info('device: device already registered, refreshing');

      return this.refresh();
    }

    const body = this.config.defaults;

    if (this.config.ephemeral) {
      body.ttl = this.config.ephemeralDeviceTTL;
    }

    return this.request({
      method: 'POST',
      service: 'wdm',
      resource: 'devices',
      body
    })
      .then((res) => this._processRegistrationSuccess(res));
  },

@oneFlight
@waitForValue('@')
  unregister() {
    this.logger.info('device: unregistering');

    if (!this.url) {
      this.logger.warn('device: not registered');

      return Promise.resolve();
    }

    return this.request({
      uri: this.url,
      method: 'DELETE'
    })
      .then(() => this.clear());
  },

  clear(...args) {
    clearTimeout(this.refreshTimer);
    Reflect.apply(WebexPlugin.prototype.clear, this, args);
  },

  _processRegistrationSuccess(res) {
    this.logger.info('device: received registration payload');
    this.set(res.body);
    if (this.config.ephemeral) {
      this.logger.info('device: enqueing device refresh');
      const delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;

      this.refreshTimer = safeSetTimeout(() => this.refresh(), delay);
    }
  },

  _updateServiceCatalog(newRegistration) {
    const feature = this.features.developer.get('web-high-availability');

    if (feature && feature.value) {
      if (newRegistration.serviceHostMap &&
      newRegistration.serviceHostMap.serviceLinks &&
      newRegistration.serviceHostMap.hostCatalog) {
        Object.keys(newRegistration.serviceHostMap.serviceLinks).forEach((key) => {
          const hostName = Url.parse(newRegistration.serviceHostMap.serviceLinks[key]).hostname;
          const hosts = newRegistration.serviceHostMap.hostCatalog[hostName];

          this.serviceCatalog.set({
            service: key,
            defaultUrl: newRegistration.serviceHostMap.serviceLinks[key],
            availableHosts: hosts || []
          }, {remove: false});
        });
        this.trigger('serviceCatalogUpdated');
      }
      else {
      // if user has old device in localStorage, refresh device
        this.refresh();
      }
    }
  },

  _resetLogoutTimer() {
    // Clear any previously set timers and listeners
    clearTimeout(this.logoutTimer);
    this.off('change:lastUserActivityDate'); // removes previous event listener
    this.unset('logoutTimer');

    if (!this.isInMeeting && this.config.enableInactivityEnforcement && this.isReachabilityChecked) {
      if (this.isInNetwork) {
        this._setLogoutTimer(this.inNetworkInactivityDuration);
      }
      else {
        this._setLogoutTimer(this.intranetInactivityDuration);
      }
    }
  },

  _setLogoutTimer(duration) {
    if (!duration || (duration && duration === -1)) {
      return;
    }
    this.on('change:lastUserActivityDate', () => { this._resetLogoutTimer(); });
    const timer = safeSetTimeout(() => {
      this.webex.logout();
    }, duration * 1000);

    this.logoutTimer = timer;
  }

});

export default Device;
