/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@webex/test-helper-chai';
import MockWebex from '@webex/test-helper-mock-webex';
import sinon from 'sinon';
import Device, {config} from '@webex/internal-plugin-wdm';
import {cloneDeep} from 'lodash';
import lolex from 'lolex';
import {skipInBrowser} from '@webex/test-helper-mocha';

function promiseTick(count) {
  let promise = Promise.resolve();

  while (count > 1) {
    promise = promise.then(() => promiseTick(1));
    count -= 1;
  }

  return promise;
}

describe('plugin-wdm', () => {
  describe('Device', () => {
    let device, webex;

    beforeEach(() => {
      webex = new MockWebex({
        children: {
          device: Device
        },
        config: cloneDeep(config)
      });

      device = webex.internal.device;

      assert.isFalse(webex.internal.device.config.ephemeral);
      assert.equal(webex.internal.device.config.ephemeralDeviceTTL, config.device.ephemeralDeviceTTL);
    });

    afterEach(() => device.unregister());

    let clock;

    beforeEach(() => {
      clock = lolex.install({now: Date.now()});
    });

    afterEach(() => {
      clock.uninstall();
    });

    describe('#register()', () => {
      it('does not included a ttl', () => webex.internal.device.register()
        .then(() => {
          const req = webex.request.args[0][0];

          assert.notProperty(req, 'uri', 'this request hits a service/resource pair, not a uri');
          assert.notProperty(req.body, 'ttl');
        }));
    });

    describe('#refresh()', () => {
      it('includes a ttl', () => {
        webex.internal.device.url = 'http://example.com/device/id';

        return webex.internal.device.refresh()
          .then(() => {
            const req = webex.request.args[0][0];

            assert.equal(req.uri, webex.internal.device.url);
            assert.notProperty(req.body, 'ttl');
          });
      });
    });

    describe('when ephemeral', () => {
      beforeEach(() => {
        webex.internal.device.config.ephemeral = true;
        assert.isTrue(webex.internal.device.config.ephemeral);
        assert.equal(webex.internal.device.config.ephemeralDeviceTTL, config.device.ephemeralDeviceTTL);
      });

      describe('#register()', () => {
        it('includes a ttl', () => webex.internal.device.register()
          .then(() => {
            const {body} = webex.request.args[0][0];

            assert.property(body, 'ttl');
            assert.equal(body.ttl, config.device.ephemeralDeviceTTL);
          }));

        // skipping due to an aparent incompatibility between lolex and all
        // browsers but chrome
        skipInBrowser(it)('periodically refreshes the device', () => {
          sinon.spy(webex.internal.device, 'refresh');
          webex.internal.device.register();

          return promiseTick(80)
            .then(() => {
              assert.notCalled(webex.internal.device.refresh);
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.notCalled(webex.internal.device.refresh);

              return promiseTick(80);
            })
            .then(() => {
              clock.tick(60 * 1000);

              return promiseTick(80);
            })
            .then(() => {
              assert.calledOnce(webex.internal.device.refresh);

              return promiseTick(4);
            })
            .then(() => {
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.calledOnce(webex.internal.device.refresh);
              clock.tick(60 * 1000);
              assert.calledTwice(webex.internal.device.refresh);
            });
        });
      });

      describe('#refresh()', () => {
        it('includes a ttl', () => {
          webex.internal.device.url = 'http://example.com/device/id';

          return webex.internal.device.refresh()
            .then(() => {
              const {body} = webex.request.args[0][0];

              assert.property(body, 'ttl');
              assert.equal(body.ttl, config.device.ephemeralDeviceTTL);
            });
        });
      });

      describe('#unregister()', () => {
        // skipping due to an aparent incompatibility between lolex and all
        // browsers but chrome
        skipInBrowser(it)('stops refreshing the device', () => {
          sinon.spy(webex.internal.device, 'refresh');
          webex.internal.device.register();

          return promiseTick(8)
            .then(() => {
              webex.internal.device.url = 'http://example.com/device/id';
              assert.notCalled(webex.internal.device.refresh);
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.notCalled(webex.internal.device.refresh);
              clock.tick(60 * 1000);
              assert.calledOnce(webex.internal.device.refresh);
              webex.internal.device.unregister();

              // Reminder: for this to be a valid test, the number of ticks on
              // the next line must be at least as many ticks as are advanced in
              // the refresh test.
              return promiseTick(4);
            })
            .then(() => {
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.calledOnce(webex.internal.device.refresh);
              clock.tick(60 * 1000);
              assert.calledOnce(webex.internal.device.refresh);
            });
        });
      });

      it('does not get persisted to bounded storage', () => {
        assert.isTrue(webex.internal.device.config.ephemeral);

        webex.internal.device.url = 'http://example.com/device/id';

        // single tick accounts for debounce
        clock.tick(1);
        assert.notProperty(webex.boundedStorage.data.Device, '@');
      });
    });

    it('gets persisted to bounded storage', () => {
      webex.internal.device.url = 'http://example.com/device/id';

      // single tick accounts for debounce
      clock.tick(1);
      assert.equal(webex.boundedStorage.data.Device['@'].url, webex.internal.device.url);
    });
  });
});
