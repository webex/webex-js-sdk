/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';

import {assert} from '@webex/test-helper-chai';
import WebexCore from '@webex/webex-core';
import testUsers from '@webex/test-helper-test-users';

describe('plugin-wdm', function () {
  this.timeout(30000);
  describe('Device', () => {
    let webex;

    beforeEach('create users', () => testUsers.create({count: 1})
      .then((users) => {
        webex = new WebexCore({
          credentials: {
            supertoken: users[0].token
          }
        });
      }));

    describe('#register()', () => {
      it('registers a device', () => webex.internal.device.register()
        .then(() => {
          assert.property(webex.internal.device, 'customerCompanyName');
          assert.property(webex.internal.device, 'customerLogoUrl');
          assert.property(webex.internal.device, 'helpUrl');
          assert.property(webex.internal.device, 'partnerCompanyName');
          assert.property(webex.internal.device, 'partnerLogoUrl');
          assert.property(webex.internal.device, 'reportingSiteDesc');
          assert.property(webex.internal.device, 'reportingSiteUrl');
          assert.property(webex.internal.device, 'showSupportText');
          assert.property(webex.internal.device, 'supportProviderCompanyName');
          assert.property(webex.internal.device, 'supportProviderLogoUrl');

          assert.property(webex.internal.device, 'modificationTime');
          assert.property(webex.internal.device, 'services');
          assert.property(webex.internal.device, 'url');
          assert.property(webex.internal.device, 'userId');
          assert.property(webex.internal.device, 'webSocketUrl');
          assert.property(webex.internal.device, 'serviceHostMap');
          assert.property(webex.internal.device.serviceHostMap, 'serviceLinks');
          assert.property(webex.internal.device.serviceHostMap, 'hostCatalog');
        }));
    });

    describe('#refresh()', () => {
      let modificationTime;

      beforeEach(() => webex.internal.device.register()
        .then(() => {
          modificationTime = webex.internal.device.modificationTime;
        }));

      it('refreshes a device', () => {
        const {url} = webex.internal.device;

        return webex.internal.device.refresh()
          .then(() => {
            assert.property(webex.internal.device, 'modificationTime');
            assert.property(webex.internal.device, 'services');
            assert.property(webex.internal.device, 'url');
            assert.property(webex.internal.device, 'userId');
            assert.property(webex.internal.device, 'webSocketUrl');
            assert.property(webex.internal.device, 'serviceHostMap');
            assert.property(webex.internal.device.serviceHostMap, 'hostCatalog');
            assert.property(webex.internal.device.serviceHostMap, 'serviceLinks');
            assert.notEqual(webex.internal.device.modificationTime, modificationTime);
            assert.equal(webex.internal.device.url, url, 'Refreshing the device without sending the entire original payload must not give us a new registration');
          });
      });

      it('refreshes the device even if the device has expired', () => {
        const {url} = webex.internal.device;

        return webex.request({
          url,
          method: 'DELETE'
        })
          .then(() => webex.internal.device.refresh())
          .then(() => {
            assert.equal(webex.internal.device.url, url);
          });
      });
    });

    describe('#unregister()', () => {
      it('unregisters the device', () => webex.internal.device.register()
        .then(() => webex.internal.device.unregister())
        .then(() => assert.isUndefined(webex.internal.device.url)));
    });
  });
});
