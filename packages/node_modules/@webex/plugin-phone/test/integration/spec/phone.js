/*!
 * Copyright (c) 2015-2020 Cisco Systems, Inc. See LICENSE file.
 */
import '@webex/internal-plugin-user';
import '@webex/plugin-authorization';
import '@webex/plugin-people';
import '@webex/plugin-phone';

import {assert} from '@webex/test-helper-chai';
import sinon from 'sinon';
import WebexCore from '@webex/webex-core';
import testUsers from '@webex/test-helper-test-users';
import {createUser as createGuestUser} from '@webex/test-helper-appid';
import {browserOnly, handleErrorEvent} from '@webex/test-helper-mocha';

import {
  expectCallCreatedEvent,
  expectCallIncomingEvent,
  expectChangeLocusEvent,
  expectConnectedEvent,
  expectDisconnectedEvent,
  expectMembershipConnectedEvent,
  expectMembershipDisconnectedEvent
} from '../lib/event-expectations';


if (process.env.NODE_ENV !== 'test') {
  throw new Error('Cannot run the plugin-phone test suite without NODE_ENV === "test"');
}

browserOnly(describe)('plugin-phone', function () {
  this.timeout(60000);

  describe('Phone', () => {
    let mccoy, spock, quark;

    before('create users and register', () => testUsers.create({count: 2})
      .then((users) => {
        [mccoy, spock] = users;
        spock.webex = new WebexCore({
          credentials: {
            authorization: spock.token
          }
        });

        spock.webex2 = new WebexCore({
          credentials: {
            authorization: spock.token
          }
        });

        mccoy.webex = new WebexCore({
          credentials: {
            authorization: mccoy.token
          }
        });
        const displayName = 'JS SDK Guest';

        return createGuestUser({displayName});
      })
      .then(({jwt}) => {
        const guestWebex = new WebexCore();

        return guestWebex.authorization.requestAccessTokenFromJwt({jwt}).then(() =>
          // We don't have a user id for guest users until a record is looked up
          guestWebex.people.get('me').then((p) => {
            quark = Object.assign({}, p);
            quark.id = p.id;
            const email = p.emails[0];

            quark.email = email;
            quark.jwt = jwt;
            quark.webex = guestWebex;

            return quark;
          }));
      })
      .then(() => Promise.all([
        quark.webex.phone.register(),
        spock.webex.phone.register(),
        mccoy.webex.phone.register()
          .then(() => mccoy.webex.request({
            method: 'GET',
            service: 'hydra',
            resource: 'people/me'
          })
            .then((res) => {
              mccoy.hydraUserId = res.body.id;
            }))
      ])));

    let ringMccoy;

    beforeEach(() => {
      ringMccoy = sinon.spy();
      mccoy.webex.phone.on('call:incoming', ringMccoy);
    });

    beforeEach('end outstanding calls', () => spock.webex.internal.device.registered && spock.webex.internal.locus.list()
      .then((loci) => {
        if (loci.length) {
          return spock.webex.internal.locus.leave(loci[0]);
        }

        return Promise.resolve();
      }));

    after('unregister spock and mccoy', () => Promise.all([
      quark && quark.webex.phone.deregister()
        // eslint-disable-next-line no-console
        .catch((reason) => console.warn('could not disconnect quark from mercury', reason)),
      spock && spock.webex.phone.deregister()
        // eslint-disable-next-line no-console
        .catch((reason) => console.warn('could not disconnect spock from mercury', reason)),
      mccoy && mccoy.webex.phone.deregister()
        // eslint-disable-next-line no-console
        .catch((reason) => console.warn('could not disconnect mccoy from mercury', reason))
    ]));

    describe('#createLocalMediaStream()', () => {
      it('returns a MediaStreamObject', () => spock.webex.phone.createLocalMediaStream()
        .then((stream) => {
          assert.instanceOf(stream, MediaStream);
        }));
    });

    describe('#deregister()', () => {
      let mercuryDisconnectSpy;

      beforeEach(() => {
        mercuryDisconnectSpy = sinon.spy(spock.webex.internal.mercury, 'disconnect');
      });

      afterEach(() => mercuryDisconnectSpy.restore());

      it('disconnects from mercury', () => spock.webex.phone.deregister()
        .then(() => assert.calledOnce(mercuryDisconnectSpy))
        .then(() => assert.isFalse(spock.webex.internal.mercury.connected, 'Mercury is not connected'))
        .then(() => assert.isFalse(spock.webex.phone.connected, 'Mercury (proxied through webex.phone) is not connected'))
        .then(() => mercuryDisconnectSpy.restore()));

      it('unregisters from wdm', () => spock.webex.phone.deregister()
        .then(() => assert.isUndefined(spock.webex.internal.device.url))
        .then(() => spock.webex.phone.register()));

      it('is a noop when not registered', () => spock.webex.phone.deregister()
        .then(() => spock.webex.phone.deregister())
        .then(() => spock.webex.phone.register()));
    });

    describe('#dial()', () => {
      describe('by email address', () => {
        it('initiates an audio-only call', () => handleErrorEvent(spock.webex.phone.dial(mccoy.email, {
          constraints: {
            video: false,
            audio: true
          }
        }), (call) => expectCallIncomingEvent(mccoy.webex.phone)
          .then((mc) => Promise.all([
            expectConnectedEvent(call),
            mc.answer()
          ]))
          .then(() => {
            assert.isTrue(call.sendingAudio);
            assert.isFalse(call.sendingVideo);
            assert.isTrue(call.receivingAudio);
            assert.isFalse(call.receivingVideo);
          })));

        it('initiates a video-only call', () => handleErrorEvent(spock.webex.phone.dial(mccoy.email, {
          constraints: {
            video: true,
            audio: false
          }
        }), (call) => expectCallIncomingEvent(mccoy.webex.phone)
          .then((mc) => Promise.all([
            expectConnectedEvent(call),
            mc.answer()
          ]))
          .then(() => {
            assert.isFalse(call.sendingAudio);
            assert.isTrue(call.sendingVideo);
            assert.isFalse(call.receivingAudio);
            assert.isTrue(call.receivingVideo);
          })));

        it('initiates a receive-only call', () => handleErrorEvent(spock.webex.phone.dial(mccoy.email, {
          constraints: {
            video: false,
            audio: false
          },
          offerOptions: {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          }
        }), (call) => expectCallIncomingEvent(mccoy.webex.phone)
          .then((mc) => Promise.all([
            expectConnectedEvent(call),
            mc.answer()
          ]))
          .then(() => {
            assert.isFalse(call.sendingAudio);
            assert.isFalse(call.sendingVideo);
            assert.isTrue(call.receivingAudio);
            assert.isTrue(call.receivingVideo);
          })));

        it('places a call with an existing MediaStreamObject', () => spock.webex.phone.createLocalMediaStream()
          .then((localMediaStream) => handleErrorEvent(
            spock.webex.phone.dial(mccoy.email, {localMediaStream}),
            (call) => Promise.all([
              expectCallIncomingEvent(mccoy.webex.phone)
                .then((c) => {
                  assert.isDefined(call.media.localMediaStream, 'call.media.localMediaStream is defined');
                  assert.isDefined(call.localMediaStream, 'call.localMediaStream is defined');

                  return c.answer();
                }),
              expectConnectedEvent(call)
                .then(() => {
                  assert.equal(call.status, 'connected');
                  assert.isDefined(call.media.localMediaStream, 'call.media.localMediaStream is defined');
                  assert.isDefined(call.localMediaStream, 'call.localMediaStream is defined');
                })
            ])
          )));
      });

      it('calls a user by hydra user id', () => handleErrorEvent(spock.webex.phone.dial(mccoy.hydraUserId), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(mccoy.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      it('calls a user by uuid', () => handleErrorEvent(spock.webex.phone.dial(mccoy.id), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(mccoy.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      // Note: This does not actually use sip to make the connection, but
      // determines who the user is from their sip address and then places a 1:1
      // space call
      it('calls a user by sip uri', () => mccoy.webex.internal.user.get()
        .then((mu) => {
          assert.property(mu, 'sipAddresses', 'McCoy\'s user object contains a sip address array');
          assert.isAbove(mu.sipAddresses.length, 0, 'McCoy\'s user object contains one or more sip addresses');

          return handleErrorEvent(spock.webex.phone.dial(mu.sipAddresses[0].value), (call) => Promise.all([
            // Spock's view of the call
            expectMembershipConnectedEvent(call)
              .then(() => Promise.all([
                expectMembershipDisconnectedEvent(call),
                expectDisconnectedEvent(call)
              ])),

            // McCoy's view of the call
            expectCallIncomingEvent(mccoy.webex.phone)
              .then((mc) => Promise.all([
                expectMembershipConnectedEvent(mc),
                mc.answer()
              ])
                .then(() => mc.hangup()))
          ]));
        }));
    });

    describe('#listActiveCalls()', () => {
      beforeEach('empty emittedCalls collection', () => {
        spock.webex.phone.emittedCalls.reset();
      });

      describe('when no ongoing calls exist', () => {
        it('returns an empty array', () =>
          spock.webex.phone.listActiveCalls()
            .then((callList) => {
              assert.isTrue(Array.isArray(callList));
              assert.equal(callList.length, 0);
            }));
      });

      describe('when an incoming call is ringing', () => {
        let incomingCall;

        beforeEach('create an incoming call', () => handleErrorEvent(mccoy.webex.phone.dial(spock.email), () =>
          expectCallIncomingEvent(spock.webex.phone, 'spock should receive an incoming call from mccoy')));

        afterEach('hangup incoming call', () => incomingCall.hangup());

        it('emits a call incoming event for an unanswered call', () => {
          // Manually reset the emittedCalls collection
          spock.webex.phone.emittedCalls.reset();

          return Promise.all([
            spock.webex.phone.listActiveCalls(),
            expectCallIncomingEvent(spock.webex.phone, 'spock should emit an incoming call event')
              .then((call) => {
                incomingCall = call;
              })
          ])
            .then(() => Promise.all([
              // Answer the call so it can cleanup properly
              incomingCall.answer(),
              expectConnectedEvent(incomingCall)
            ]));
        });
      });

      describe('when a ongoing call exists', () => {
        let connectedCall;

        beforeEach('create an existing call', () => handleErrorEvent(spock.webex.phone.dial(mccoy.email), (call) =>
          Promise.all([
            expectCallIncomingEvent(mccoy.webex.phone).then((mc) => mc.answer()),
            expectConnectedEvent(call)
          ])
            .then(() => {
              connectedCall = call;
            })));

        afterEach(() => connectedCall.hangup());

        it('lists the existing call', () => {
          assert.isDefined(connectedCall);

          return spock.webex.phone.listActiveCalls()
            .then((result) => {
              assert.isTrue(Array.isArray(result));
              assert.equal(result.length, 1);
              const activeCall = result[0];

              assert.equal(activeCall.id, connectedCall.id);
              assert.equal(activeCall.id, connectedCall.id);
            });
        });

        it.skip('adds the existing call to the emittedCalls collection', () => {
          // Remove our connected call from the collection
          spock.webex.phone.emittedCalls.reset();
          assert.equal(spock.webex.phone.emittedCalls.length, 0, 'emitted calls collection should have no calls');

          return spock.webex.phone.listActiveCalls()
            .then((result) => {
              const activeCall = result[0];

              assert.isAtLeast(spock.webex.phone.emittedCalls.length, 1, 'emitted calls collection should have at least one call');
              assert.isDefined(spock.webex.phone.emittedCalls.get(activeCall.internalCallId));
            });
        });

        it.skip('does not add the existing call to the emittedCalls collection if it exists', () => {
          assert.equal(spock.webex.phone.emittedCalls.length, 1, 'emitted calls collection should have one calls');

          return spock.webex.phone.listActiveCalls()
            .then((result) => {
              const activeCall = result[0];

              assert.equal(spock.webex.phone.emittedCalls.length, 1, 'emitted calls collection should have one call');
              assert.isDefined(spock.webex.phone.emittedCalls.get(activeCall.internalCallId));
            });
        });

        it('emits a call created event for the existing call', () => {
          spock.webex.phone.emittedCalls.reset();

          return Promise.all([
            spock.webex.phone.listActiveCalls(),
            expectCallCreatedEvent(spock.webex.phone)
          ]);
        });
      });
    });

    describe('#register()', () => {
      let kirk;

      beforeEach(() => testUsers.create({count: 1})
        .then(([user]) => {
          kirk = user;
          kirk.webex = new WebexCore({
            credentials: {
              authorization: kirk.token
            }
          });
        }));

      afterEach('unregister kirk', () => kirk && kirk.webex.phone.deregister());

      it('registers with wdm', () => {
        const spy = sinon.spy();

        kirk.webex.phone.on('change:registered', spy);

        return kirk.webex.phone.register()
          .then(() => {
            assert.isDefined(kirk.webex.internal.device.url);
            assert.called(spy);
          });
      });

      it('connects to mercury', () => {
        assert.isFalse(kirk.webex.internal.mercury.connected, 'Mercury is not connected');
        assert.isFalse(kirk.webex.phone.connected, 'Mercury (proxied through webex.phone) is not conneted');
        const spy = sinon.spy();

        kirk.webex.phone.on('change:connected', spy);

        return kirk.webex.phone.register()
          .then(() => {
            assert.isTrue(kirk.webex.internal.mercury.connected, 'Mercury is connected after calling register');
            assert.isTrue(kirk.webex.phone.connected, 'webex.phone.connected proxies to webex.internal.mercury.connected');
            assert.called(spy);
          });
      });

      it('fetches active calls', () =>
        // use change:locus as the trigger for determining when the post to
        // /call completes.
        handleErrorEvent(spock.webex.phone.dial(kirk.email), (call) => expectChangeLocusEvent(call)
          .then(() => {
            assert.isFalse(kirk.webex.phone.registered);
            kirk.webex.phone.register();

            return expectCallIncomingEvent(kirk.webex.phone)
              .then(() => assert.isTrue(kirk.webex.phone.registered, 'By the time webex.phone can emit call:incoming, webex.phone.registered must be true'));
          })));

      it('is a noop when already registered', () => spock.webex.phone.register());
    });

    describe('when a call is received', () => {
      it('emits a call:incoming event', () => {
        spock.webex.phone.dial(mccoy.email);

        return expectCallIncomingEvent(mccoy.webex.phone)
          .then(() => assert.calledOnce(ringMccoy));
      });
    });

    describe('when a call is created elsewhere', () => {
      it('emits a call:created event', () => {
        const emittedCallsLength = spock.webex.phone.emittedCalls.length;

        spock.webex2.phone.dial(mccoy.email);

        return expectCallCreatedEvent(spock.webex.phone)
          .then((createdCall) => {
            assert.equal(spock.webex.phone.emittedCalls.length, emittedCallsLength + 1, 'emitted calls collection should have one additional call');
            assert.isDefined(spock.webex.phone.emittedCalls.get(createdCall.internalCallId));
          });
      });
    });

    describe('guest user calling', () => {
      it('can call a guest user by hydra user id', () => handleErrorEvent(spock.webex.phone.dial(quark.id), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(quark.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      it('can call a guest user by guest email', () => handleErrorEvent(spock.webex.phone.dial(quark.email), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(quark.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      it('can place a call to a regular user', () => handleErrorEvent(quark.webex.phone.dial(spock.email), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(spock.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      it('calls a regular user by hydra user id', () => handleErrorEvent(quark.webex.phone.dial(mccoy.hydraUserId), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(mccoy.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));

      it('calls a regular user by uuid', () => handleErrorEvent(quark.webex.phone.dial(mccoy.id), (call) => Promise.all([
        expectConnectedEvent(call)
          .then(() => {
            assert.isDefined(call.correlationId);
            assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
          }),
        expectCallIncomingEvent(mccoy.webex.phone)
          .then((c) => c.answer()
            .then(() => {
              assert.equal(c.locus.self.devices[0].correlationId, c.correlationId);
              assert.isDefined(c.correlationId);
            }))
      ])));
    });
  });
});
