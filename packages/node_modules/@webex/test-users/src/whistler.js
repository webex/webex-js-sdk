import assert from 'assert';

import btoa from 'btoa';
import _ from 'lodash';
import {request} from '@webex/http-core';

const BASE_PATH = '/users/test_users';

/**
 * Computes `expires` and `refresh_token_expires` from `expires_in` and
 * `refresh_token_expires_in` and creates an `authorization` string.
 * @param {Object} token
 * @private
 * @returns {Object}
 */
function fixToken(token) {
  const now = Date.now();

  if (token.expires_in && !token.expires) {
    token.expires = now + token.expires_in * 1000;
  }

  if (token.refresh_token_expires_in && !token.refresh_token_expires) {
  /* eslint camelcase: [0] */
    token.refresh_token_expires = now + token.refresh_token_expires_in * 1000;
  }

  if (token.token_type && token.access_token) {
    token.authorization = `${token.token_type} ${token.access_token}`;
  }

  return token;
}

let clientToken;

/**
 * Fetches credentials to talk to the test_users_s endpoint
 *
 * Caches result in `clientToken` variable for multiple runs
 * @param {Object} options
 * @param {string} options.clientId
 * @param {string} options.clientSecret
 * @param {string} options.idbrokerUrl
 * @param {string} options.orgId
 * @param {string} options.machineAccount
 * @param {string} options.machinePassword
 * @private
 * @returns {Promise<string>}
 */
function getClientCredentials({
  clientId, clientSecret, orgId, idbrokerUrl, machineAccount, machinePassword
}) {
  if (clientToken) {
    return Promise.resolve(clientToken);
  }

  return request({
    method: 'POST',
    uri: `${idbrokerUrl}/idb/token/${orgId}/v2/actions/GetBearerToken/invoke`,
    json: true,
    body: {
      uid: machineAccount,
      password: machinePassword
    }
  })
    .then((res) => request({
      method: 'POST',
      uri: `${idbrokerUrl}/idb/oauth2/v1/access_token`,
      json: true,
      form: {
        assertion: res.body.BearerToken,
        grant_type: 'urn:ietf:params:oauth:grant-type:saml2-bearer',
        scope: 'webexsquare:get_conversation webexsquare:admin',
        self_contained_token: true,
        client_id: clientId,
        client_secret: clientSecret
      },
      headers: {
        // Note: we can't request's auth hash here because this endpoint expects
        // us to send the auth header *without including "Basic "* before the
        // token string
        // authorization: `Basic + ${btoa(`${clientId}:${clientSecret}`)}`
        authorization: btoa(`${clientId}:${clientSecret}`)
      }
    }))
    .then((res) => {
      const token = fixToken(res.body);

      return `${token.token_type} ${token.access_token}`;
    })
    .then((token) => {
      clientToken = token;

      return clientToken;
    });
}

/**
 * @typedef {Object} AccessTokenObject
 * @property {string} token.access_token
 * @property {Number} token.expires_in
 * @property {string} token.token_type
 * @property {string} token.refresh_token
 * @property {Number} token.refresh_token_expires_in
 * @property {string} token.expires
 * @property {string} token.refresh_token_expires
 */

/**
 * @typedef {Object} CreateUserOptions
 * @param {Object} [options]
 * @param {string} [options.clientId] defaults to WEBEX_CLIENT_ID
 * @param {string} [options.clientSecret] defaults to WEBEX_CLIENT_SECRET
 * @param {string} [options.conversationServiceUrl] defaults to WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL
 * @param {string} [options.idbrokerUrl] defaults to IDBROKER_BASE_URL
 * @param {string} [options.orgId] organization ID to create the user under
 * @param {string} [options.machineAccount] defaults to WHISTLER_MACHINE_ACCOUNT
 * @param {string} [options.machinePassword] defaults to WHISTLER_MACHINE_PASSWORD
 */

/**
 * Creates a test user
 * @param {CreateUserOptions} options
 * @returns {Promise.<TestUserObject>}
 */
export function createTestUser(options = {}) {
  const clientId = options.clientId || process.env.WEBEX_CLIENT_ID;
  const clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET;
  const idbrokerUrl = options.idbrokerUrl || process.env.IDBROKER_BASE_URL;
  const orgId = options.orgId || process.env.WHISTLER_TEST_ORG_ID;
  const machineAccount = options.machineAccount || process.env.WHISTLER_MACHINE_ACCOUNT;
  const machinePassword = options.idbrokerUrl || process.env.WHISTLER_MACHINE_PASSWORD;

  if (!clientId) {
    throw new Error('options.clientId or process.env.WEBEX_CLIENT_ID must be defined');
  }

  if (!clientSecret) {
    throw new Error('options.clientSecret or process.env.WEBEX_CLIENT_SECRET must be defined');
  }

  return getClientCredentials({
    clientId,
    clientSecret,
    machineAccount,
    machinePassword,
    idbrokerUrl,
    orgId
  })
    .then((authorization) => request({
      method: 'GET',
      uri: `${process.env.WHISTLER_API_SERVICE_URL}/reservations/testUser`,
      headers: {
        authorization
      }
    }))
    .then((res) => Object.assign({
      password: res.body.responseMetaData.webexPassword,
      emailAddress: res.body.responseMetaData.name,
      displayName: res.body.responseMetaData.webExUserName
    }, res.body.responseMetaData, {token: fixToken(res.body.token)}));
}

/**
 * Exchanges a user name/password for an access token
 * @param {Object} options
 * @param {string} options.id
 * @param {string} options.email
 * @param {string} options.password
 * @param {string} options.clientId
 * @param {string} options.clientSecret
 * @param {string} options.conversationServiceUrl
 * @returns {Promise.<AccessTokenObject>}
 */
export function loginTestUser(options) {
  const clientId = options.clientId || process.env.WEBEX_CLIENT_ID;
  const clientSecret = options.clientSecret || process.env.WEBEX_CLIENT_SECRET;
  const conversationServiceUrl = options.conversationServiceUrl || process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL;

  if (!clientId) {
    throw new Error('options.clientId or process.env.WEBEX_CLIENT_ID must be defined');
  }

  if (!clientSecret) {
    throw new Error('options.clientSecret or process.env.WEBEX_CLIENT_SECRET must be defined');
  }

  if (!conversationServiceUrl) {
    throw new Error('options.conversationServiceUrl or process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL must be defined');
  }

  return request({
    method: 'POST',
    uri: `${conversationServiceUrl}${BASE_PATH}/login`,
    json: true,
    body: _.defaultsDeep(options, {
      clientId,
      clientSecret
    })
  })
    .then((res) => fixToken(res.body));
}

/**
 * Removes a test user
 * @param {Object} options
 * @param {string} options.id user id to remove
 * @param {string} options.conversationServiceUrl
 * @param {Object} options.token
 * @param {string} options.token.authorization
 * @param {string} [options.token.refresh_token]
 * @returns {Promise}
 */
export function removeTestUser(options = {}) {
  const conversationServiceUrl = options.conversationServiceUrl || process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL;

  if (!conversationServiceUrl) {
    throw new Error('options.conversationServiceUrl or process.env.WEBEX_TEST_USERS_CONVERSATION_SERVICE_URL must be defined');
  }

  if (!options.id) {
    return Promise.reject(new Error('options.id is required'));
  }

  if (!options.token) {
    return loginTestUser(options)
      .then((token) => {
        options.token = token;

        return removeTestUser(options);
      });
  }

  assert(options.token.authorization, 'options.token.authorization must be defined');

  return request({
    method: 'POST',
    json: true,
    headers: {
      authorization: options.token.authorization
    },
    body: {
      /* eslint-disable camelcase */
      user_id: options.id,
      refresh_token: options.token.refresh_token,
      user_type: options.userType || 'PERSON'
      /* eslint-enable camelcase */
    },
    uri: `${conversationServiceUrl}${BASE_PATH}/delete`
  });
}
