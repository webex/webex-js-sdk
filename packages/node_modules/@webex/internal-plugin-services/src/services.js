import Url from 'url';

import {base64} from '@webex/common';
import {WebexPlugin} from '@webex/webex-core';

import ServiceUrl from './service-url';

/* eslint-disable no-underscore-dangle */
/**
 * @class
 */
const Services = WebexPlugin.extend({
  namespace: 'Services',

  status: {
    ready: false
  },

  _serviceUrls: [],
  _serviceUrlsLimited: [],
  _serviceUrlsDiscovery: [
    new ServiceUrl({
      name: 'u2c',
      defaultUrl: process.env.U2C_SERVICE_URL ||
        'https://u2c.wbx2.com/u2c/api/v1',
      hosts: []
    })
  ],

  /**
   * **Internal**
   * Creates an object where the keys are the service
   * names and the values are the service urls.
   * @param {boolean} [priorityHost] - use highest priority host if set to `true`
   * @param {string} [serviceGroup]
   * @returns {object}
   */
  _generateServicesList(priorityHost, serviceGroup = '') {
    const output = {};

    this[`_serviceUrls${serviceGroup}`].forEach((serviceUrl) => {
      output[serviceUrl.name] = serviceUrl.get(priorityHost);
    });

    return output;
  },

  /**
   * Generate a service catalog as an object.
   * @param {boolean} [priorityHost] - use highest priority host if set to `true`
   * @param {string} [serviceGroup]
   * @returns {Record<string, string>}
   */
  services(priorityHost, serviceGroup) {
    if (serviceGroup) {
      return this._generateServicesList(priorityHost, serviceGroup);
    }

    return {
      ...this._generateServicesList(priorityHost, 'Discovery'),
      ...this._generateServicesList(priorityHost, 'Limited'),
      ...this._generateServicesList(priorityHost)
    };
  },

  /**
   * **Internal**
   * Search the service url array to locate a `ServiceUrl`
   * class object based on its name.
   * @param {string} name
   * @param {string} [serviceGroup]
   * @returns {ServiceUrl}
   */
  _getUrl(name, serviceGroup) {
    if (serviceGroup) {
      return this[`_serviceUrls${serviceGroup}`].find(
        (serviceUrl) => serviceUrl.name === name
      );
    }

    return this._serviceUrls.find((servUrl) => servUrl.name === name) ||
      this._serviceUrlsLimited.find((servUrl) => servUrl.name === name) ||
      this._serviceUrlsDiscovery.find((servUrl) => servUrl.name === name);
  },

  /**
   * Get a service url from the current services list by name.
   * @param {string} name
   * @param {boolean} [priorityHost]
   * @param {string} [serviceGroup]
   * @returns {string|undefined}
   */
  get(name, priorityHost, serviceGroup) {
    const serviceUrl = this._getUrl(name, serviceGroup);

    return (serviceUrl) ? serviceUrl.get(priorityHost) : undefined;
  },

  /**
   * Mark a priority host service url as failed.
   * This will mark the host associated with the
   * `ServiceUrl` to be removed from the its
   * respective host array, and then return the next
   * viable host from the `ServiceUrls` host array,
   * or the `ServiceUrls` default url if no other priority
   * hosts are available, or if `noPriorityHosts` is set to
   * `true`.
   * @param {string} url
   * @param {boolean} noPriorityHosts
   * @returns {string}
   */
  markFailedUrl(url, noPriorityHosts) {
    const serviceUrl = this._getUrl(Object.keys(this.services()).find(
      (key) => this._getUrl(key).removeHost(url)
    ));

    if (!serviceUrl) {
      return undefined;
    }

    return (noPriorityHosts) ? serviceUrl.get(false) : serviceUrl.get(true);
  },

  /**
   * Update a list of `serviceUrls` to the most current
   * catalog via the defined `discoveryUrl` then returns the current
   * list of services.
   * @param {string} by This accepts `email`, `orgId` or `userId`
   * @param {string} value This accepts an email, orgId, or userId
   * @returns {Promise<Array<string>>}
   */
  updateServices(by, value) {
    const params = [];

    if (by && value) {
      params.push(
        true,
        by,
        (by === 'email') ? base64.encode(value) : value
      );
    }

    const limited = params.length > 0;

    return this._fetchNewServiceHostmap(...params)
      .then((serviceHostMap) => {
        this._updateServiceUrls(
          serviceHostMap,
          limited ? 'Limited' : undefined
        );

        this.trigger('servicesUpdated');

        return Promise.resolve({
          ...this.services(false, (limited) ? 'Limited' : undefined)
        });
      });
  },

  /**
   * Wait until this plugin is ready
   * @returns {Promise<void>}
   */
  waitUntilReady() {
    return new Promise((resolve) => {
      if (this.status.ready) {
        resolve();
      }

      this.once('ready', () => resolve());
    });
  },

  /**
   * **Internal**
   * Safely load one or more `ServiceUrl`s into this `Services` instance.
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _loadServiceUrls(serviceGroup, services) {
    services.forEach((service) => {
      // Validate a service was found in the service catalog.
      // and that service is an instance of `ServiceUrl`
      if (!this[`_serviceUrls${serviceGroup}`].includes(service)) {
        this[`_serviceUrls${serviceGroup}`].push(service);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Safely unload one or more `ServiceUrl`s into this `Services` instance
   * @param {string} serviceGroup
   * @param  {Array<ServiceUrl>} services
   * @returns {Services}
   */
  _unloadServiceUrls(serviceGroup, services) {
    let s;

    services.forEach((service) => {
      s = service;

      // Confirm that the service param is a string or object.
      if (typeof service === 'string') {
        s = this._getUrl(s, serviceGroup);
      }

      // Validate a service was found in the service catalog.
      if (s && this[`_serviceUrls${serviceGroup}`].includes(service)) {
        this[`_serviceUrls${serviceGroup}`]
          .splice(this[`_serviceUrls${serviceGroup}`].indexOf(s), 1);
      }
    });

    return this;
  },

  /**
   * **Internal**
   * Update the current list of `ServiceUrl`s against a provided
   * service hostmap.
   * @param {object} serviceHostmap
   * @param {string} [catalog]
   * @returns {Services}
   */
  _updateServiceUrls(serviceHostmap, catalog = '') {
    const targetUrls = this[`_serviceUrls${catalog}`];

    // Clean up current service urls.
    const unusedUrls = targetUrls.filter(
      (serviceUrl) => serviceHostmap.every(
        (item) => item.name !== serviceUrl.name
      )
    );

    this._unloadServiceUrls(catalog, unusedUrls);

    serviceHostmap.forEach((serviceObj) => {
      const service = this._getUrl(serviceObj.name, catalog);

      if (service) {
        service.defaultUrl = serviceObj.defaultUrl;
        service.hosts = serviceObj.hosts;
      }
      else {
        this._loadServiceUrls(catalog, [new ServiceUrl({
          ...serviceObj
        })]);
      }
    });

    return this;
  },

  /**
   *  **Internal**
   * Organize a received hostmap from a service
   * catalog endpoint.
   * @param {object} serviceHostmap
   * @returns {object}
   */
  _formatReceivedHostmap(serviceHostmap) {
    const output = [];
    let item = {};

    Object.keys(serviceHostmap.serviceLinks).forEach((key) => {
      item = {};

      item.name = key;
      item.defaultUrl = serviceHostmap.serviceLinks[key];
      item.hosts = serviceHostmap.hostCatalog[Url.parse(item.defaultUrl).host];

      output.push(item);
    });

    return output;
  },

  /**
   * **Internal**
   * Simplified method wrapper for sending a request to get
   * an updated service hostmap.
   * @param {boolean} [limited]
   * @param {string} [by]
   * @param {string} [value]
   * @returns {Promise<object>}
   */
  _fetchNewServiceHostmap(limited, by, value) {
    const service = 'u2c';
    const limStr = (limited) ? '/limited' : '';
    const qs = {
      format: 'hostmap'
    };

    if (limited) {
      qs[by] = value;
    }

    return this.request({
      method: 'GET',
      service,
      resource: `${limStr}/catalog`,
      qs
    })
      .then(({body}) => Promise.resolve(this._formatReceivedHostmap(body)))
      .catch((e) => Promise.reject(e));
  },

  /**
   * Initializer
   *
   * @emits Services#ready
   * @emits Services#servicesUpdated
   * @emits Services#pulse
   * @instance
   * @memberof Services
   * @returns {Services}
   */
  initialize() {
    this.listenToOnce(this.webex, 'ready', () => {
      this.updateServices();
    });

    this.once('servicesUpdated', () => {
      this.status.ready = true;
      this.trigger('ready');
    });
  }
});
/* eslint-enable no-underscore-dangle */

export default Services;
