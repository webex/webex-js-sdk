/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';
import '@webex/internal-plugin-mercury';
import '@webex/plugin-logger';
import '@webex/plugin-people';
import '@webex/plugin-rooms';
import '@webex/plugin-messages';
import WebexCore, {WebexHttpError} from '@webex/webex-core';
import {
  SDK_EVENT,
  hydraTypes,
  constructHydraId
} from '@webex/common';
import {assert} from '@webex/test-helper-chai';
import sinon from '@webex/test-helper-sinon';
import testUsers from '@webex/test-helper-test-users';

const debug = require('debug')('rooms');

describe('plugin-rooms', function () {
  this.timeout(60000);

  let webex, actor;

  before(() => testUsers.create({count: 1})
    .then(([user]) => {
      webex = new WebexCore({credentials: user.token});
      webex.people.get('me')
        .then((person) => {
          actor = person;
          debug('SDK User (Actor) for tests:');
          debug(`- name: ${actor.displayName}`);
          debug(`-   id: ${actor.id}`);
        });
    }));

  describe('#rooms', () => {
    const rooms = [];

    afterEach(() => {
      webex.rooms.stopListening();

      return Promise.all(rooms.map((room) => webex.rooms.remove(room)
        .catch((reason) => {
          console.error('Failed to delete room', reason);
        })))
        .then(() => {
          while (rooms.length) {
            rooms.pop();
          }
        });
    });

    describe('#create()', () => {
      it('creates a room and validates the room:created event', () => {
        const createdEventPromise = new Promise((resolve) => {
          webex.rooms.on('created', (event) => {
            debug('room:created event handler called');
            resolve(event);
          });
        });

        return webex.rooms.listen()
          .then(() => webex.rooms.create({title: 'Cisco Spark Test Room'})
            .then(async (room) => {
              assert.isRoom(room);
              rooms.push(room); // for future cleanup
              const event = await createdEventPromise;

              validateRoomEvent(event, room, actor);
            }));
      });
    });

    describe('#one-on-one()', () => {
      let user1, room;

      before(() => testUsers.create({count: 1})
        .then((users) => {
          user1 = users[0];
          debug('Test User for One-on-One room:');
          debug(`- name: ${user1.displayName}`);
          debug(`-   id: ${constructHydraId(hydraTypes.PEOPLE, user1.id)}`);
        }));

      // We need a one-on-on space for this test
      // We create it by sending a message to the test user
      it('creates a 1-1 space and validates the room type', () => {
        const createdEventPromise = new Promise((resolve) => {
          webex.rooms.on('created', (event) => {
            debug('room:created event handler called');
            debug(event);
            resolve(event);
          });
        });

        return webex.rooms.listen()
          .then(() => webex.messages.create({
            toPersonId: user1.id,
            text: 'Message to start a one-on-on space'
          })
            .then((message) => {
              assert.exists(message.roomId);

              return webex.rooms.get({id: message.roomId});
            })
            .then(async (r) => {
              room = r;
              assert.isRoom(room);
              const event = await createdEventPromise;

              validateRoomEvent(event, room, actor);
            }));
      });
    });

    describe('#get()', () => {
      let room0;

      beforeEach(() => Promise.all([
        webex.rooms.create({title: 'Cisco Spark Test Room 1'})
          .then((room) => {
            rooms.push(room);
          }),
        webex.rooms.create({title: 'Cisco Spark Test Room 0'})
          .then((room) => {
            rooms.push(room);
            room0 = room;
          })
      ]));

      it('retrieves a specific room', () => webex.rooms.get(room0)
        .then((room) => {
          assert.isRoom(room);

          assert.equal(room.id, room0.id);
          assert.equal(room.title, room0.title);
        }));
    });

    describe('#list()', () => {
      // Reminder: we can't run the next two creates in parallel because some of
      // the tests rely on ordering.
      let room0, room1;

      beforeEach(() => webex.rooms.create({title: 'Cisco Spark Test Room 1'})
        .then((room) => {
          rooms.push(room);
          room1 = room;
        }));

      beforeEach(() => webex.rooms.create({title: 'Cisco Spark Test Room 0'})
        .then((room) => {
          rooms.push(room);
          room0 = room;
        }));

      it('retrieves all the rooms to which I have access', () => webex.rooms.list()
        .then((rooms) => {
          for (const room of rooms) {
            assert.isRoom(room);
          }
          assert.equal(rooms.items[0].id, room0.id, 'Room 0\'s id matches');
          assert.equal(rooms.items[0].title, room0.title, 'Room 0\'s title matches');
          assert.equal(rooms.items[1].id, room1.id, 'Room 1\'s id matches');
          assert.equal(rooms.items[1].title, room1.title, 'Room 1\'s title matches');
        }));

      it('retrieves a bounded, pageable set of rooms to which I have access', () => {
        const spy = sinon.spy();

        return webex.rooms.list({max: 1})
          .then((rooms) => {
            assert.lengthOf(rooms, 1);

            return (function f(page) {
              for (const room of page) {
                spy(room.id);
              }

              if (page.hasNext()) {
                return page.next().then(f);
              }

              return Promise.resolve();
            }(rooms));
          })
          .then(() => {
            assert.isAbove(spy.callCount, 1);
            assert.calledWith(spy, room0.id);
            assert.calledWith(spy, room1.id);
          });
      });
    });

    describe('#update()', () => {
      let room;

      beforeEach(() => webex.rooms.create({title: 'Cisco Spark Test Room'})
        .then((r) => {
          room = r;
          rooms.push(room);
          assert.property(room, 'id');
        }));

      it('updates a single room\'s title and validates a room:updated event', () => {
        const r = Object.assign({}, room, {title: 'Cisco Spark Test Room with New Title'});
        const updatedEventPromise = new Promise((resolve) => {
          webex.rooms.on('updated', (event) => {
            debug('room:updated event handler called');
            resolve(event);
          });
        });

        return webex.rooms.listen()
          .then(() => webex.rooms.update(r)
            .then(async (room) => {
              assert.isRoom(room);
              assert.deepEqual(room, r);
              const event = await updatedEventPromise;

              validateRoomEvent(event, room, actor);
            }));
      });
    });

    describe('#remove()', () => {
      let room;

      beforeEach(() => webex.rooms.create({title: 'Cisco Spark Test Room'})
        .then((r) => {
          room = r;
          assert.property(room, 'id');
        }));

      it('deletes a single room', () => webex.rooms.remove(room)
        .then((body) => {
          assert.notOk(body);

          return assert.isRejected(webex.rooms.get(room));
        })
        .then((reason) => {
          assert.instanceOf(reason, WebexHttpError.NotFound);
        }));
    });
  });
});

/**
 * Validate a rooms event.
 * @param {Object} event - rooms event
 * @param {Object} room -- return from the API that generated this event
 * @param {Object} actor - person object for user who performed action
 * @returns {void}
 */
function validateRoomEvent(event, room, actor) {
  assert.isTrue(event.resource === SDK_EVENT.EXTERNAL.RESOURCE.ROOMS,
    'not a room event');
  assert.isDefined(event.event, 'room event type not set');
  assert.isDefined(event.created, 'event listener created date not set');
  assert.equal(event.createdBy, actor.id,
    'event listener createdBy not set to our actor');
  assert.equal(event.orgId, actor.orgId,
    'event listener orgId not === to our actor\'s');
  assert.equal(event.ownedBy, 'creator', 'event listener not owned by creator');
  assert.equal(event.status, 'active', 'event listener status not active');
  assert.equal(event.actorId, actor.id,
    'event actorId not equal to our actor\'s id');

  // Ensure event data matches data returned from function call
  // Skip this until we figure out how conversations converts the internal test user UUID
  assert.equal(event.data.id, room.id,
    'event/room.id not equal');
  assert.equal(event.data.isLocked, room.isLocked,
    'event/room.isLocked not equal');
  assert.equal(event.data.type, room.type,
    'event/room.type not equal');
}
