/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {WebexPlugin, Page} from '@webex/webex-core';
import {cloneDeep} from 'lodash';
import {
  SDK_EVENT,
  createEventEnvelope,
  hydraTypes,
  constructHydraId
} from '@webex/common';

const debug = require('debug')('memberships');

/**
 * @typedef {Object} RoomObject
 * @property {string} id - (server generated) Unique identifier for the room
 * @property {string} title - The display name for the room. All room members
 * will see the title so make it something good
 * @property {string} teamId - (optional) The ID of the team to which the room
 * belongs
 * @property {isoDate} created - (server generated) The date and time that the
 * room was created
 */

/**
 * Rooms are virtual meeting places for getting stuff done. This resource
 * represents the room itself. Check out the {@link Memberships} API to learn
 * how to add and remove people from rooms and the {@link Messages} API for
 * posting and managing content.
 * @class
 * @name Rooms
 */
const Rooms = WebexPlugin.extend({
  /**
   * Connect to the web socket to listen to incoming messages.
   * @returns {Promise}
   */
  listen() {
    return createEventEnvelope(this.spark, SDK_EVENT.EXTERNAL.RESOURCE.ROOMS)
      .then((envelope) => {
        this.eventEnvelope = envelope;

        return this.spark.internal.mercury.connect().then(() => {
          this.listenTo(this.spark.internal.mercury,
            SDK_EVENT.INTERNAL.TEAMS_ACTIVITY,
            (event) => this.onWebexApiEvent(event));
        });
      });
  },

  /**
   * Trigger a membership related events.
   * @param {Object} event
   * @returns {undefined} -- nothing //linter requires return in JSDoc
   */
  onWebexApiEvent(event) {
    const {activity} = event.data;

    /* eslint-disable no-case-declarations */
    switch (activity.verb) {
      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:
        const roomCreatedEvent =
          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);

        if (roomCreatedEvent) {
          debug(`room "created" payload: \
            ${JSON.stringify(roomCreatedEvent)}`);
          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);
        }
        break;

      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:
        const roomUpdatedEvent =
          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);

        if (roomUpdatedEvent) {
          debug(`room "updated" payload: \
            ${JSON.stringify(roomUpdatedEvent)}`);
          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);
        }
        break;

      default:
        break;
    }
  },

  /**
   * Constructs the data object for an event on the rooms resource,
   * adhering to Hydra's Webehook data structure.
   * @param {Object} activity from mercury
   * @param {Object} event type of "webhook" event
   * @returns {Object} constructed event
   */
  getRoomEvent(activity, event) {
    try {
      const sdkEvent = cloneDeep(this.eventEnvelope);
      let room;

      sdkEvent.event = event;
      sdkEvent.data.created = activity.published;
      sdkEvent.actorId = constructHydraId(hydraTypes.PEOPLE, activity.actor.entryUUID);
      if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {
        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;
        sdkEvent.data.creatorId =
          constructHydraId(hydraTypes.PEOPLE, activity.actor.entryUUID);
        sdkEvent.data.lastActivity = activity.published;
      }
      else if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {
        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;
        // TODO - lastActivity is not in the update mercury event
        // would need to make an async call to get more conversation details
        // or we can skip this for the SDK, since we will provide an
        // SDK api to allow the app to query this directly if it needs
        // sdkEvent.data.lastActivity = 'to do';
      }
      else {
        throw new Error('unexpected event type');
      }
      sdkEvent.data.id =
        constructHydraId(hydraTypes.ROOM, activity[room].id);
      sdkEvent.data.type =
        activity[room].tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.ONE_ON_ONE) ?
          SDK_EVENT.EXTERNAL.SPACE_TYPE.DIRECT :
          SDK_EVENT.EXTERNAL.SPACE_TYPE.GROUP;
      sdkEvent.data.isLocked =
        activity[room].tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);

      return sdkEvent;
    }
    catch (e) {
      this.spark.logger.error(`Unable to generate SDK event from mercury \
'socket activity for rooms:${event} event: ${e.message}`);

      return null;
    }
  },

  /**
   * Creates a new room. The authenticated user is automatically added as a
   * member of the room. See the {@link Memberships} API to learn how to add
   * more people to the room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * webex.rooms.create({title: 'Create Room Example'})
   *   .then(function(room) {
   *     var assert = require('assert')
   *     assert(typeof room.created === 'string');
   *     assert(typeof room.id === 'string');
   *     assert(room.title === 'Create Room Example');
   *     console.log(room.title);
   *     return 'success';
   *   });
   *   // => success
   */
  create(room) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'rooms',
      body: room
    })
      .then((res) => res.body);
  },

  /**
   * Returns a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @param {Object} options
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * webex.rooms.create({title: 'Get Room Example'})
   *   .then(function(r) {
   *     room = r
   *     return webex.rooms.get(room.id)
   *   })
   *   .then(function(r) {
   *     var assert = require('assert');
   *     assert.deepEqual(r, room);
   *     return 'success';
   *   });
   *   // => success
   */
  get(room, options) {
    const id = room.id || room;

    return this.request({
      service: 'hydra',
      resource: `rooms/${id}`,
      qs: options
    })
      .then((res) => res.body.items || res.body);
  },

  /**
   * Returns a list of rooms. In most cases the results will only contain rooms
   * that the authentiated user is a member of.
   * @instance
   * @memberof Rooms
   * @param {Object} options
   * @param {Object} options.max Limit the maximum number of rooms in the
   * response.
   * @returns {Promise<Page<RoomObject>>}
   * @example
   * var createdRooms;
   * Promise.all([
   *   webex.rooms.create({title: 'List Rooms Example 1'}),
   *   webex.rooms.create({title: 'List Rooms Example 2'}),
   *   webex.rooms.create({title: 'List Rooms Example 3'})
   * ])
   *   .then(function(r) {
   *     createdRooms = r;
   *     return webex.rooms.list({max: 3})
   *       .then(function(rooms) {
   *         var assert = require('assert');
   *         assert(rooms.length === 3);
   *         for (var i = 0; i < rooms.items.length; i+= 1) {
   *           assert(createdRooms.filter(function(room) {
   *             return room.id === rooms.items[i].id;
   *           }).length === 1);
   *         }
   *         return 'success';
   *       });
   *   });
   *   // => success
   */
  list(options) {
    return this.request({
      service: 'hydra',
      resource: 'rooms/',
      qs: options
    })
      .then((res) => new Page(res, this.webex));
  },

  /**
   * Deletes a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @returns {Promise}
   * @example
   * var room;
   * webex.rooms.create({title: 'Remove Room Example'})
   *  .then(function(r) {
   *    room = r;
   *    return webex.rooms.remove(room.id);
   *  })
   *  .then(function() {
   *    return webex.rooms.get(room.id);
   *  })
   *  .then(function() {
   *    var assert = require('assert');
   *    assert(false, 'the previous get should have failed');
   *  })
   *  .catch(function(reason) {
   *    var assert = require('assert');
   *    assert.equal(reason.statusCode, 404);
   *    return 'success'
   *  });
   *  // => success
   */
  remove(room) {
    const id = room.id || room;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: `rooms/${id}`
    })
      .then((res) => {
        // Firefox has some issues with 204s and/or DELETE. This should move to
        // http-core
        if (res.statusCode === 204) {
          return undefined;
        }

        return res.body;
      });
  },

  /**
   * Used to update a single room's properties.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * webex.rooms.update({title: 'Update Room Example'})
   *   .then(function(r) {
   *     room = r;
   *     room.title = 'Update Room Example (Updated Title)';
   *     return webex.rooms.update(room);
   *   })
   *   .then(function() {
   *     return webex.rooms.get(room.id);
   *   })
   *   .then(function(room) {
   *    var assert = require('assert');
   *     assert.equal(room.title, 'Update Room Example (Updated Title)');
   *     return 'success';
   *   });
   *   // => success
   */
  update(room) {
    const {id} = room;

    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: `rooms/${id}`,
      body: room
    })
      .then((res) => res.body);
  }
});

export default Rooms;
