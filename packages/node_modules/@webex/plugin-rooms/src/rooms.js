/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {SparkPlugin, Page} from '@webex/webex-core';
import {cloneDeep} from 'lodash';
import {
  SDK_EVENT,
  createEventEnvelope,
  buildHydraPersonId,
  buildHydraRoomId,
  getHydraRoomType
} from '@webex/common';

const debug = require('debug')('memberships');

/**
 * @typedef {Object} RoomObject
 * @property {string} id - (server generated) Unique identifier for the room
 * @property {string} title - The display name for the room. All room members
 * will see the title so make it something good
 * @property {string} teamId - (optional) The ID of the team to which the room
 * belongs
 * @property {isoDate} created - (server generated) The date and time that the
 * room was created
 */

/**
 * Rooms are virtual meeting places for getting stuff done. This resource
 * represents the room itself. Check out the {@link Memberships} API to learn
 * how to add and remove people from rooms and the {@link Messages} API for
 * posting and managing content.
 * @class
 * @name Rooms
 */
const Rooms = SparkPlugin.extend({
  /**
   * Connect to the web socket to listen to incoming messages.
   * @returns {Promise}
   */
  listen() {
    return createEventEnvelope(this.spark, SDK_EVENT.EXTERNAL.RESOURCE.ROOMS)
      .then((envelope) => {
        this.eventEnvelope = envelope;

        return this.spark.internal.mercury.connect().then(() => {
          this.listenTo(this.spark.internal.mercury,
            SDK_EVENT.INTERNAL.TEAMS_ACTIVITY,
            (event) => this.onWebexApiEvent(event));
        });
      });
  },

  /**
   * Trigger a membership related events.
   * @param {Object} event
   * @returns {undefined} -- nothing //linter requires return in JSDoc
   */
  onWebexApiEvent(event) {
    const {activity} = event.data;

    /* eslint-disable no-case-declarations */
    switch (activity.verb) {
      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.CREATE:
        const roomCreatedEvent =
          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED);

        if (roomCreatedEvent) {
          debug(`room "created" payload: \
            ${JSON.stringify(roomCreatedEvent)}`);
          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED, roomCreatedEvent);
        }
        break;

      case SDK_EVENT.INTERNAL.ACTIVITY_VERB.UPDATE:
        const roomUpdatedEvent =
          this.getRoomEvent(activity, SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED);

        if (roomUpdatedEvent) {
          debug(`room "updated" payload: \
            ${JSON.stringify(roomUpdatedEvent)}`);
          this.trigger(SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED, roomUpdatedEvent);
        }
        break;

      default:
        break;
    }
  },

  /**
   * Constructs the data object for an event on the rooms resource,
   * adhering to Hydra's Webehook data structure.
   * @param {Object} activity from mercury
   * @param {Object} event type of "webhook" event
   * @returns {Object} constructed event
   */
  getRoomEvent(activity, event) {
    try {
      const sdkEvent = cloneDeep(this.eventEnvelope);
      let room;

      sdkEvent.event = event;
      sdkEvent.data.created = activity.published;
      sdkEvent.actorId = buildHydraPersonId(activity.actor.entryUUID);
      if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.CREATED) {
        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.OBJECT;
        sdkEvent.data.creatorId = buildHydraPersonId(activity.actor.entryUUID);
        sdkEvent.data.lastActivity = activity.published;
      }
      else if (event === SDK_EVENT.EXTERNAL.EVENT_TYPE.UPDATED) {
        room = SDK_EVENT.INTERNAL.ACTIVITY_FIELD.TARGET;
        // TODO - lastActivity is not in the mercury 'update' event
        // would need to make an async call to get more conversation details
        // or we can skip this for the SDK, since we will provide an
        // SDK api to allow the app to query this directly if it needs
        // sdkEvent.data.lastActivity = 'to do';
      }
      else {
        throw new Error('unexpected event type');
      }
      sdkEvent.data.id =
      buildHydraRoomId(activity[room].id);
      sdkEvent.data.type = getHydraRoomType(activity[room].tags);
      sdkEvent.data.isLocked =
        activity[room].tags.includes(SDK_EVENT.INTERNAL.ACTIVITY_TAG.LOCKED);

      return sdkEvent;
    }
    catch (e) {
      this.spark.logger.error(`Unable to generate SDK event from mercury \
'socket activity for rooms:${event} event: ${e.message}`);

      return null;
    }
  },

  /**
   * Creates a new room. The authenticated user is automatically added as a
   * member of the room. See the {@link Memberships} API to learn how to add
   * more people to the room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * ciscospark.rooms.create({title: 'Create Room Example'})
   *   .then(function(room) {
   *     var assert = require('assert')
   *     assert(typeof room.created === 'string');
   *     assert(typeof room.id === 'string');
   *     assert(room.title === 'Create Room Example');
   *     console.log(room.title);
   *     return 'success';
   *   });
   *   // => success
   */
  create(room) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'rooms',
      body: room
    })
      .then((res) => res.body);
  },

  /**
   * Returns a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @param {Object} options
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'Get Room Example'})
   *   .then(function(r) {
   *     room = r
   *     return ciscospark.rooms.get(room.id)
   *   })
   *   .then(function(r) {
   *     var assert = require('assert');
   *     assert.deepEqual(r, room);
   *     return 'success';
   *   });
   *   // => success
   */
  get(room, options) {
    const id = room.id || room;

    return this.request({
      service: 'hydra',
      resource: `rooms/${id}`,
      qs: options
    })
      .then((res) => res.body.items || res.body);
  },

  /**
   * Returns a list of rooms. In most cases the results will only contain rooms
   * that the authentiated user is a member of.
   * @instance
   * @memberof Rooms
   * @param {Object} options
   * @param {Object} options.max Limit the maximum number of rooms in the
   * response.
   * @returns {Promise<Page<RoomObject>>}
   * @example
   * var createdRooms;
   * Promise.all([
   *   ciscospark.rooms.create({title: 'List Rooms Example 1'}),
   *   ciscospark.rooms.create({title: 'List Rooms Example 2'}),
   *   ciscospark.rooms.create({title: 'List Rooms Example 3'})
   * ])
   *   .then(function(r) {
   *     createdRooms = r;
   *     return ciscospark.rooms.list({max: 3})
   *       .then(function(rooms) {
   *         var assert = require('assert');
   *         assert(rooms.length === 3);
   *         for (var i = 0; i < rooms.items.length; i+= 1) {
   *           assert(createdRooms.filter(function(room) {
   *             return room.id === rooms.items[i].id;
   *           }).length === 1);
   *         }
   *         return 'success';
   *       });
   *   });
   *   // => success
   */
  list(options) {
    return this.request({
      service: 'hydra',
      resource: 'rooms/',
      qs: options
    })
      .then((res) => new Page(res, this.spark));
  },

  /**
   * Returns a list of rooms with details about the data of the last
   * actvity in the space, and the date of the users last presences in
   * the room.
   *
   * For spaces where lastActivityDate > lastSeenDate the space
   * can be considerd to be "unread"
   *
   * This differs from the rooms.list() function in the following ways:
   *  -- when called with no parameters it returns an array of all
   *     spaces that the user is a member of
   *  -- no other options, eg: max, are considered
   *  -- pagination is not supported. ALL rooms are returned which
   *     can result in a large payload
   *  -- only "id", "lastActivityDate", and "lastSeenDate" are
   *     guaranteed to return
   *  -- "title" is returned for group spaces only to improve
   *     efficiency.  Clients that detect unread status for spaces
   *     with no displayName can query the space details by id
   *
   * In general this function should be used only when the
   * client needs to access read status info, for example on
   * startup.   After startup track message and membership:seen
   * events to maintain read status client side.
   *
   * This function may be deprecated when this info is provided in the membership
   * objects returned in the list function.
   * @instance
   * @memberof Rooms
   * @returns {Promise<RoomObjectList>}
   */
  listWithReadStatus() {
    return this.spark.internal.conversation.list({},
      {
        activitiesLimit: 0,
        participantsLimit: 0,
        isActive: true,
        deferDecrypt: true
      })
      .then((resp) => {
        try {
          // We keep track of the last read message by each user
          const rooms = resp;
          const roomReadInfo = {items: []};

          for (let i = 0; i < rooms.length; i += 1) {
            const room = rooms[i];
            const roomInfo = {
              id: constructHydraId(hydraTypes.ROOM, room.id),
              ...(room.displayName && {title: room.displayName}),
              lastSeenActivityDate: room.lastSeenActivityDate ?
                room.lastSeenActivityDate :
                // If user has never been seen set the date to "a long time ago"
                new Date(0).toISOString()
            };

            if (room.lastReadableActivityDate) {
              roomInfo.lastActivityDate = room.lastReadableActivityDate;
            }
            else if (room.lastRelevantActivityDate) {
              roomInfo.lastActivityDate = room.lastRelevantActivityDate;
            }
            else {
              this.spark.logger.error(`rooms.listWithReadStatus: Cannot read last activity date for a space: ${Info.roomId}.  Ignoring`);
              // eslint-disable-next-line no-continue
              continue;
            }
            roomReadInfo.items.push(roomInfo);
          }

          return Promise.resolve(roomReadInfo);
        }
        catch (e) {
          return Promise.reject(e);
        }
      });
  },

  /**
   * Deletes a single room.
   * @instance
   * @memberof Rooms
   * @param {RoomObject|string} room
   * @returns {Promise}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'Remove Room Example'})
   *  .then(function(r) {
   *    room = r;
   *    return ciscospark.rooms.remove(room.id);
   *  })
   *  .then(function() {
   *    return ciscospark.rooms.get(room.id);
   *  })
   *  .then(function() {
   *    var assert = require('assert');
   *    assert(false, 'the previous get should have failed');
   *  })
   *  .catch(function(reason) {
   *    var assert = require('assert');
   *    assert.equal(reason.statusCode, 404);
   *    return 'success'
   *  });
   *  // => success
   */
  remove(room) {
    const id = room.id || room;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: `rooms/${id}`
    })
      .then((res) => {
        // Firefox has some issues with 204s and/or DELETE. This should move to
        // http-core
        if (res.statusCode === 204) {
          return undefined;
        }

        return res.body;
      });
  },

  /**
   * Used to update a single room's properties.
   * @instance
   * @memberof Rooms
   * @param {RoomObject} room
   * @returns {Promise<RoomObject>}
   * @example
   * var room;
   * ciscospark.rooms.update({title: 'Update Room Example'})
   *   .then(function(r) {
   *     room = r;
   *     room.title = 'Update Room Example (Updated Title)';
   *     return ciscospark.rooms.update(room);
   *   })
   *   .then(function() {
   *     return ciscospark.rooms.get(room.id);
   *   })
   *   .then(function(room) {
   *    var assert = require('assert');
   *     assert.equal(room.title, 'Update Room Example (Updated Title)');
   *     return 'success';
   *   });
   *   // => success
   */
  update(room) {
    const {id} = room;

    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: `rooms/${id}`,
      body: room
    })
      .then((res) => res.body);
  }
});

export default Rooms;
