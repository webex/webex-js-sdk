import {constants} from '@webex/internal-plugin-devices';
import chai from 'chai';
import chaiAsPromised from 'chai-as-promised';
import sinon from 'sinon';
import testUsers from '@webex/test-helper-test-users';
import WebexCore, {WebexHttpError} from '@webex/webex-core';

const {assert} = chai;
const {DEVICES_EVENT_REGISTRATION_SUCCESS} = constants;

chai.use(chaiAsPromised);
sinon.assert.expose(chai.assert, {prefix: ''});

describe('plugin-devices', () => {
  describe('Devices', () => {
    let devices;
    let user;
    let webex;

    beforeEach('create test users and webex instance',
      () => testUsers.create({count: 1})
        .then(([createdUser]) => {
          user = createdUser;

          webex = new WebexCore({
            credentials: user.token
          });

          devices = webex.internal.devices;
        }));

    afterEach('unregister the device and remove test users',
      () => devices.unregister()
        .then(() => testUsers.remove([user])));

    describe('events', () => {
      describe('when a meeting is started', () => {
        beforeEach('setup sinon', () => {
          devices.resetLogoutTimer = sinon.spy();
          webex.trigger('meeting started');
        });

        it('should set \'isInMeeting\' to \'true\'', () => {
          assert.isTrue(devices.isInMeeting);
        });

        it('should call \'resetLogoutTimer()\'', () => {
          assert.called(devices.resetLogoutTimer);
        });
      });

      describe('when a meeting has ended', () => {
        beforeEach('setup sinon', () => {
          devices.resetLogoutTimer = sinon.spy();
          devices.isInMeeting = false;
          webex.trigger('meeting ended');
        });

        it('should set \'isInMeeting\' to \'false\'', () => {
          assert.isFalse(devices.isInMeeting);
        });

        it('should call \'resetLogoutTimer()\'', () => {
          assert.called(devices.resetLogoutTimer);
        });
      });
    });

    describe('#canRegister()', () => {
      describe('when wait is truthy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = true;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin and get catalog', () => {
            services = webex.internal.services;

            return services.waitForCatalog('postauth')
              .then(() => {
                assert.isDefined(services.get('wdm'));
              });
          });

          it('should return a resolved promise', () => {
            assert.isFulfilled(devices.canRegister(wait));
          });
        });

        describe('when the service catalog is not ready', () => {
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;

            services.updateServices();
          });

          describe('when the \'wdm\' service does exist after wait', () => {
            it('should return a resolved promise', () => {
              /* eslint-disable-next-line no-underscore-dangle */
              assert.isTrue(services._getCatalog().status.postauth.collecting);
              assert.isFulfilled(devices.canRegister(wait));
            });
          });

          describe('when the \'wdm\' service does not exist after wait', () => {
            beforeEach('remove wdm service', () => {
              services.get = sinon.stub().returns(undefined);
              services.waitForCatalog = sinon.stub().resolves();
            });

            it('should return a rejected promise', () => {
              /* eslint-disable-next-line no-underscore-dangle */
              assert.isTrue(services._getCatalog().status.postauth.collecting);
              assert.isRejected(devices.canRegister(wait));
            });
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('remove wdm service', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('should return a rejected promise', () => {
            assert.isRejected(devices.canRegister(wait));
          });
        });
      });

      describe('when wait is falsy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = false;
        });

        describe('when the `wdm` service is available', () => {
          let services;

          beforeEach('destructure services plugin', () => {
            services = webex.internal.services;

            return services.updateServices();
          });

          it('should return a resolved promise', () => {
            assert.isFulfilled(devices.canRegister(wait));
          });
        });

        describe('when the service catalog is not ready', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();
            catalog.serviceGroups.postauth = [];

            services.updateServices();
          });

          it('should return a rejected promise', () => {
            /* eslint-disable-next-line no-underscore-dangle */
            assert.isTrue(services._getCatalog().status.postauth.collecting);
            assert.isRejected(devices.canRegister(wait));
          });
        });

        describe('when the `wdm` service is not available', () => {
          let catalog;
          let services;

          beforeEach('setup catalog to be not ready', () => {
            services = webex.internal.services;
            /* eslint-disable-next-line no-underscore-dangle */
            catalog = services._getCatalog();

            catalog.serviceGroups.postauth = [];
          });

          it('should return a rejected promise', () => {
            assert.isRejected(devices.canRegister(wait));
          });
        });
      });
    });

    describe('#clear()', () => {
      beforeEach('append a feature', () => {
        devices.features.set({
          developer: [{
            key: 'console',
            type: 'boolean',
            val: 'true',
            value: true,
            mutable: true,
            lastModified: '2015-06-29T20:02:48.033Z'
          }]
        });
      });

      it('should clear all features', () => {
        assert.isAbove(devices.features.developer.length, 0);
        devices.clear();
        assert.lengthOf(devices.features.developer, 0);
      });

      it('should not clear the logger', () => {
        assert.property(devices, 'logger');
        assert.isDefined(devices.logger);
        devices.clear();
        assert.property(devices, 'logger');
        assert.isDefined(devices.logger);
      });
    });

    describe('#checkNetworkReachability()', () => {
      describe('when the reachability check has already been completed', () => {
        beforeEach('set reachability checked to true', () => {
          devices.isReachabilityChecked = true;
        });

        it('should return a resolved promise', () => {
          assert.isFulfilled(devices.checkNetworkReachability());
        });
      });

      describe('when there is no intranet inactivity check url', () => {
        beforeEach('set devices properties', () => {
          devices.intranetInactivityCheckUrl = undefined;
          devices.isReachabilityChecked = false;
        });

        it('should set the in-network property to false',
          () => devices.checkNetworkReachability()
            .then(() => {
              assert.isFalse(devices.isInNetwork);
            }));

        it('should return a resolved promise',
          () => assert.isFulfilled(devices.checkNetworkReachability()));

        describe('when the device has inactivity enforcement', () => {
          let logoutTimer;

          beforeEach('set device to enforce inactivity timers', () => {
            devices.config.enableInactivityEnforcement = true;
            logoutTimer = devices.logoutTimer;
            devices.intranetInactivityCheckUrl = undefined;
          });

          it('should not reset the logout timer',
            () => devices.checkNetworkReachability()
              .then(() => assert.equal(devices.logoutTimer, logoutTimer)));
        });
      });

      describe('when the rechability check is performable', () => {
        beforeEach('setup for reachability check', () => {
          // Due to property overriding, `isReachabilityChecked` must be set
          // within each `it` statement.
          devices.isInNetwork = false;
        });

        describe('when the network is reachabable', () => {
          beforeEach('set inactivity check url and stubs', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/spark_session_check.json';

            devices.resetLogoutTimer = sinon.spy();

            devices.request = sinon.stub().resolves({});
          });

          it('should call \'resetLogoutTimer()\'', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.called(devices.resetLogoutTimer));
          });

          it('should set the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('should set the in-network property to true', () => {
            devices.isReachabilityChecked = false;

            assert.isFalse(devices.isInNetwork);

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isInNetwork));
          });

          it('should return a resolved promise',
            () => assert.isFulfilled(devices.checkNetworkReachability()));
        });

        describe('when the network is not reachable', () => {
          beforeEach('set an invalid inactivity check url', () => {
            devices.intranetInactivityCheckUrl =
              'https://myspark.cisco.com/bad-spark_session_check.json';
          });

          it('should set the reachability check to true', () => {
            devices.isReachabilityChecked = false;

            return devices.checkNetworkReachability()
              .then(() => assert.isTrue(devices.isReachabilityChecked));
          });

          it('should set the in-network property to false',
            () => devices.checkNetworkReachability()
              .then(() => assert.isFalse(devices.isInNetwork)));

          it('should return a resolved promise',
            () => assert.isFulfilled(devices.checkNetworkReachability()));
        });
      });
    });

    describe('#getWebSocketUrl()', () => {
      let services;

      beforeEach('destructure services', () => {
        services = webex.internal.services;
      });

      describe('when wait is truthy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = true;
        });

        describe('when the device is registered', () => {
          beforeEach('register the device', () => devices.register());

          it('should resolve the promise with the websocket url',
            () => devices.getWebSocketUrl(wait)
              .then((url) => {
                assert.isDefined(url);
                assert.isTrue(services.isServiceUrl(url));
                assert.include(url, 'mercury');
              }));
        });

        describe('when the device is not registered', () => {
          describe('when the device successfully registers', () => {
            it('should resolve the promise with the websocket url',
              () => Promise.all([
                devices.getWebSocketUrl(wait),
                devices.register()
              ])
                .then(([url]) => {
                  assert.isTrue(services.isServiceUrl(url));
                  assert.include(
                    services.getServiceFromUrl(url).name,
                    'mercury'
                  );
                }));
          });

          it('should return a rejected promise if the device never registers',
            () => assert.isRejected(devices.getWebSocketUrl(wait)));
        });
      });

      describe('when wait is falsy', () => {
        let wait;

        beforeEach('set wait', () => {
          wait = false;
        });

        describe('when the device is registered', () => {
          beforeEach('register the device', () => devices.register());

          describe('when the priority host can be mapped', () => {
            it('should resolve the promise with the websocket url',
              () => devices.getWebSocketUrl(wait)
                .then((url) => {
                  assert.isDefined(url);
                  assert.isTrue(services.isServiceUrl(url));
                  assert.include(url, 'mercury');
                }));
          });

          describe('when the priority host cannot be mapped', () => {
            beforeEach('stub priority host url converting', () => {
              services.convertUrlToPriorityHostUrl = sinon.stub();
              services.convertUrlToPriorityHostUrl.returns(undefined);
            });

            it('should return a rejected promise',
              () => assert.isRejected(devices.getWebSocketUrl(wait)));
          });
        });

        describe('when the device is not registered', () => {
          it('should return a rejected promise',
            () => assert.isRejected(devices.getWebSocketUrl(wait)));
        });
      });
    });

    describe('#meetingStarted()', () => {
      let spy;

      beforeEach('setup instance function', () => {
        spy = sinon.spy();
      });

      it('should trigger a \'meeting started\' event', () => {
        webex.on('meeting started', spy);
        devices.meetingStarted();
        assert.called(spy);
      });
    });

    describe('#meetingEnded()', () => {
      let spy;

      beforeEach('setup instance function', () => {
        spy = sinon.spy();
      });

      it('should trigger a \'meeting ended\' event', () => {
        webex.on('meeting ended', spy);
        devices.meetingEnded();
        assert.called(spy);
      });
    });

    describe('#processRegistrationSuccess()', () => {
      let customResponse;
      let spy;

      beforeEach('setup parameters', () => {
        customResponse = {
          body: {
            exampleKey: 'exampleValue',
            services: [],
            serviceHostMap: []
          }
        };

        spy = sinon.spy();
      });

      it('should set the device properties to the response values', () => {
        devices.processRegistrationSuccess(customResponse);
        assert.equal(devices.exampleKey, customResponse.body.exampleKey);
      });

      it('should not set a \'services\' property', () => {
        devices.processRegistrationSuccess(customResponse);
        assert.isUndefined(devices.services);
      });

      it('should not set a \'serviceHostMap\' property', () => {
        devices.processRegistrationSuccess(customResponse);
        assert.isUndefined(devices.serviceHostMap);
      });

      it(`should trigger '${DEVICES_EVENT_REGISTRATION_SUCCESS}'`, () => {
        devices.on(DEVICES_EVENT_REGISTRATION_SUCCESS, spy);
        devices.processRegistrationSuccess(customResponse);
        assert.called(spy);
      });

      describe('when the device is ephemeral', () => {
        beforeEach('set the device to ephemeral', () => {
          devices.config.ephemeral = true;
        });

        it('should create a refresh timer', () => {
          const {refreshTimer} = devices;

          devices.processRegistrationSuccess(customResponse);
          assert.notEqual(devices.refreshTimer, refreshTimer);
          assert.isDefined(devices.refreshTimer);
        });
      });
    });

    describe('#refresh()', () => {
      describe('when the device can register', () => {
        describe('when the device is not registered', () => {
          beforeEach('setup spy function', () => {
            devices.register = sinon.spy();
          });

          it('should attempt to register', () => devices.refresh()
            .then(() => assert.called(devices.register)));
        });

        describe('when the device is registered', () => {
          let exampleResponse;

          beforeEach('register the device', () => {
            exampleResponse = {
              body: {
                exampleKey: 'example response value'
              }
            };

            return devices.register()
              .then(() => {
                devices.request = sinon.stub().returns(Promise.resolve(
                  {...exampleResponse}
                ));
              });
          });

          describe('when the device is ephemeral', () => {
            beforeEach('set device to ephemeral', () => {
              devices.config.ephemeral = true;
            });

            it('should set the ttl property to the config values',
              () => devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.ttl', devices.config.ephemeralDeviceTTL
                  ))));
          });

          describe('when the refresh request is sent', () => {
            let customHeaders;
            let customBody;

            beforeEach('configure devices plugin', () => {
              customHeaders = {
                testHeader: 'example header value'
              };

              customBody = {
                testBody: 'example body value'
              };
            });

            it('should allow for custom header key:values', () => {
              devices.config.headers = {...customHeaders};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'headers.testHeader', customHeaders.testHeader
                  )));
            });

            it('should allow for custom body key:values', () => {
              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.testBody', customBody.testBody
                  )));
            });

            it('should use the device\'s url property', () => {
              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'uri', devices.url
                  )));
            });

            it('should send a PUT request', () => {
              devices.config.body = {...customBody};

              return devices.refresh()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'method', 'PUT'
                  )));
            });
          });

          describe('when the device is successfully refreshes', () => {
            beforeEach('setup stubs', () => {
              devices.processRegistrationSuccess = sinon.stub();
            });

            it('should return a resolved promise',
              () => assert.isFulfilled(devices.refresh()));

            it('should call \'processRegistrationSuccess()\'',
              () => devices.refresh()
                .then(() => assert.called(devices.processRegistrationSuccess)));
          });

          describe('when the device fails to refresh', () => {
            describe('when the device is not found', () => {
              let request;

              beforeEach('setup request stub to 404', () => {
                request = devices.request;

                devices.register = sinon.spy();

                devices.request = sinon.stub().rejects(
                  new WebexHttpError({
                    statusCode: 404,
                    options: {
                      url: devices.url,
                      headers: {
                        trackingId: 'tid'
                      }
                    }
                  })
                );
              });

              afterEach('reset the device request', () => {
                devices.request = request;
              });

              it('should clear the current device', () => devices.refresh()
                .then(() => assert.isUndefined(devices.url)));

              it('should attempt to register a new device', () =>
                devices.refresh()
                  .then(() => assert.called(devices.register)));
            });

            describe('when the device was found', () => {
              let request;

              beforeEach('setup request stub to 503', () => {
                request = devices.request;

                devices.request = sinon.stub().rejects(
                  new WebexHttpError({
                    statusCode: 503,
                    options: {
                      url: devices.url,
                      headers: {
                        trackingId: 'tid'
                      }
                    }
                  })
                );
              });

              afterEach('resest the request method', () => {
                devices.request = request;
              });

              it('should return a rejected promise',
                () => assert.isRejected(devices.refresh()));
            });
          });
        });
      });

      describe('when the device cannot register', () => {
        beforeEach('setup \'canRegister()\' stub', () => {
          devices.canRegister = sinon.stub().rejects(
            new Error()
          );
        });

        it('should return a rejected promise',
          () => assert.isRejected(devices.refresh()));
      });
    });

    describe('#register()', () => {
      describe('when the device can register', () => {
        describe('when the device is already registered', () => {
          beforeEach('setup \'register()\' spy and register', () => {
            devices.refresh = sinon.spy();

            return devices.register();
          });

          it('should attempt to refresh', () => devices.register()
            .then(() => assert.called(devices.refresh)));
        });

        describe('when the device is not already registered', () => {
          let exampleResponse;

          beforeEach('setup stubs and scoped variables', () => {
            exampleResponse = {
              body: {
                exampleKey: 'example response value'
              }
            };

            devices.request = sinon.stub().returns(Promise.resolve(
              {...exampleResponse}
            ));
          });

          describe('when the registration request is sent', () => {
            let customHeaders;
            let customBody;

            beforeEach('configure devices plugin', () => {
              customHeaders = {
                testHeader: 'example header value'
              };

              customBody = {
                testBody: 'example body value'
              };
            });

            it('should allow for custom header key:values', () => {
              devices.config.headers = {...customHeaders};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'headers.testHeader', customHeaders.testHeader
                  )));
            });

            it('should allow for custom body key:values', () => {
              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.hasNested(
                    'body.testBody', customBody.testBody
                  )));
            });

            it('should use the \'wdm\' service', () => {
              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'service', 'wdm'
                  )));
            });

            it('should use the \'devices\' resource', () => {
              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'resource', 'devices'
                  )));
            });

            it('should send a POST request', () => {
              devices.config.body = {...customBody};

              return devices.register()
                .then(() =>
                  assert.calledWith(devices.request, sinon.match.has(
                    'method', 'POST'
                  )));
            });
          });

          describe('when the device is successfully registered', () => {
            beforeEach('setup stubs', () => {
              devices.processRegistrationSuccess = sinon.stub();
            });

            it('should return a resolved promise',
              () => assert.isFulfilled(devices.register()));

            it('should call \'processRegistrationSuccess()\'',
              () => devices.register()
                .then(() => assert.called(devices.processRegistrationSuccess)));
          });

          describe('when the device fails to register', () => {
            beforeEach('setup request stub to 503', () => {
              devices.request = sinon.stub().rejects(
                new WebexHttpError({
                  statusCode: 503,
                  options: {
                    url: 'http://not-a-url.com/resource',
                    headers: {
                      trackingId: 'tid'
                    }
                  }
                })
              );
            });

            it('should return a rejected promise',
              () => assert.isRejected(devices.register()));
          });
        });
      });

      describe('when the device cannot register', () => {
        beforeEach('setup \'canRegister()\' stub', () => {
          devices.canRegister = sinon.stub().rejects(
            new Error()
          );
        });

        it('should return a rejected promise',
          () => assert.isRejected(devices.register()));
      });
    });

    describe('#resetLogoutTimer()', () => {
      describe('when inactivty enforcement is enabled', () => {
        beforeEach('set inactity enforcement and reachability checked', () => {
          devices.config.enableInactivityEnforcement = true;
          devices.isReachabilityChecked = true;
        });

        describe('when the user is in a meeting', () => {
          beforeEach('set user to be in a meeting', () => {
            devices.isInMeeting = true;
          });

          it('should not set the logout timer', () => {
            devices.resetLogoutTimer();

            assert.isUndefined(devices.logoutTimer);
          });
        });

        describe('when the user is not in a meeting', () => {
          beforeEach('setup the \'setLogoutTimer()\' spy', () => {
            devices.setLogoutTimer = sinon.stub();
          });

          describe('when the user is in network', () => {
            beforeEach('set user to be in network', () => {
              devices.isInNetwork = true;
            });

            it('should set the logout timer to the in-network duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityCheckUrl
              );
            });
          });

          describe('when the user is not in network', () => {
            beforeEach('set the user to not be in network', () => {
              devices.isInNetwork = false;
            });

            it('should set the logout timer to the intranet duration', () => {
              devices.resetLogoutTimer();

              assert.calledWith(
                devices.setLogoutTimer,
                devices.intranetInactivityDuration
              );
            });
          });
        });
      });
    });

    describe('#unregister()', () => {
      describe('when the device is registered', () => {
        beforeEach('register the device', () => devices.register());

        describe('when the unregistration request is sent', () => {
          let url;

          beforeEach('setup the \'request()\' stub', () => {
            devices.request = sinon.stub().resolves();
            url = devices.url;
          });

          it('should use the device\'s url property', () => devices.unregister()
            .then(() =>
              assert.calledWith(devices.request, sinon.match.has(
                'uri', url
              ))));

          it('should send a DELETE request', () => devices.unregister()
            .then(() =>
              assert.calledWith(devices.request, sinon.match.has(
                'method', 'DELETE'
              ))));
        });

        describe('when the device unregistration request is successful', () => {
          it('should clear the device url', () => devices.unregister()
            .then(() => assert.isUndefined(devices.url)));
        });

        describe('when the device unregistration request fails', () => {
          let request;

          beforeEach('setup the \'request\' stub', () => {
            request = devices.request;

            devices.request = sinon.stub().rejects(
              new WebexHttpError({
                statusCode: 404,
                options: {
                  url: devices.url,
                  headers: {
                    trackingId: 'tid'
                  }
                }
              })
            );
          });

          afterEach('reset the request method', () => {
            devices.request = request;
          });

          it('returns a rejected promise',
            () => assert.isRejected(devices.unregister()));
        });
      });

      describe('when the device is not registered', () => {
        it('should return a resolved promise',
          () => assert.isFulfilled(devices.unregister()));
      });
    });

    describe('#waitForRegistration()', () => {
      describe('when the device is registered', () => {
        beforeEach('register the device', () => devices.register());

        it('should return a resolved promise',
          () => assert.isFulfilled(devices.waitForRegistration()));
      });

      describe('when the device is not registered', () => {
        describe('when the device registers', () => {
          it('should return a resolved promise once registered',
            () => Promise.all([
              devices.waitForRegistration(),
              devices.register()
            ])
              .then(() => assert.isTrue(devices.registered)));
        });

        describe('when the device does not register', () => {
          it('should return a rejected promise',
            () => assert.isRejected(devices.waitForRegistration()));
        });
      });
    });
  });
});
