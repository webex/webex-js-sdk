// Internal Dependencies
import {WebexPlugin} from '@webex/webex-core';
import {safeSetTimeout} from '@webex/common-timers';

// Local Dependencies
import {FEATURE_COLLECTION_NAMES} from './constants';
import FeaturesModel from './features/features-model';

const Devices = WebexPlugin.extend({

  // Ampersand property members.

  namespace: 'Devices',

  // Allow for extra properties to prevent the plugin from failing due to
  // **WDM** service DTO changes.
  extraProperties: 'allow',

  children: {
    /**
     * The class object that contains all of the feature collections.
     *
     * @type {FeaturesModel}
     */
    features: FeaturesModel
  },

  /**
   * A collection of device properties mostly assigned by the retrieved DTO from
   * the **WDM** service that are mapped against the ampersand properties.
   *
   * @type {Object}
   */
  props: {
    /**
     * This property determines whether or not giphy support is enabled.
     *
     * @type {'ALLOW' | 'BLOCK'}
     */
    clientMessagingGiphy: 'string',

    /**
     * This property should store the company name.
     *
     * @type {string}
     */
    customerCompanyName: 'string',

    /**
     * This property should store the logo url.
     *
     * @type {string}
     */
    customerLogoUrl: 'string',

    /**
     * This property doesn't have any real values, but is sent during device
     * refresh to prevent the **wdm** service from falling back to an iOS device
     * type.
     *
     * @type {string}
     */
    deviceType: 'string',

    /**
     * This property should store the help url.
     *
     * @type {string}
     */
    helpUrl: 'string',

    /**
     * This property should store the intranet inactivity timer duration.
     *
     * @type {number}
     */
    intranetInactivityDuration: 'number',

    /**
     * This property stores the url required to validate if the device is able
     * to actively reach the intranet network.
     *
     * @type {string}
     */
    intranetInactivityCheckUrl: 'string',

    /**
     * This property stores the inactivity timer duration, and could possibly
     * deprecate the `intranetInactivityDuration` property.
     *
     * @type {number}
     */
    inNetworkInactivityDuration: 'number',

    /**
     * This property stores the ECM (external content management) enabled value
     * for the whole organization.
     *
     * @type {boolean}
     */
    ecmEnabledForAllUsers: ['boolean', false, false],

    /**
     * This property stores an array of ECM (external content management)
     * providers that are currently available.
     *
     * @returns {Array<string>}
     */
    ecmSupportedStorageProviders: ['array', false, (() => [])],

    /**
     * This property stores the modification time value retrieved from the
     * **WDM** endpoint formatted as ISO 8601.
     *
     * @type {string}
     */
    modificationTime: 'string',

    /**
     * This property stores the navigation bar color.
     *
     * @type {string}
     */
    navigationBarColor: 'string',

    /**
     * This property stores the partner company's name when available.
     *
     * @type {string}
     */
    partnerCompanyName: 'string',

    /**
     * This property stores the partner company's logo when available.
     *
     * @type {string}
     */
    partnerLogoUrl: 'string',

    /**
     * This property stores the availability of people data from the **WDM**
     * service.
     *
     * @type {boolean}
     */
    peopleInsightsEnabled: 'boolean',

    /**
     * This property stores the reporting site's description when available.
     *
     * @type {string}
     */
    reportingSiteDesc: 'string',

    /**
     * This property stores the reporting site's access url when available.
     *
     * @type {string}
     */
    reportingSiteUrl: 'string',

    /**
     * This property stores the encryption key url when available.
     *
     * @type {string}
     */
    searchEncryptionKeyUrl: 'string',

    /**
     * This property stores the availability of support-provided text from the
     * **WDM** service.
     *
     * @type {boolean}
     */
    showSupportText: 'boolean',

    /**
     * This property stores the support provider's company name when available.
     *
     * @type {string}
     */
    supportProviderCompanyName: 'string',

    /**
     * This property stores the support provider's logo url when available.
     *
     * @type {string}
     */
    supportProviderLogoUrl: 'string',

    /**
     * This property stores the device's url retrieved from a registration
     * request. This property gets set via the initial registration process by a
     * `this.set()` method.
     *
     * @type {string}
     */
    url: 'string',

    /**
     * This property stores the device's userId uuid value, which can also be
     * derived from the device's registerd user's userId retrieved from
     * the **Hydra** service.
     *
     * @type {string}
     */
    userId: 'string',

    /**
     * This property stores whether or not file sharing is enabled
     *
     * @type {'BLOCK_BOTH' | 'BLOCK_UPLOAD'}
     */
    webFileShareControl: 'string',

    /**
     * This property stores the current web socket url used by the registered
     * device.
     *
     * @type {string}
     */
    webSocketUrl: 'string',

    /**
     * This property stores the value indicating whether or not white board file
     * sharing is enabled for the current device.
     *
     * @type {'ALLOW' | 'BLOCK'}
     */
    whiteboardFileShareControl: 'string'
  },

  /**
   * A list of derived properties that populate based when their parent data
   * available via the device's properties.
   *
   * @type {Object}
   */
  derived: {
    /**
     * This property determines if the current device is registered.
     *
     * @type {boolean}
     */
    registered: {
      deps: ['url'],

      /**
       * Checks if the device is registered by validating that the url exists.
       * Amperstand does not allow this to method to be written as an arrow
       * function.
       *
       * @returns {boolean}
       */
      fn() {
        return !!(this.url);
      }
    }
  },

  /**
   * Stores timer data as well as other state details.
   *
   * @type {Object}
   */
  session: {
    /**
     * This property stores the logout timer object
     *
     * @type {any}
     */
    logoutTimer: 'any',

    /**
     * This property stores the date for the last activity the user made
     * with the current device.
     *
     * @type {number}
     */
    lastUserActivityDate: 'number',

    /**
     * This property stores whether or not the reachability check has been
     * performed to prevent the reachability check from performing its
     * operation more than once after a successful check.
     *
     * @returns {boolean}
     */
    isReachabilityChecked: ['boolean', false, false],

    /**
     * This property stores whether or not the current device is in a meeting
     * to prevent an unneeded timeout of a meeting due to inactivity.
     *
     * @type {boolean}
     */
    isInMeeting: 'boolean',

    /**
     * This property identifies if the device is currently in network to prevent
     * the `resetLogoutTimer()` method from being called repeatedly once its
     * known client is connected to the organization's internal network.
     *
     * @type {boolean}
     */
    isInNetwork: 'boolean'
  },

  // Event method members.

  /**
   * Trigger meeting started event for webex instance. Used by web-client team.
   *
   * @returns {void}
   */
  meetingStarted() {
    this.webex.trigger('meeting started');
  },

  /**
   * Trigger meeting ended event for webex instance. Used by web-client team.
   *
   * @returns {void}
   */
  meetingEnded() {
    this.webex.trigger('meeting ended');
  },

  // Registration method members

  refresh() {}, // Refreshes the device's registration.
  register() {}, // Registers a device.
  unregister() {}, // Unregisters the device.

  // Helper method members

  /**
   * Determine if registration methods can be performed. This method utilizes
   * the `services` plugin to confirm if the appropriate service urls are
   * available for device registration.
   *
   * @param {boolean} [wait=false] - Willing to wait on registration.
   * @returns {Promise<void, Error>}
   */
  canRegister(wait = false) {
    this.logger.info('devices: validating if registration can occur');

    // Destructure the services plugin for ease of reference.
    const {services} = this.webex.internal;

    // Validate if the service url exists in the service catalog.
    if (services.get('wdm')) {
      return Promise.resolve();
    }

    // If wait is true, wait for the catalog to populate.
    if (wait) {
      return services.waitForCatalog('postauth',
        this.config.canRegisterWaitDuration);
    }

    // Reject if the service url is not available.
    return Promise.reject(new Error(
      '`wdm` service is not currently available'
    ));
  },

  /**
   * Check if the device can currently reach the inactivity check url.
   *
   * @returns {Promise<void, Error>}
   */
  checkNetworkReachability() {
    this.logger.info('devices: checking network reachability');

    // Validate if the device has been checked and reset the logout timer.
    if (this.isReachabilityChecked) {
      return Promise.resolve(this.resetLogoutTimer());
    }

    // Validate if the device has a intranet checking url.
    if (!this.intranetInactivityCheckUrl) {
      this.isInNetwork = false;

      return Promise.resolve(this.resetLogoutTimer());
    }

    this.isReachabilityChecked = true;

    // Clear unnecessary headers for reachability request.
    const headers = {
      'cisco-no-http-redirect': null,
      'spark-user-agent': null,
      trackingid: null
    };

    // Send the network reachability request.
    return this.request({
      headers,
      method: 'GET',
      uri: this.intranetInactivityCheckUrl
    })
      .then(() => {
        this.isInNetwork = true;

        return Promise.resolve(this.resetLogoutTimer());
      })
      .catch(() => {
        this.logger.info('devices: did not reach ping endpoint');
        this.logger.info('devices: triggering off-network timer');

        this.isInNetwork = false;

        return Promise.resolve(this.resetLogoutTimer());
      });
  },

  /**
   * Clears the registration ttl value if available.
   *
   * @param {Object} options - Values to be cleared.
   * @returns {void}
   */
  clear(...args) {
    this.logger.info('devices: clearing registered device');

    // Prototype the extended class in order to preserve the parent member.
    Reflect.apply(WebexPlugin.prototype.clear, this, args);
  },

  getWebSocketUrl() {}, // Retrieves the priority-mapped web socket url.

  /**
   * Process a successful device registration.
   *
   * @param {Object} response - response object from registration success.
   * @returns {void}
   */
  processRegistrationSuccess(response) {
    this.logger.info('devices: received registration payload');

    // Assign the recieved DTO from **WDM** to this device.
    this.set(response.body);

    // Validate if device is ephemeral and setup refresh timer.
    if (this.config.ephemeral) {
      this.logger.info('devices: enqueuing device refresh');

      const delay = (this.config.ephemeralDeviceTTL / 2 + 60) * 1000;

      this.refreshTimer = safeSetTimeout(() => this.refresh(), delay);
    }

    // Emit the registration:success event.
    this.trigger('registration:success', this);
  },

  /**
   * Reset the current local logout timer for the registered device if
   * registered.
   *
   * @returns {void}
   */
  resetLogoutTimer() {
    this.logger.info('devices: resetting logout timer');

    // Clear current logout timer.
    clearTimeout(this.logoutTimer);

    // Remove last activity date event listener.
    this.off('change:lastUserActivityDate');

    // Remove the logout timer.
    this.unset('logoutTimer');

    // Validate if the device is currently in a meeting and is configured to
    // required inactivity enforcement.
    if (!this.isInMeeting && this.config.enableInactivityEnforcement &&
      this.isReachabilityChecked) {
      if (this.isInNetwork) {
        this.setLogoutTimer(this.inNetworkInactivityDuration);
      }
      else {
        this.setLogoutTimer(this.intranetInactivityDuration);
      }
    }
  },

  /**
   * Set the value of the logout timer for the current registered device.
   *
   * @param {number} duration - Value in seconds of the new logout timer.
   * @returns {void}
   */
  setLogoutTimer(duration) {
    this.logger.info('devices: setting logout timer');

    if (!duration || duration <= 0) {
      return;
    }

    // Setup user activity date event listener.
    this.on('change:lastUserActivityDate', () => { this.resetLogoutTimer(); });

    // Initialize a new timer.
    this.logoutTimer = safeSetTimeout(() => {
      this.webex.logout();
    }, duration * 1000);
  },

  waitForRegistration() {}, // Eventing method queue actions after registration.

  // Ampersand method members

  /**
   * Initializer method for the devices plugin.
   *
   * @override
   * @param {Array<any>} args - An array of items to be mapped as properties.
   * @returns {void}
   */
  initialize(...args) {
    // Prototype the extended class in order to preserve the parent member.
    Reflect.apply(WebexPlugin.prototype.initialize, this, args);

    // Initialize feature events and listeners.
    FEATURE_COLLECTION_NAMES.forEach((collectionName) => {
      this.features.on(`change:${collectionName}`, (model, value, options) => {
        this.trigger('change', this, options);
        this.trigger('change:features', this, this.features, options);
      });
    });

    // Initialize network reachability checking event for url change.
    this.on('change:intranetInactivityCheckUrl', () => {
      this.checkNetworkReachability();
    });

    // Initialize network reachability checking event for duration change.
    this.on('change:intranetInactivityDuration', () => {
      this.checkNetworkReachability();
    });

    // Initialize network reachability checking event for duration change.
    this.on('change:inNetworkInactivityDuration', () => {
      this.checkNetworkReachability();
    });

    // Initialize listener for activity checking.
    this.listenTo(this.webex, 'user-activity', () => {
      this.lastUserActivityDate = Date.now();
    });

    // Initialize listener for meeting started event.
    this.listenTo(this.webex, 'meeting started', () => {
      this.isInMeeting = true;
      this.resetLogoutTimer();
    });

    // Initialize listener for meeting ended event.
    this.listenTo(this.webex, 'meeting ended', () => {
      this.isInMeeting = false;
      this.resetLogoutTimer();
    });
  }
});

export default Devices;
