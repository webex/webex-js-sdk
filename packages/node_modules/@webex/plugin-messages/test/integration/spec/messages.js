/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-wdm';
import '@webex/plugin-logger';
import '@webex/plugin-rooms';
import '@webex/plugin-people';
import '@webex/plugin-messages';
import CiscoSpark, {SparkHttpError} from '@webex/webex-core';
import {SDK_EVENT} from '@webex/common';
import {assert} from '@webex/test-helper-chai';
import sinon from '@webex/test-helper-sinon';
import testUsers from '@webex/test-helper-test-users';
import fh from '@webex/test-helper-file';
import {browserOnly, flaky, nodeOnly} from '@webex/test-helper-mocha';

const debug = require('debug')('messages');

const KNOWN_HOSTED_IMAGE_URL = 'https://download.ciscospark.com/test/photo.png';

describe('plugin-messages', function () {
  this.timeout(60000);

  let spark;
  let actor;

  before(() => testUsers.create({count: 1})
    .then(([user]) => {
      spark = new CiscoSpark({credentials: user.token});
      spark.people.get('me')
        .then((person) => {
          actor = person;
        });
    }));

  describe('#messages', () => {
    let room;

    before(() => spark.rooms.create({title: 'Cisco Spark Test Room'})
      .then((r) => {
        room = r;
        const text = 'First Message';

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => {
            validateMessage(message, text);
          });
      }));

    after(() => {
      if (!room) {
        return Promise.resolve();
      }

      return spark.rooms.remove(room)
        .catch((reason) => {
          console.error('Failed to remove room', reason);
        });
    });

    afterEach(() => spark.messages.stopListening());

    describe('#create()', () => {
      it('posts a message in a room and validates the messages:created event', () => {
        let message;

        // "Block" this test with a promise that will
        // resolve after the messages:created arrives.
        const created = new Promise((resolve) => {
          spark.messages.on('created', (event) => {
            debug('message created event called');
            resolve(event);
          });
        });

        const text = 'A test message';

        return spark.messages.listen()
          .then(() => spark.messages.create({
            roomId: room.id,
            text
          })
            .then(async (m) => {
              message = m;
              validateMessage(message, text);
              const event = await created;

              validateMessageEvent(event, message, actor);
            }));
      });

      it('posts a file to a room by specifying the file\'s url and validates the event', () => {
        const created = new Promise((resolve) => {
          spark.messages.on('created', (event) => {
            debug('message created event called');
            resolve(event);
          });
        });

        return spark.messages.listen()
          .then(() => spark.messages.create({
            roomId: room.id,
            file: KNOWN_HOSTED_IMAGE_URL
          })
            .then(async (message) => {
              validateMessage(message);
              const event = await created;

              validateMessageEvent(event, message, actor);
            }));
      });

      let blob, buffer;
      const text = 'A File';

      browserOnly(before)(() => fh.fetch('sample-image-small-one.png')
        .then((file) => {
          blob = file;

          return new Promise((resolve) => {
            /* global FileReader */
            const fileReader = new FileReader();

            fileReader.onload = function () {
              buffer = this.result;
              resolve();
            };
            fileReader.readAsArrayBuffer(blob);
          });
        }));

      nodeOnly(before)(() => fh.fetchWithoutMagic('sample-image-small-one.png')
        .then((file) => {
          buffer = file;
        }));

      browserOnly(it)('posts a file to a room by directly supplying its blob and validates the event', () => {
        const created = new Promise((resolve) => {
          spark.messages.on('created', (event) => {
            debug('message created event called');
            resolve(event);
          });
        });

        return spark.messages.listen()
          .then(() => spark.messages.create({
            roomId: room.id,
            file: blob,
            text
          })
            .then(async (message) => {
              validateMessage(message);
              const event = await created;

              validateMessageEvent(event, message, actor);
            }));
      });

      // Disabling it gating pipelines because it failes a lot and we get
      // mostly adequate coverage via blob upload
      flaky(it, process.env.SKIP_FLAKY_TESTS)('posts a file to a room by directly supplying its buffer and validates the event', () => spark.messages.create({
        roomId: room.id,
        file: buffer
      })
        .then((message) => {
          validateMessage(message, '', 1);
        }));

      it('posts a file with a message to a room by specifying the file\'s url and validates the event', () => {
        const created = new Promise((resolve) => {
          spark.messages.on('created', (event) => {
            debug('message created event called');
            resolve(event);
          });
        });

        return spark.messages.listen()
          .then(() => spark.messages.create({
            roomId: room.id,
            file: KNOWN_HOSTED_IMAGE_URL,
            text
          })
            .then(async (message) => {
              validateMessage(message);
              const event = await created;

              validateMessageEvent(event, message, actor);
            }));
      });
    });

    describe('#remove()', () => {
      let message;
      const text = 'This message will be deleted';

      beforeEach(() => spark.messages.create({
        roomId: room.id,
        text
      })
        .then((m) => {
          message = m;
          validateMessage(m, text);
        }));

      it('deletes a single message and validates the message:deleted event', () => {
        const deleted = new Promise((resolve) => {
          spark.messages.on('deleted', (event) => {
            debug('message deleted event called');
            resolve(event);
          });
        });

        return spark.messages.listen()
          .then(() => spark.messages.remove(message)
            .then((body) => {
              assert.notOk(body);

              return assert.isRejected(spark.messages.get(message));
            })
            .then(async (reason) => {
              assert.instanceOf(reason, SparkHttpError.NotFound);
              const event = await deleted;

              validateMessageEvent(event, message, actor);
            }));
      });
    });

    describe('get()', () => {
      let message;
      const text = 'A test message';

      before(() => {
        // The above tests validate all the events
        // Turn off the event listener for the remainder of the tests
        spark.messages.off('created');
        spark.messages.off('deleted');

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((m) => {
            message = m;
            validateMessage(message, text);
          });
      });

      it('returns a single message', () => spark.messages.get(message)
        .then((m) => {
          assert.isMessage(m);
          assert.deepEqual(m, message);
        }));
    });


    describe('#list()', () => {
      before(() => spark.rooms.create({
        title: 'Room List Test'
      })
        .then((r) => {
          room = r;
        }));

      before(() => [1, 2, 3].reduce((promise, value) => promise.then(() => spark.messages.create({
        roomId: room.id,
        text: `message: ${value}`
      })), Promise.resolve()));

      it('returns all messages for a room', () => spark.messages.list({roomId: room.id})
        .then((messages) => {
          assert.isDefined(messages);
          assert.lengthOf(messages, 3);
          for (const message of messages) {
            assert.isMessage(message);
          }
        }));

      it('returns a bounded set of messages for a room', () => {
        const spy = sinon.spy();

        return spark.messages.list({roomId: room.id, max: 2})
          .then((messages) => {
            assert.lengthOf(messages, 2);

            return (function f(page) {
              for (const message of page) {
                spy(message.id);
              }

              if (page.hasNext()) {
                return page.next().then(f);
              }

              return Promise.resolve();
            }(messages));
          })
          .then(() => {
            assert.calledThrice(spy);
          });
      });
    });
  });
});


/**
 * Validate a Message object.
 * @param {Object} message
 * @param {String} text -- optional message text to check
 * @param {Boolean} numFiles
 * @returns {void}
 */
function validateMessage(message, text = '', numFiles = 0) {
  assert.isDefined(message);
  assert.isMessage(message);
  if (text) {
    assert.equal(message.text, text);
  }
  if (numFiles) {
    assert.property(message, 'files');
    assert.isDefined(message.files);
    assert.isArray(message.files);
    assert.lengthOf(message.files, numFiles);
  }
  debug('message validated');
}

/**
 * Validate a Message event.
 * @param {Object} event - message event
 * @param {Object} message -- return from the API that generate this event
 * @param {Object} actor - person object for user who performed action
 * @returns {void}
 */
function validateMessageEvent(event, message, actor) {
  assert.isTrue(event.resource === SDK_EVENT.EXTERNAL.RESOURCE.MESSAGES,
    'not a message event');
  assert.isDefined(event.event, 'message event type not set');
  assert.isDefined(event.created, 'event listener created date not set');
  assert.equal(event.createdBy, actor.id,
    'event listener createdBy not set to our actor');
  assert.equal(event.orgId, actor.orgId,
    'event listener orgId not === to our actor\'s');
  assert.equal(event.ownedBy, 'creator', 'event listener not owned by creator');
  assert.equal(event.status, 'active', 'event listener status not active');
  assert.equal(event.actorId, actor.id,
    'event actorId not equal to our actor\'s id');

  // Ensure event data matches data returned from function call
  assert.equal(event.data.id, message.id,
    'event/message.id not equal');
  assert.equal(event.data.roomId, message.roomId,
    'event/message.roomId not equal');
  assert.equal(event.data.personId, message.personId,
    'event/message.personId not equal');
  assert.equal(event.data.personEmail, message.personEmail,
    'event/message.personEmail not equal');
  assert.equal(event.data.roomType, message.roomType,
    'event/message.roomType not equal');
  if (event.event === SDK_EVENT.EXTERNAL.EVENT_TYPE.DELETED) {
    return;
  }
  if (message.text) {
    assert.equal(event.data.text, message.text, 'event/message.text not equal');
  }
  if (message.files) {
    assert.isArray(event.data.files, 'event.data.files is not array');
    assert.isArray(message.files, 'message.files is not array');
    assert.equal(event.data.files.length, message.files.length,
      'event/message file arrays are different lengths');
    for (let i = 0; i < message.files.length; i += 1) {
      // The gateway returned by the API is apialpha.ciscospark.com
      // The gateway returned in the event is api.ciscospark.com -- expected?
      assert.equal(event.data.files[i].substr(event.data.files[i].lastIndexOf('/') + 1),
        message.files[i].substr(message.files[i].lastIndexOf('/') + 1),
        'event/message file urls do not match');
    }
  }
}

