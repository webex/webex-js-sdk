/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import '@webex/internal-plugin-encryption';
import '@webex/internal-plugin-conversation';

import {registerInternalPlugin} from '@webex/webex-core';
import {has} from 'lodash';

import EDiscovery from './ediscovery';
import Transforms from './transforms';

registerInternalPlugin('ediscovery', EDiscovery, {
  payloadTransformer: {
    predicates: [
      {
        name: 'decryptReportRequest',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.reportRequest'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'decryptReportRequestArray',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body[0].reportRequest'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'encryptReportRequest',
        direction: 'outbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.keywords') || has(object, 'body.spaceNames') || has(object, 'body.emails'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'decryptReportContent',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.activityId'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'decryptReportContentArray',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body[0].activityId'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'decryptReportContentSummary',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body.spaceId'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      },
      {
        name: 'decryptReportContentSummaryArray',
        direction: 'inbound',
        test(ctx, object) {
          return Promise.resolve(has(object, 'body[0].spaceId'));
        },
        extract(object) {
          return Promise.resolve(object);
        }
      }
    ],
    transforms: [
      {
        name: 'decryptReportRequest',
        direction: 'inbound',
        fn(ctx, object) {
          return Transforms.decryptReportRequest(ctx, object);
        }
      },
      {
        name: 'decryptReportRequestArray',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object || !object.body) {
            return Promise.resolve();
          }

          return Promise.all(object.body.map((item) => ctx.transform('decryptReportRequest', {body: item})));
        }
      },
      {
        name: 'encryptReportRequest',
        direction: 'outbound',
        fn(ctx, object) {
          return Transforms.encryptReportRequest(ctx, object);
        }
      },
      {
        name: 'decryptReportContent',
        direction: 'inbound',
        fn(ctx, object, reportId) {
          if (!object || !object.body || !reportId) {
            return Promise.resolve();
          }

          return Transforms.decryptReportContent(ctx, object, reportId);
        }
      },
      {
        name: 'decryptReportContentArray',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object || !object.body) {
            return Promise.resolve();
          }
          // the report id is needed in order to retrieve space information for activities with whiteboards so that
          // the list of users in those spaces can be accessed and the content can be decrypted on their behalf
          const reportId = object.options.resource.split('/')[1];

          return Promise.all(object.body.map((item) => ctx.transform('decryptReportContent', {body: item}, reportId)));
        }
      },
      {
        name: 'decryptReportContentSummary',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object || !object.body || !object.body.spaceName || !object.body.participants || !object.body.participants.length) {
            return Promise.resolve();
          }

          return Transforms.decryptReportContentSummary(ctx, object);
        }
      },
      {
        name: 'decryptReportContentSummaryArray',
        direction: 'inbound',
        fn(ctx, object) {
          if (!object || !object.body) {
            return Promise.resolve();
          }

          return Promise.all(object.body.map((item) => ctx.transform('decryptReportContentSummary', {body: item})));
        }
      }
    ]
  }
});

export default EDiscovery;

export {config} from './config';
export {default as ReportRequest} from './report-request';
export {EdiscoveryError, InvalidEmailAddressError} from './ediscovery-error';
