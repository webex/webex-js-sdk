import EDiscovery from '@webex/internal-plugin-ediscovery';
import MockWebex from '@webex/test-helper-mock-webex';
import sinon from 'sinon';
import {assert, expect} from '@webex/test-helper-chai';
import config from '@webex/internal-plugin-ediscovery/src/config';

/* eslint-disable max-len */
describe('EDiscovery Content API Tests', () => {
  let webex;
  const uuid = 'cc06f622-46ab-45b9-b3a6-5d70bad1d70a';
  const defaultTimeout = 30000;

  beforeEach(() => {
    webex = new MockWebex({
      children: {
        ediscovery: EDiscovery
      }
    });
    webex.config.ediscovery = config.ediscovery;
  });

  describe('GetContent Tests', () => {
    it('GetContent succeeds', async () => {
      const result = webex.internal.ediscovery.getContent(uuid, {offset: 0, size: 1})
        .then((res) => {
          expect(res.statusCode).equal(200);
        });

      return result;
    });

    it('GetContent fails with no params', async () => {
      const result = expect(webex.internal.ediscovery.getContent()).to.be.rejectedWith(Error, 'Undefined parameter');

      return result;
    });

    it('GetContent timeout defaults to 30s', async () => {
      const result = webex.internal.ediscovery.getContent(uuid)
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', defaultTimeout));
        });

      return result;
    });

    it('GetContent timeout defaults to 30s when other options are specified', async () => {
      const result = webex.internal.ediscovery.getContent(uuid, {offset: 0, size: 1})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', defaultTimeout));
        });

      return result;
    });

    it('GetContent timeout can be overwritten to 5s with timeout as the only option', async () => {
      const result = webex.internal.ediscovery.getContent(uuid, {timeoutMs: 5000})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 5000));
        });

      return result;
    });

    it('GetContent timeout can be overwritten to 5s when other options are specified', async () => {
      const result = webex.internal.ediscovery.getContent(uuid, {offset: 0, size: 1, timeoutMs: 5000})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 5000));
          sinon.assert.calledWith(webex.request, sinon.match.has('qs', {offset: 0, size: 1}));
        });

      return result;
    });
  });

  describe('GetContentSummary Tests', () => {
    it('GetContentSummary succeeds', async () => {
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1})
        .then((res) => {
          expect(res.statusCode).equal(200);
        });

      return result;
    });

    it('GetContentSummary fails with no params', async () => {
      const result = expect(webex.internal.ediscovery.getContentSummary()).to.be.rejectedWith(Error, 'Undefined parameter');

      return result;
    });

    it('GetContentSummary timeout defaults to 30s', async () => {
      const result = webex.internal.ediscovery.getContentSummary(uuid)
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', defaultTimeout));
        });

      return result;
    });

    it('GetContentSummary timeout defaults to 30s when other options are specified', async () => {
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', defaultTimeout));
        });

      return result;
    });

    it('GetContentSummary timeout can be overwritten to 5s with timeout as the only option', async () => {
      const result = webex.internal.ediscovery.getContentSummary(uuid, {timeoutMs: 5000})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 5000));
        });

      return result;
    });

    it('GetContentSummary timeout can be overwritten to 5s when other options are specified', async () => {
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1, timeoutMs: 5000})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 5000));
          sinon.assert.calledWith(webex.request, sinon.match.has('qs', {offset: 0, size: 1}));
        });

      return result;
    });

    it('GetContentSummary sets report in contentSummaryBySpaceIdCache if it does not exist', async () => {
      const mockResponse = {body: [{spaceId: uuid}]};

      webex.internal.ediscovery.request = sinon.stub().resolves(mockResponse);

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        set: sinon.stub(),
        has: sinon.stub().returns(false),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1})
        .then(() => {
          assert.calledWith(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, uuid);
          assert.calledOnce(webex.internal.ediscovery.contentSummaryBySpaceIdCache.clear);
          assert.calledWith(webex.internal.ediscovery.contentSummaryBySpaceIdCache.set, uuid, new Map());
        });

      return result;
    });

    it('GetContentSummary does not retrieves space from contentSummaryBySpaceIdCache if available', async () => {
      const mockCachedSpace = {spaceId: uuid};
      const spaceIdMap = {
        get: sinon.stub().withArgs(uuid).returns(mockCachedSpace),
        set: sinon.stub(),
        has: sinon.stub().returns(true)
      };

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        get: sinon.stub().withArgs(uuid).returns(spaceIdMap),
        set: sinon.stub(),
        has: sinon.stub().returns(true),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1})
        .then((res) => {
          expect(res).to.not.equal(mockCachedSpace);
          assert.callCount(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, 0);
          assert.callCount(spaceIdMap.has, 0);
          assert.callCount(spaceIdMap.get, 0);
        });

      return result;
    });

    it('GetContentSummary populates contentSummaryBySpaceIdCache with space when retrieved', async () => {
      const mockResponse = {body: [{spaceId: uuid}]};

      webex.internal.ediscovery.request = sinon.stub().resolves(mockResponse);

      const spaceIdMap = {
        set: sinon.stub(),
        has: sinon.stub().returns(false)
      };

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        get: sinon.stub().withArgs(uuid).returns(spaceIdMap),
        has: sinon.stub().returns(true),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummary(uuid, {offset: 0, size: 1})
        .then((res) => {
          expect(res).to.equal(mockResponse);
          assert.callCount(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, 1);
          assert.calledWith(spaceIdMap.set, mockResponse.body[0].spaceId, mockResponse.body[0]);
        });

      return result;
    });

    it('PostAuditLog with valid reportId succeeds', () => {
      webex.internal.ediscovery.postAuditLog(uuid, {timeoutMs: 1000})
        .then((res) => {
          expect(res.statusCode).equal(200);
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 1000));
        });
    });

    it('PostAuditLog with no reportId is rejected', () => {
      const noUuid = '';
      const result = expect(webex.internal.ediscovery.postAuditLog(noUuid, {timeoutMs: 1000})).to.be.rejectedWith(Error, 'No report ID specified');

      return result;
    });

    it('PostAuditLog propagates http error on failure', () => {
      webex.request = sinon.stub().returns(Promise.resolve({
        body: {},
        statusCode: 400
      }));

      webex.internal.ediscovery.postAuditLog(uuid, {timeoutMs: 1000})
        .then((res) => {
          expect(res.statusCode).equal(400);
        });
    });
  });

  describe('GetContentSummaryBySpaceId Tests', () => {
    it('GetContentSummaryBySpaceId succeeds', async () => {
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then((res) => {
          expect(res).to.not.equal(undefined);
        });

      return result;
    });

    it('GetContentSummaryBySpaceId fails with no params', async () => {
      const result = expect(webex.internal.ediscovery.getContentSummaryBySpaceId()).to.be.rejectedWith(Error, 'Undefined parameter');

      return result;
    });

    it('GetContentSummaryBySpaceId timeout defaults to 30s', async () => {
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', defaultTimeout));
        });

      return result;
    });

    it('GetContentSummaryBySpaceId timeout can be overwritten to 5s with timeout as the only option', async () => {
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid, {timeoutMs: 5000})
        .then(() => {
          sinon.assert.calledWith(webex.request, sinon.match.has('timeout', 5000));
        });

      return result;
    });

    it('GetContentSummaryBySpaceId sets report in contentSummaryBySpaceIdCache if it does not exist', async () => {
      const mockResponse = {body: {spaceId: uuid}};

      webex.internal.ediscovery.request = sinon.stub().resolves(mockResponse);

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        set: sinon.stub(),
        has: sinon.stub().returns(false),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then(() => {
          assert.calledWith(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, uuid);
          assert.calledOnce(webex.internal.ediscovery.contentSummaryBySpaceIdCache.clear);
          assert.calledWith(webex.internal.ediscovery.contentSummaryBySpaceIdCache.set, uuid, new Map());
        });

      return result;
    });

    it('GetContentSummaryBySpaceId retrieves space from contentSummaryBySpaceIdCache if available', async () => {
      const mockCachedSpace = {spaceId: uuid};

      const spaceIdMap = {
        get: sinon.stub().withArgs(uuid).returns(mockCachedSpace),
        set: sinon.stub(),
        has: sinon.stub().returns(true)
      };

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        get: sinon.stub().withArgs(uuid).returns(spaceIdMap),
        set: sinon.stub(),
        has: sinon.stub().returns(true),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then((res) => {
          expect(res.body).to.equal(mockCachedSpace);
          assert.callCount(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, 1);
          assert.callCount(spaceIdMap.has, 1);
          assert.callCount(spaceIdMap.get, 1);
        });

      return result;
    });

    it('GetContentSummaryBySpaceId populates contentSummaryBySpaceIdCache with space when retrieved', async () => {
      const mockResponse = {body: {spaceId: uuid}};

      webex.internal.ediscovery.request = sinon.stub().resolves(mockResponse);

      const spaceIdMap = {
        set: sinon.stub(),
        has: sinon.stub().returns(false)
      };

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        get: sinon.stub().withArgs(uuid).returns(spaceIdMap),
        set: sinon.stub(),
        has: sinon.stub().returns(true),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then((res) => {
          expect(res).to.equal(mockResponse);
          assert.callCount(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, 2);
          assert.callCount(spaceIdMap.has, 1);
          assert.calledWith(spaceIdMap.set, mockResponse.body.spaceId, mockResponse.body);
        });

      return result;
    });

    it('GetContentSummaryBySpaceId cannot write space to contentSummaryBySpaceIdCache without spaceId', async () => {
      const mockResponse = {body: {}};

      webex.internal.ediscovery.request = sinon.stub().resolves(mockResponse);

      const spaceIdMap = {
        set: sinon.stub(),
        has: sinon.stub().returns(false)
      };

      webex.internal.ediscovery.contentSummaryBySpaceIdCache = {
        get: sinon.stub().withArgs(uuid).returns(spaceIdMap),
        set: sinon.stub(),
        has: sinon.stub().returns(true),
        clear: sinon.stub()
      };
      const result = webex.internal.ediscovery.getContentSummaryBySpaceId(uuid, uuid)
        .then((res) => {
          expect(res).to.equal(mockResponse);
          assert.callCount(webex.internal.ediscovery.contentSummaryBySpaceIdCache.has, 2);
          assert.callCount(spaceIdMap.has, 1);
          assert.notCalled(spaceIdMap.set);
        });

      return result;
    });
  });
});
