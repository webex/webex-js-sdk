/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {
  browserOnly,
  expectNEvents,
  maxWaitForEvent
} from '@ciscospark/test-helper-mocha';
import {
  expectCallIncomingEvent,
  expectChangeActiveParticipantsCountEvent,
  expectChangeLocusEvent,
  expectChangeStateEvent,
  expectInactiveEvent,
  expectMembershipChangeEvent,
  expectMembershipConnectedEvent,
  expectMembershipDeclinedEvent,
  expectMembershipDisconnectedEvent
} from '../lib/event-expectations';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(60000);

  describe(`Phone`, () => {
    const users = {
      chekov: null,
      mccoy: null,
      spock: null,
      uhura: null
    };
    let chekov, mccoy, spock, uhura;

    before(`create users and register`, () => testUsers.create({count: Object.keys(users).length})
      .then((created) => Promise.all(Object.keys(users).map((name, index) => {
        const user = users[name] = created[index];
        user.spark = new CiscoSpark({
          credentials: {
            authorization: user.token
          }
        });

        return user.spark.phone.register();
      })))
      .then(() => {
        chekov = users.chekov;
        mccoy = users.mccoy;
        spock = users.spock;
        uhura = users.uhura;
      }));

    beforeEach(`enable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    }));

    afterEach(`disable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    }));

    after(`unregister users`, () => Promise.all(Object.keys(users).map((name) => {
      const user = users[name];
      return user && user.spark.phone.deregister()
        .catch((reason) => console.warn(`could not unregister ${user}`, reason));
    })));

    describe(`#dial()`, () => {
      let room;
      beforeEach(`create room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        }));

      beforeEach(`add mccoy to room via hydra`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `memberships`,
        body: {
          personId: mccoy.id,
          roomId: room.id
        }
      }));

      beforeEach(`refresh room details from hydra`, () => spock.spark.request({
        method: `GET`,
        service: `hydra`,
        resource: `rooms/${room.id}`
      })
        .then((res) => {
          room = res.body;
        }));

      it(`calls a room by hydra room id`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        let mccoyCall;
        assert.isUndefined(call.state);
        return Promise.all([
          Promise.resolve()
            .then(() => call.locus || expectChangeLocusEvent(call))
            .then(() => call.state === `active` || expectChangeStateEvent(call))
            .then(() => assert.equal(call.state, `active`)),
          expectCallIncomingEvent(mccoy.spark.phone)
        ])
          // eslint-disable-next-line no-unused-vars
          .then(([_, mc]) => {
            mccoyCall = mc;

            assert.isFalse(mccoyCall.isCall, `McCoy sees the Call as a MEETING`);

            assert.isDefined(mccoyCall.locus, `McCoy's call has a locus`);
            assert.equal(mccoyCall.state, `active`, `McCoy's view of the call is active`);
            return Promise.all([
              mccoyCall.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(mccoyCall),
              call.activeParticipantsCount === 2 || expectChangeActiveParticipantsCountEvent(call),
              mccoyCall.answer()
            ]);
          })
          .then(() => {
            // The find statements here are taking advantage of the fact
            // that this is, in fact, a two-party call
            assert.equal(call.memberships.find((m) => m._self).state, `connected`, `Spock sees Spock as connected`);
            assert.equal(mccoyCall.memberships.find((m) => m._self).state, `connected`, `McCoy sees McCoy as connected`);

            assert.equal(call.memberships.find((m) => !m._self).state, `connected`, `Spock sees McCoy as connected`);
            assert.equal(mccoyCall.memberships.find((m) => !m._self).state, `connected`, `McCoy sees Spock as connected`);

            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 2);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 2);
          })
          .then(() => Promise.all([
            maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
            maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
            call.hangup()
          ]))
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 1);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 1);

            assert.equal(call.state, `active`, `Spock sees the call as active after Spock leaves`);
            assert.equal(mccoyCall.state, `active`, `McCoy sees the call as active after Spock leaves`);
            return Promise.all([
              maxWaitForEvent(5000, `inactive`, call),
              maxWaitForEvent(5000, `inactive`, mccoyCall),
              mccoyCall.hangup()
            ]);
          })
          .then(() => {
            assert.lengthOf(call.memberships, 2);
            assert.equal(call.activeParticipantsCount, 0);
            assert.lengthOf(mccoyCall.memberships, 2);
            assert.equal(mccoyCall.activeParticipantsCount, 0);

            assert.equal(call.state, `inactive`, `Spock sees the call as inactive after McCoy leaves`);
            assert.equal(mccoyCall.state, `inactive`, `McCoy sees the call as inactive after McCoy leaves`);
          });
      }));

      it(`calls a room by sip uri`, () => handleErrorEvent(spock.spark.phone.dial(room.sipAddress), (call) => Promise.all([
        // Spock's view of the call
        expectMembershipConnectedEvent(call, `spock expects mccoy to connect`)
          .then(() => expectMembershipDisconnectedEvent(call, `spock expects mccoy to disconnect`))
          .then(() => Promise.all([
            call.hangup(),
            expectInactiveEvent(call, `spock expects the call to go inactive`)
          ])),

        // McCoy's view of the call
        expectCallIncomingEvent(mccoy.spark.phone, `mccoy expects an incoming call`)
          .then((mc) => Promise.all([
            expectMembershipConnectedEvent(mc, `mccoy expects his own connection event`),
            mc.answer()
          ])
            .then(() => mc.hangup()))
      ])));
    });

    describe(`group calling events model`, () => {
      let room;

      before(() => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        })
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: mccoy.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: chekov.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: uhura.id
          }
        })));

      it(`proceeds through a series of events`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        return Promise.all([
          // This execution chain represents Spock's view of the call
          Promise.resolve(call.locus || expectChangeLocusEvent(call, `spock expects to receive a locus`))
            .then(() => {
              assert.equal(call.state, `active`);
              assert.equal(call.me.state, `connected`);
              const onMembershipConnected = sinon.spy();
              call.on(`membership:connected`, onMembershipConnected);
              return Promise.all([
                expectNEvents(5000, 2, `membership:connected`, call),
                expectMembershipDeclinedEvent(call, `spock expects chekov to decline`)
                  .then((membership) => assert.equal(membership.personUuid, chekov.id))
              ])
                .then(() => {
                  call.off(`membership:connected`, onMembershipConnected);
                  assert.calledTwice(onMembershipConnected);
                  assert.calledWith(onMembershipConnected, call.memberships.find((m) => m.personUuid === mccoy.id));
                  assert.calledWith(onMembershipConnected, call.memberships.find((m) => m.personUuid === uhura.id));

                  return expectMembershipChangeEvent(call, `spock expects mccoy to mute audio`);
                })
                .then((membership) => {
                  assert.equal(membership.personUuid, mccoy.id);
                  assert.isTrue(membership.audioMuted);
                  // wait for uhura to hangup
                  assert.notEqual(call.memberships.find((m) => m.personUuid === uhura.id).state, `disconnected`);
                  return expectMembershipDisconnectedEvent(call, `spock expects uhura to hangup`)
                    .then(() => assert.equal(call.memberships.find((m) => m.personUuid === uhura.id).state, `disconnected`));
                })
                // wait for mccoy to hangup
                .then(() => expectMembershipDisconnectedEvent(call, `spock expects mccoy to hangup`))
                .then(() => {
                  assert.equal(call.me.state, `connected`);
                  assert.equal(call.memberships.find((m) => m.personUuid === mccoy.id).state, `disconnected`);
                  assert.equal(call.memberships.find((m) => m.personUuid === uhura.id).state, `disconnected`);
                  assert.equal(call.memberships.find((m) => m.personUuid === chekov.id).state, `declined`);
                  return call.hangup();
                });
            }),

          // This execution chain represents McCoy's view of the call
          expectCallIncomingEvent(mccoy.spark.phone, `mccoy expects a group call`)
            .then((mc) => {
              assert.equal(mc.state, `active`);
              assert.equal(mc.me.state, `notified`);
              return Promise.all([
                new Promise((resolve) => {
                  mc.on(`change:activeParticipantsCount`, onAPCchange);
                  function onAPCchange() {
                    if (mc.activeParticipantsCount === 3) {
                      mc.off(`change:activeParticipantsCount`, onAPCchange);
                      resolve();
                    }
                  }
                }),
                mc.answer()
              ])
                .then(() => mc.toggleSendingAudio())
                // wait for uhura to hangup
                .then(() => expectMembershipDisconnectedEvent(mc, `mccoy expects uhura to hangup`))
                .then(() => mc.hangup())
              ;
            }),

          // This execution chain represents Chekov's view of the call
          expectCallIncomingEvent(chekov.spark.phone, `chekov expects a group call`)
            .then((cc) => {
              assert.equal(cc.state, `active`);
              assert.equal(cc.me.state, `notified`);
              return cc.decline();
            }),

          // This execution chain represents Uhura's view of the call
          expectCallIncomingEvent(uhura.spark.phone, `uhura expects a group call`)
            .then((uc) => {
              assert.equal(uc.state, `active`);
              assert.equal(uc.me.state, `notified`);
              return Promise.all([
                new Promise((resolve) => {
                  uc.on(`change:activeParticipantsCount`, onAPCchange);
                  function onAPCchange() {
                    if (uc.activeParticipantsCount === 3) {
                      uc.off(`change:activeParticipantsCount`, onAPCchange);
                      resolve();
                    }
                  }
                }),
                uc.answer()
              ])
                .then(() => expectMembershipChangeEvent(uc, `uhura expects mccoy to mute`))
                .then((membership) => {
                  if (membership.personUuid !== mccoy.id) {
                    return expectMembershipChangeEvent(uc, `uhura still expects mccoy to mute`);
                  }
                  return Promise.resolve(membership);
                })
                .then((membership) => {
                  assert.equal(membership.personUuid, mccoy.id);
                  assert.isTrue(membership.audioMuted);
                  return uc.hangup();
                });
            })
        ]);
      }));
    });
  });
});
