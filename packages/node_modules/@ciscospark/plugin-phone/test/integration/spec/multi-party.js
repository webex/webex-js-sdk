/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import {handleErrorEvent} from '@ciscospark/test-helper-mocha';
import {
  browserOnly,
  expectEvent,
  expectNEvents,
  maxWaitForEvent
} from '@ciscospark/test-helper-mocha';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(60000);

  describe(`Phone`, () => {
    const users = {
      chekov: null,
      mccoy: null,
      spock: null,
      uhura: null
    };
    let chekov, mccoy, spock, uhura;

    before(`create users and register`, () => testUsers.create({count: Object.keys(users).length})
      .then((created) => Promise.all(Object.keys(users).map((name, index) => {
        const user = users[name] = created[index];
        user.spark = new CiscoSpark({
          credentials: {
            authorization: user.token
          }
        });

        return user.spark.phone.register();
      })))
      .then(() => {
        chekov = users.chekov;
        mccoy = users.mccoy;
        spock = users.spock;
        uhura = users.uhura;
      }));

    beforeEach(`enable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    }));

    afterEach(`disable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    }));

    after(`unregister users`, () => Promise.all(Object.keys(users).map((name) => {
      const user = users[name];
      return user && user.spark.phone.deregister()
        .catch((reason) => console.warn(`could not unregister ${user}`, reason));
    })));

    describe(`#dial()`, () => {
      it(`calls a room by hydra room id`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          const room = res.body;

          return spock.spark.request({
            method: `POST`,
            service: `hydra`,
            resource: `memberships`,
            body: {
              roomId: room.id,
              personId: mccoy.id
            }
          })
            .then(() => handleErrorEvent(spock.spark.phone.dial(room.id),
              (call) => {
                let mccoyCall;
                assert.isUndefined(call.state);
                return Promise.all([
                  maxWaitForEvent(5000, `change:locus`, call)
                    .then(() => {
                      assert.isDefined(call.locus);
                      return maxWaitForEvent(1000, `change:state`, call);
                    })
                    .then(() => assert.equal(call.state, `active`)),
                  mccoy.spark.phone.when(`call:incoming`)
                ])
                  // eslint-disable-next-line no-unused-vars
                  .then(([_, [mc]]) => {
                    mccoyCall = mc;

                    assert.isFalse(mccoyCall.isCall, `McCoy sees the Call as a MEETING`);

                    assert.isDefined(mccoyCall.locus, `McCoy's call has a locus`);
                    assert.equal(mccoyCall.state, `active`, `McCoy's view of the call is active`);
                    return Promise.all([
                      maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
                      maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
                      mccoyCall.answer()
                    ]);
                  })
                  .then(() => {
                    // The find statements here are taking advantage of the fact
                    // that this is, in fact, a two-party call
                    assert.equal(call.memberships.find((m) => m._self).state, `connected`, `Spock sees Spock as connected`);
                    assert.equal(mccoyCall.memberships.find((m) => m._self).state, `connected`, `McCoy sees McCoy as connected`);

                    assert.equal(call.memberships.find((m) => !m._self).state, `connected`, `Spock sees McCoy as connected`);
                    assert.equal(mccoyCall.memberships.find((m) => !m._self).state, `connected`, `McCoy sees Spock as connected`);

                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 2);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 2);
                  })
                  .then(() => Promise.all([
                    maxWaitForEvent(5000, `change:activeParticipantsCount`, mccoyCall),
                    maxWaitForEvent(5000, `change:activeParticipantsCount`, call),
                    call.hangup()
                  ]))
                  .then(() => {
                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 1);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 1);

                    assert.equal(call.state, `active`, `Spock sees the call as active after Spock leaves`);
                    assert.equal(mccoyCall.state, `active`, `McCoy sees the call as active after Spock leaves`);
                    return Promise.all([
                      maxWaitForEvent(5000, `inactive`, call),
                      maxWaitForEvent(5000, `inactive`, mccoyCall),
                      mccoyCall.hangup()
                    ]);
                  })
                  .then(() => {
                    assert.lengthOf(call.memberships, 2);
                    assert.equal(call.activeParticipantsCount, 0);
                    assert.lengthOf(mccoyCall.memberships, 2);
                    assert.equal(mccoyCall.activeParticipantsCount, 0);

                    assert.equal(call.state, `inactive`, `Spock sees the call as inactive after McCoy leaves`);
                    assert.equal(mccoyCall.state, `inactive`, `McCoy sees the call as inactive after McCoy leaves`);
                  });
              }));

        }));

      it(`calls a room by sip uri`, () => {
        let room;

        return spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `rooms`,
          body: {
            title: `Call Test`
          }
        })
          .then((res) => {
            room = res.body;
          })
          .then(() => spock.spark.request({
            method: `POST`,
            service: `hydra`,
            resource: `memberships`,
            body: {
              roomId: room.id,
              personId: mccoy.id
            }
          }))
          // We need to re-get the room because the sip uri doesn't exist at
          // creation
          .then(() => spock.spark.request({
            method: `GET`,
            service: `hydra`,
            resource: `rooms/${room.id}`
          }))
          .then((res) => {
            room = res.body;

            return handleErrorEvent(spock.spark.phone.dial(room.sipAddress), (call) => Promise.all([
              // Spock's view of the call
              expectEvent(10000, `membership:connected`, call, `spock expects mccoy to connect`)
                .then(() => expectEvent(10000, `membership:disconnected`, call, `spock expects mccoy to disconnect`))
                .then(() => Promise.all([
                  call.hangup(),
                  expectEvent(10000, `inactive`, call, `spock expects the call to go inactive`)
                ])),

              // McCoy's view of the call
              expectEvent(10000, `call:incoming`, mccoy.spark.phone, `mccoy expects an incoming call`)
                .then((mc) => Promise.all([
                  expectEvent(10000, `membership:connected`, mc, `mccoy expects his own connection event`),
                  mc.answer()
                ])
                .then(() => mc.hangup()))
            ]));
          });
      });

    });


    describe(`group calling events model`, () => {
      let room;

      before(() => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Call Test`
        }
      })
        .then((res) => {
          room = res.body;
        })
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: mccoy.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: chekov.id
          }
        }))
        .then(() => spock.spark.request({
          method: `POST`,
          service: `hydra`,
          resource: `memberships`,
          body: {
            roomId: room.id,
            personId: uhura.id
          }
        })));


      it(`proceeds through a series of events`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        return Promise.all([
          // This execution chain represents Spock's view of the call
          Promise.resolve(call.locus || expectEvent(10000, `change:locus`, call, `spock expects to receive a locus`))
            .then(() => {
              assert.equal(call.state, `active`);
              assert.equal(call.me.state, `connected`);
              const onMembershipConnected = sinon.spy();
              call.on(`membership:connected`, onMembershipConnected);
              return Promise.all([
                expectNEvents(5000, 2, `membership:connected`, call),
                expectEvent(10000, `membership:declined`, call, `spock expects chekov to decline`)
                  .then((membership) => assert.equal(membership.personUuid, chekov.id))
              ])
              .then(() => {
                call.off(`membership:connected`, onMembershipConnected);
                assert.calledTwice(onMembershipConnected);
                assert.calledWith(onMembershipConnected, call.memberships.find((m) => m.personUuid === mccoy.id));
                assert.calledWith(onMembershipConnected, call.memberships.find((m) => m.personUuid === uhura.id));

                return expectEvent(10000, `membership:change`, call, `spock expects mccoy to mute audio`);
              })
              .then((membership) => {
                assert.equal(membership.personUuid, mccoy.id);
                assert.isTrue(membership.audioMuted);
                // wait for uhura to hangup
                return expectEvent(10000, `membership:disconnected`, call, `spock expects uhura to hangup`);
              })
              // wait for mccoy to hangup
              .then(() => expectEvent(10000, `membership:disconnected`, call, `spock expects mccoy to hangup`))
              .then(() => {
                assert.equal(call.me.state, `connected`);
                assert.equal(call.memberships.find((m) => m.personUuid === mccoy.id).state, `disconnected`);
                assert.equal(call.memberships.find((m) => m.personUuid === uhura.id).state, `disconnected`);
                assert.equal(call.memberships.find((m) => m.personUuid === chekov.id).state, `declined`);
                return call.hangup();
              });
            }),

          // This execution chain represents McCoy's view of the call
          expectEvent(10000, `call:incoming`, mccoy.spark.phone, `mccoy expects a group call`)
            .then((mc) => {
              assert.equal(mc.state, `active`);
              assert.equal(mc.me.state, `notified`);
              return Promise.all([
                new Promise((resolve) => {
                  mc.on(`change:activeParticipantsCount`, onAPCchange);
                  function onAPCchange() {
                    if (mc.activeParticipantsCount === 3) {
                      mc.off(`change:activeParticipantsCount`, onAPCchange);
                      resolve();
                    }
                  }
                }),
                mc.answer()
              ])
              .then(() => mc.toggleSendingAudio())
                // wait for uhura to hangup
              .then(() => expectEvent(10000, `membership:disconnected`, mc, `mccoy expects uhura to hangup`))
              .then(() => mc.hangup())
              ;
            }),

          // This execution chain represents Chekov's view of the call
          expectEvent(10000, `call:incoming`, chekov.spark.phone, `chekov expects a group call`)
            .then((cc) => {
              assert.equal(cc.state, `active`);
              assert.equal(cc.me.state, `notified`);
              return cc.decline();
            }),

          // This execution chain represents Uhura's view of the call
          expectEvent(10000, `call:incoming`, uhura.spark.phone, `uhura expects a group call`)
            .then((uc) => {
              assert.equal(uc.state, `active`);
              assert.equal(uc.me.state, `notified`);
              return Promise.all([
                new Promise((resolve) => {
                  uc.on(`change:activeParticipantsCount`, onAPCchange);
                  function onAPCchange() {
                    if (uc.activeParticipantsCount === 3) {
                      uc.off(`change:activeParticipantsCount`, onAPCchange);
                      resolve();
                    }
                  }
                }),
                uc.answer()
              ])
                .then(() => expectEvent(10000, `membership:change`, uc, `uhura expects mccoy to mute`))
                .then((membership) => {
                  if (membership.personUuid !== mccoy.id) {
                    return expectEvent(10000, `membership:change`, uc, `uhura still expects mccoy to mute`);
                  }
                  return Promise.resolve(membership);
                })
                .then((membership) => {
                  assert.equal(membership.personUuid, mccoy.id);
                  assert.isTrue(membership.audioMuted);
                  return uc.hangup();
                });
            })
        ]);
      }));
    });
  });
});
