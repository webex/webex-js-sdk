/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {browserOnly} from '@ciscospark/test-helper-mocha';
import {remoteParticipant} from '../../..';
import {boolToStatus} from '@ciscospark/plugin-phone';
import {
  expectCallIncomingEvent,
  expectConnectedEvent,
  expectRemoteAudioMutedChangeEvent,
  expectRemoteVideoMutedChangeEvent
} from '../lib/event-expectations';

function assertLocusMediaState(call, {
  sendingAudio,
  sendingVideo,
  receivingAudio,
  receivingVideo
}) {
  assertMediaState(call, {
    sendingAudio,
    sendingVideo,
    receivingAudio,
    receivingVideo
  });
  // Locus State
  assert.equal(call.locus.self.status.audioStatus.toLowerCase(), boolToStatus(sendingAudio, receivingAudio), `Locus State`);
  assert.equal(call.locus.self.status.videoStatus.toLowerCase(), boolToStatus(sendingVideo, receivingVideo), `Locus State`);
}

function assertMediaState(call, {
  sendingAudio,
  sendingVideo,
  receivingAudio,
  receivingVideo
}) {
  // Local State
  assert.equal(call.sendingAudio, sendingAudio, `The call ${sendingAudio ? `is` : `is not`} sending audio`);
  assert.equal(call.sendingVideo, sendingVideo, `The call ${sendingVideo ? `is` : `is not`} sending video`);

  // Media State
  assert.equal(call.media.sendingAudio, sendingAudio, `The call's media layer's sendingAudio is ${sendingAudio}`);
  assert.equal(call.media.sendingVideo, sendingVideo, `The call's media layer's sendingVideo is ${sendingVideo}`);
  assert.equal(call.media.receivingAudio, receivingAudio, `The call's media layer's receivingAudio is ${receivingAudio}`);
  assert.equal(call.media.receivingVideo, receivingVideo, `The call's media layer's receivingVideo is ${receivingVideo}`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(30000);

  describe(`Call`, () => {
    describe(`Media State Controls`, () => {
      /* eslint max-statements: [0] */
      let mccoy, spock;
      // I was getting weird cross talk from sharing the same users across all
      // the tests. I think it was a latency issue on the locus or linus side
      // where not all the cloud pieces were fully aware the previous test's
      // call had ended. As such, it seems necessary to use new users for each
      // test.
      beforeEach(`create caller`, () => testUsers.create({count: 1})
        .then(([user]) => {
          spock = user;
          spock.spark = new CiscoSpark({
            credentials: {
              authorization: spock.token
            }
          });

          return spock.spark.phone.register();
        }));

      beforeEach(`create callee`, () => testUsers.create({count: 1})
        .then(([user]) => {
          mccoy = user;
          mccoy.spark = new CiscoSpark({
            credentials: {
              authorization: mccoy.token
            }
          });

          return mccoy.spark.phone.register();
        }));

      afterEach(() => mccoy && mccoy.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect mccoy from mercury`, reason)));

      afterEach(() => spock && spock.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect spock from mercury`, reason)));

      // For quite awhile, locus didn't actually allow send-only audio. This
      // test is here as a sanity check for all the other tests that may put us
      // in that state
      it(`starts a send-only call`, () => handleErrorEvent(spock.spark.phone.dial(mccoy.email, {
        constraints: {
          audio: true,
          video: true
        },
        offerOptions: {
          offerToReceiveAudio: false,
          offerToReceiveVideo: false
        }
      }), (call) => Promise.all([
        expectCallIncomingEvent(mccoy.spark.phone)
          .then((c) => handleErrorEvent(c, () => c.answer())),
        expectConnectedEvent(call)
          .then(() => assertLocusMediaState(call, {
            sendingAudio: true,
            sendingVideo: true,
            receivingAudio: false,
            receivingVideo: false
          }))
      ])));

      describe(`#toggleReceivingAudio()`, () => {
        describe(`when the call is started with audio`, () => {
          it(`stops receiving audio and starts receiving audio`, () => {
            const call = spock.spark.phone.dial(mccoy.email);
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => handleErrorEvent(c, () => c.answer())),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                // .then(() => console.log(`TOGGLING FOR FIRST TIME`))
                .then(() => call.toggleReceivingAudio())
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
                .then(() => call.toggleReceivingAudio()))
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
            ]);
          });
        });

        describe(`when the call is started without audio`, () => {
          it(`starts receiving audio and stops receiving audio`, () => {
            const call = spock.spark.phone.dial(mccoy.email, {
              constraints: {
                audio: false,
                video: true
              }
            });
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => handleErrorEvent(c, () => c.answer())),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
                // .then(() => console.log(`TOGGLING FOR FIRST TIME`))
                .then(() => call.toggleReceivingAudio())
                .then(() => assertMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                // .then(() => console.log(`TOGGLING FOR SECOND TIME`))
                .then(() => call.toggleReceivingAudio()))
                .then(() => assertMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
            ]);
          });
        });
      });

      describe(`#toggleReceivingVideo()`, () => {
        describe(`when the call is started with video`, () => {
          it(`stops receiving video and starts receiving video`, () => {
            const call = spock.spark.phone.dial(mccoy.email);
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => handleErrorEvent(c, () => c.answer())),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                // .then(() => console.log(`TOGGLING FOR FIRST TIME`))
                .then(() => call.toggleReceivingVideo())
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                // .then(() => console.log(`TOGGLING FOR SECOND TIME`))
                .then(() => call.toggleReceivingVideo()))
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
            ]);
          });
        });

        describe(`when the call is started without video`, () => {
          it(`starts receiving video and stops receiving video`, () => {
            const call = spock.spark.phone.dial(mccoy.email, {
              constraints: {
                audio: true,
                video: false
              }
            });
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => handleErrorEvent(c, () => c.answer())),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                .then(() => call.toggleReceivingVideo())
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => call.toggleReceivingVideo()))
                .then(() => assertMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
            ]);
          });
        });
      });

      describe(`#toggleSendingAudio()`, () => {
        describe(`when the call is started with audio`, () => {
          it(`stops sending audio then starts sending audio`, () => {
            const call = spock.spark.phone.dial(mccoy.email);
            let mccoyCall;
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => {
                  mccoyCall = c;
                  return handleErrorEvent(c, () => c.answer());
                }),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => Promise.all([
                  expectRemoteAudioMutedChangeEvent(mccoyCall),
                  call.toggleSendingAudio()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(false, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, true));
                })
                .then(() => Promise.all([
                  expectRemoteAudioMutedChangeEvent(mccoyCall),
                  call.toggleSendingAudio()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, true));
                }))
            ]);
          });
        });

        describe(`when the call is started without audio`, () => {
          it(`starts sending audio and stops sending audio`, () => {
            const call = spock.spark.phone.dial(mccoy.email, {
              constraints: {
                audio: false,
                video: true
              }
            });
            let mccoyCall;
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => {
                  mccoyCall = c;
                  return handleErrorEvent(c, () => c.answer());
                }),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
                .then(() => Promise.all([
                  expectRemoteAudioMutedChangeEvent(mccoyCall),
                  call.toggleSendingAudio()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, false));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, true));
                })
                .then(() => Promise.all([
                  expectRemoteAudioMutedChangeEvent(mccoyCall),
                  call.toggleSendingAudio()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: false,
                  sendingVideo: true,
                  receivingAudio: false,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(false, false));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, true));
                }))
            ]);
          });
        });
      });

      describe(`#toggleSendingVideo()`, () => {
        describe(`when the call is started with video`, () => {
          it(`stops sending video then starts sending video`, () => {
            const call = spock.spark.phone.dial(mccoy.email);
            let mccoyCall;
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => {
                  mccoyCall = c;
                  return handleErrorEvent(c, () => c.answer());
                }),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => Promise.all([
                  expectRemoteVideoMutedChangeEvent(mccoyCall),
                  call.toggleSendingVideo()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(false, true));
                })
                .then(() => Promise.all([
                  expectRemoteVideoMutedChangeEvent(mccoyCall),
                  call.toggleSendingVideo()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, true));
                }))
            ]);
          });
        });

        describe(`when the call is started without video`, () => {
          it(`starts sending video and stops sending video`, () => {
            const call = spock.spark.phone.dial(mccoy.email, {
              constraints: {
                audio: true,
                video: false
              }
            });
            let mccoyCall;
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => {
                  mccoyCall = c;
                  return handleErrorEvent(c, () => c.answer());
                }),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                .then(() => Promise.all([
                  expectRemoteVideoMutedChangeEvent(mccoyCall),
                  call.toggleSendingVideo()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, false));
                })
                .then(() => Promise.all([
                  expectRemoteVideoMutedChangeEvent(mccoyCall),
                  call.toggleSendingVideo()
                ]))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(false, false));
                }))
            ]);
          });
        });
      });

      describe(`toggle both`, () => {
        describe(`when the call starts as an audio only call`, () => {
          // TODO [SSDK-576]
          it.skip(`adds video to the call`, () => {
            const call = spock.spark.phone.dial(mccoy.email, {
              constraints: {
                audio: true,
                video: false
              }
            });
            let mccoyCall;
            sinon.spy(spock.spark.internal.locus, `updateMedia`);
            return Promise.all([
              expectCallIncomingEvent(mccoy.spark.phone)
                .then((c) => {
                  mccoyCall = c;
                  return handleErrorEvent(c, () => c.answer());
                }),
              handleErrorEvent(call, () => expectConnectedEvent(call)
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
                .then(() => Promise.all([
                  call.toggleSendingVideo(),
                  call.toggleReceivingVideo()
                ]))
                // .then(() => assert.calledTwice(spock.spark.internal.locus.updateMedia))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: true,
                  receivingAudio: true,
                  receivingVideo: true
                }))
                .then(() => {
                  assert.equal(remoteParticipant(mccoyCall.locus).status.audioStatus.toLowerCase(), boolToStatus(true, true));
                  assert.equal(remoteParticipant(mccoyCall.locus).status.videoStatus.toLowerCase(), boolToStatus(true, false));
                  return Promise.all([
                    call.toggleSendingVideo(),
                    call.toggleReceivingVideo()
                  ]);
                }))
                // two from the initial toggling, once to send the mute flag,
                // once to remove the video section
                // .then(() => assert.calledTwice(spock.spark.internal.locus.updateMedia))
                .then(() => assertLocusMediaState(call, {
                  sendingAudio: true,
                  sendingVideo: false,
                  receivingAudio: true,
                  receivingVideo: false
                }))
            ]);
          });
        });
      });
    });
  });
});
