/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {Call} from '@ciscospark/plugin-phone';
import sinon from '@ciscospark/test-helper-sinon';
import {maxWaitForPromise} from '@ciscospark/test-helper-mocha';

beforeEach(() => {
  sinon.spy(Call, `make`);
});

afterEach(`end all calls`, function() {
  if (!Call.make.restore) {
    return Promise.resolve();
  }
  console.log(`ending all calls started by this test`);
  this.timeout(30000);
  const promises = Call.make.returnValues && Call.make.returnValues.map((c) => {
    console.log(`ending call ${c.internalCallId}`);
    if (c.spark.canAuthorize && c.spark.internal.device.url) {
      return maxWaitForPromise(2000, c.hangup())
        .then(() => console.log(`ended call ${c.internalCallId}`))
        .catch((reason) => console.warn(reason.toString()));
    }

    console.log(`can't end call ${c.internalCallId}, so attempting to brick it`);
    return c._finish();

  });

  Call.make.restore();

  return maxWaitForPromise(15000, Promise.all(promises))
    .then(() => console.log(`done ending calls`))
    .catch((reason) => console.warn(reason.stack || reason.toString()));
});
