/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-user';
import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {browserOnly, expectEvent, maxWaitForEvent} from '@ciscospark/test-helper-mocha';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(60000);

  describe(`Phone`, () => {
    let mccoy, spock;
    before(`create users and register`, () => testUsers.create({count: 2})
      .then((users) => {
        [mccoy, spock] = users;
        spock.spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });
        return Promise.all([
          spock.spark.phone.register(),
          mccoy.spark.phone.register()
        ]);
      }));

    let ringMccoy;
    beforeEach(() => {
      ringMccoy = sinon.spy();
      mccoy.spark.phone.on(`call:incoming`, ringMccoy);
    });

    after(`unregister spock and mccoy`, () => Promise.all([
      spock && spock.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect spock from mercury`, reason)),
      mccoy && mccoy.spark.phone.deregister()
        .catch((reason) => console.warn(`could not disconnect mccoy from mercury`, reason))
    ]));

    describe(`#createLocalMediaStream()`, () => {
      it(`returns a MediaStreamObject`, () => {
        return spock.spark.phone.createLocalMediaStream()
          .then((stream) => {
            assert.instanceOf(stream, MediaStream);
          });
      });
    });

    describe(`#deregister()`, () => {
      let mercuryDisconnectSpy;
      beforeEach(() => {
        mercuryDisconnectSpy = sinon.spy(spock.spark.internal.mercury, `disconnect`);
      });

      afterEach(() => mercuryDisconnectSpy.restore());

      it(`disconnects from mercury`, () => {
        return spock.spark.phone.deregister()
          .then(() => assert.calledOnce(mercuryDisconnectSpy))
          .then(() => assert.isFalse(spock.spark.internal.mercury.connected, `Mercury is not connected`))
          .then(() => assert.isFalse(spock.spark.phone.connected, `Mercury (proxied through spark.phone) is not connected`))
          .then(() => mercuryDisconnectSpy.restore());
      });

      it(`unregisters from wdm`, () => spock.spark.phone.deregister()
        .then(() => assert.isUndefined(spock.spark.internal.device.url))
        .then(() => spock.spark.phone.register()));

      it(`is a noop when not registered`, () => spock.spark.phone.deregister()
        .then(() => spock.spark.phone.deregister())
        .then(() => spock.spark.phone.register()));
    });

    describe(`#dial()`, () => {
      it(`initiates a video-only call`, () => {
        const call = spock.spark.phone.dial(mccoy.email, {
          constraints: {
            video: true,
            audio: false
          }
        });

        return handleErrorEvent(call, () => mccoy.spark.phone.when(`call:incoming`)
          .then(() => maxWaitForEvent(10000, `connected`, call))
          .then(() => {
            assert.isFalse(call.sendingAudio);
            assert.isTrue(call.sendingVideo);
            assert.isFalse(call.receivingAudio);
            assert.isTrue(call.receivingVideo);
          }));
      });

      it(`initiates an audio-only call`, () => {
        const call = spock.spark.phone.dial(mccoy.email, {
          constraints: {
            video: false,
            audio: true
          }
        });

        return handleErrorEvent(call, () => mccoy.spark.phone.when(`call:incoming`)
          .then(() => maxWaitForEvent(10000, `connected`, call))
          .then(() => {
            assert.isTrue(call.sendingAudio);
            assert.isFalse(call.sendingVideo);
            assert.isTrue(call.receivingAudio);
            assert.isFalse(call.receivingVideo);
          }));
      });

      it(`initiates a receive-only call`, () => {
        const call = spock.spark.phone.dial(mccoy.email, {
          constraints: {
            video: false,
            audio: false
          },
          offerOptions: {
            offerToReceiveAudio: true,
            offerToReceiveVideo: true
          }
        });

        return handleErrorEvent(call, () => mccoy.spark.phone.when(`call:incoming`)
          .then(() => maxWaitForEvent(10000, `connected`, call))
          .then(() => {
            assert.isFalse(call.sendingAudio);
            assert.isFalse(call.sendingVideo);
            assert.isTrue(call.receivingAudio);
            assert.isTrue(call.receivingVideo);
          }));
      });

      it(`calls a user by email address`, () => {
        let mccoyCall;
        return handleErrorEvent(spock.spark.phone.dial(mccoy.email), (call) => Promise.all([
          call.when(`connected`)
            .then(() => {
              assert.isDefined(call.correlationId);
              assert.equal(call.locus.self.devices[0].correlationId, call.correlationId);
            }),
          mccoy.spark.phone.when(`call:incoming`)
            .then(([c]) => {
              mccoyCall = c;
              return c.answer()
                .then(() => {
                  assert.equal(mccoyCall.locus.self.devices[0].correlationId, mccoyCall.correlationId);
                  assert.isDefined(mccoyCall.correlationId);
                });
            })
        ]));
      });

      // TODO [SSDK-574]
      it(`calls a user by AppID username`);

      // TODO [SSDK-507] currently timing out because the PSTN participant is
      // showing up as inactive
      it.skip(`calls a PSTN phone number`, () => {
        const call = spock.spark.phone.dial(`3175276955`);
        return handleErrorEvent(call, () => call.when(`connected`)
          .then(() => call.hangup()));
      });

      it(`calls a user by hydra user id`, () => mccoy.spark.request({
        method: `GET`,
        service: `hydra`,
        resource: `people/me`
      })
        .then((res) => handleErrorEvent(spock.spark.phone.dial(res.body.id),
          (call) => mccoy.spark.phone.when(`call:incoming`)
            .then(() => call.hangup()))));

      it(`calls a user by uuid`, () => handleErrorEvent(spock.spark.phone.dial(mccoy.id),
        (call) => {
          return mccoy.spark.phone.when(`call:incoming`)
            .then(() => {
              assert.isDefined(call.media.localMediaStream, `call.media.localMediaStream is defined`);
              assert.isDefined(call.localMediaStream, `call.localMediaStream is defined`);
            })
            .then(() => call.hangup());
        }));

      // Note: This does not actually use sip to make the connection, but
      // determines who the user is from their sip address and then places a 1:1
      // space call
      it(`calls a user by sip uri`, () => mccoy.spark.internal.user.get()
        .then((mu) => {
          assert.property(mu, `sipAddresses`, `McCoy's user object contains a sip address array`);
          assert.isAbove(mu.sipAddresses.length, 0, `McCoy's user object contains one or more sip addresses`);

          return handleErrorEvent(spock.spark.phone.dial(mu.sipAddresses[0].value), (call) => Promise.all([
            // Spock's view of the call
            expectEvent(10000, `membership:connected`, call)
              .then(() => Promise.all([
                expectEvent(10000, `membership:disconnected`, call),
                expectEvent(10000, `disconnected`, call)
              ])),

            // McCoy's view of the call
            mccoy.spark.phone.when(`call:incoming`)
              .then(([mc]) => Promise.all([
                expectEvent(10000, `membership:connected`, mc),
                mc.answer()
              ])
                .then(() => mc.hangup()))
          ]));
        }));

      it(`places a call with an existing MediaStreamObject`, () => spock.spark.phone.createLocalMediaStream()
        .then((localMediaStream) => handleErrorEvent(spock.spark.phone.dial(mccoy.email, {localMediaStream}),
          (call) => Promise.all([
            mccoy.spark.phone.when(`call:incoming`)
              .then(([c]) => {
                assert.isDefined(call.media.localMediaStream, `call.media.localMediaStream is defined`);
                assert.isDefined(call.localMediaStream, `call.localMediaStream is defined`);
                return c.answer();
              }),
            call.when(`connected`)
              .then(() => {
                assert.equal(call.status, `connected`);
                assert.isDefined(call.media.localMediaStream, `call.media.localMediaStream is defined`);
                assert.isDefined(call.localMediaStream, `call.localMediaStream is defined`);
              })
          ]))));
    });

    describe(`#register()`, () => {
      let kirk;
      beforeEach(() => testUsers.create({count: 1})
        .then(([user]) => {
          kirk = user;
          kirk.spark = new CiscoSpark({
            credentials: {
              authorization: kirk.token
            }
          });
        }));

      afterEach(`unregister kirk`, () => kirk && kirk.spark.phone.deregister());

      it(`registers with wdm`, () => {
        const spy = sinon.spy();
        kirk.spark.phone.on(`change:registered`, spy);
        return kirk.spark.phone.register()
          .then(() => {
            assert.isDefined(kirk.spark.internal.device.url);
            assert.called(spy);
          });
      });

      it(`connects to mercury`, () => {
        assert.isFalse(kirk.spark.internal.mercury.connected, `Mercury is not connected`);
        assert.isFalse(kirk.spark.phone.connected, `Mercury (proxied through spark.phone) is not conneted`);
        const spy = sinon.spy();
        kirk.spark.phone.on(`change:connected`, spy);
        return kirk.spark.phone.register()
          .then(() => {
            assert.isTrue(kirk.spark.internal.mercury.connected, `Mercury is connected after calling register`);
            assert.isTrue(kirk.spark.phone.connected, `spark.phone.connected proxies to spark.internal.mercury.connected`);
            assert.called(spy);
          });
      });

      let call;
      afterEach(`end current call`, () => Promise.resolve(call && call.hangup()
        .catch((reason) => console.warn(`failed to end call`, reason))
        .then(() => {call = undefined;})));

      it(`fetches active calls`, () => {
        call = spock.spark.phone.dial(kirk.email);
        // use change:locus as the trigger for determining when the post to
        // /call completes.
        return handleErrorEvent(call, () => call.when(`change:locus`)
          .then(() => {
            assert.isFalse(kirk.spark.phone.registered);
            kirk.spark.phone.register();
            return kirk.spark.phone.when(`call:incoming`)
              .then(() => assert.isTrue(kirk.spark.phone.registered, `By the time spark.phone can emit call:incoming, spark.phone.registered must be true`));
          }));
      });

      it(`is a noop when already registered`, () => spock.spark.phone.register());
    });

    describe(`when a call is received`, () => {
      it(`emits a call:incoming event`, () => {
        spock.spark.phone.dial(mccoy.email);
        return mccoy.spark.phone.when(`call:incoming`)
          .then(() => assert.calledOnce(ringMccoy));
      });
    });
  });
});
