/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/plugin-phone';

import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import handleErrorEvent from '../lib/handle-error-event';
import {browserOnly} from '@ciscospark/test-helper-mocha';
import {
  expectCallIncomingEvent,
  expectChangeLocusEvent,
  expectMembershipChangeEvent,
  expectMembershipConnectedEvent,
  expectMembershipDisconnectedEvent
} from '../lib/event-expectations';

if (process.env.NODE_ENV !== `test`) {
  throw new Error(`Cannot run the plugin-phone test suite without NODE_ENV === "test"`);
}

browserOnly(describe)(`plugin-phone`, function() {
  this.timeout(60000);

  describe(`Phone`, () => {
    const users = {
      chekov: null,
      mccoy: null,
      kirk: null,
      scotty: null,
      spock: null,
      uhura: null
    };
    let mccoy, spock;

    before(`create users`, () => testUsers.create({count: Object.keys(users).length})
      .then((created) => Object.keys(users).forEach((name, index) => {
        const user = users[name] = created[index];
        user.spark = new CiscoSpark({
          credentials: {
            authorization: user.token
          }
        });
      }))
      .then(() => {
        mccoy = users.mccoy;
        spock = users.spock;
      }));

    before(`register users with spark`, () => Promise.all([spock, mccoy].map((user) => user.spark.phone.register())));

    before(`set toggles`, () => spock.spark.internal.feature.setFeature(`developer`, `locus-delta-event`, true));

    beforeEach(`enable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = true;
    }));

    afterEach(`disable group calling`, () => Object.values(users).forEach((user) => {
      user.spark.config.phone.enableExperimentalGroupCallingSupport = false;
    }));

    after(`unregister users`, () => Promise.all(Object.keys(users).map((name) => {
      const user = users[name];
      return user && user.spark && user.spark.phone.deregister()
        .catch((reason) => console.warn(`could not unregister ${user}`, reason));
    })));

    describe(`delta events`, () => {

      let room;
      before(`create 5 member room`, () => spock.spark.request({
        method: `POST`,
        service: `hydra`,
        resource: `rooms`,
        body: {
          title: `Delta Event Test`
        }
      })
        .then((res) => {
          room = res.body;
          return Promise.all(Object.values(users).map((user) => user !== spock && spock.spark.request({
            method: `POST`,
            service: `hydra`,
            resource: `memberships`,
            body: {
              roomId: room.id,
              personId: user.id
            }
          })));
        }));

      it(`proceeds through a series of events`, () => handleErrorEvent(spock.spark.phone.dial(room.id), (call) => {
        const onMembershipConnected = sinon.spy();
        call.on(`membership:connected`, onMembershipConnected);

        const spockDelta = sinon.spy();

        spock.spark.internal.mercury.on(`event:locus.difference`, spockDelta);

        return Promise.all([
          // This execution chain represents Spock's view of the call
          Promise.resolve(call.locus || expectChangeLocusEvent(call, `spock expects to receive a locus`))
            .then(() => {
              assert.equal(call.state, `active`);
              assert.equal(call.me.state, `connected`);
              const onMembershipConnected = sinon.spy();
              call.on(`membership:connected`, onMembershipConnected);
              return expectMembershipConnectedEvent(call, `spock expects mccoy to answer`);
            })
            .then(() => {
              call.off(`membership:connected`, onMembershipConnected);
              assert.calledOnce(onMembershipConnected);
              assert.calledWith(onMembershipConnected, call.memberships.find((m) => m.personUuid === mccoy.id));

              return expectMembershipChangeEvent(call, `spock expects mccoy to mute audio`);
            })
            .then((membership) => {
              assert.equal(membership.personUuid, mccoy.id);
              assert.isTrue(membership.audioMuted);
            })
            // wait for mccoy to hangup
            .then(() => expectMembershipDisconnectedEvent(call, `spock expects mccoy to hangup`))
            .then(() => {
              assert.equal(call.me.state, `connected`);
              assert.equal(call.memberships.find((m) => m.personUuid === mccoy.id).state, `disconnected`);
              return call.hangup();
            }),


          // This execution chain represents McCoy's view of the call
          expectCallIncomingEvent(mccoy.spark.phone)
            .then((mc) => {
              assert.equal(mc.state, `active`);
              assert.equal(mc.me.state, `notified`);
              return Promise.all([
                new Promise((resolve) => {
                  mc.on(`change:activeParticipantsCount`, onAPCchange);
                  function onAPCchange() {
                    if (mc.activeParticipantsCount === 2) {
                      mc.off(`change:activeParticipantsCount`, onAPCchange);
                      resolve();
                    }
                  }
                }),
                mc.answer()
              ])
                .then(() => mc.toggleSendingAudio())
                .then(() => mc.hangup())
              ;
            })
        ])
          .then(() => {
            assert.called(spockDelta);
          });
      }));

    });

  });
});
