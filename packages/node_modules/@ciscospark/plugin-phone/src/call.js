/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

import {SparkPlugin} from '@ciscospark/spark-core';
import {
  base64,
  oneFlight,
  retry,
  tap,
  whileInFlight
} from '@ciscospark/common';
import {
  USE_INCOMING,
  FETCH
} from '@ciscospark/internal-plugin-locus';
import WebRTCMediaEngine from '@ciscospark/media-engine-webrtc';
import {debounce, defaults, find, get} from 'lodash';
import {
  getState,
  getStatus,
  isCall,
  activeParticipants,
  direction,
  isActive,
  joinedOnThisDevice,
  makeInternalCallId,
  participantsToCallMemberships
} from './state-parsers';
import boolToStatus from './bool-to-status';

import CallMemberships from './call-memberships';
import uuid from 'uuid';

import {parse} from 'sdp-transform';


/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @protected
 * @returns {string}
 */
function getMediaDirectionFromSDP(kind, sdp) {
  if (typeof sdp === `string`) {
    sdp = parse(sdp);
  }

  const media = sdp.media.find((m) => m.type === kind);
  if (!media || !media.direction) {
    return `inactive`;
  }

  return media.direction;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} dir
 * @protected
 * @returns {string}
 */
function reverseMediaDirection(dir) {
  switch (dir) {
    case `inactive`:
    case `sendrecv`:
      return dir;
    case `sendonly`:
      return `recvonly`;
    case `recvonly`:
      return `sendonly`;
    default:
      throw new Error(`direction "${dir}" is not valid`);
  }
}

/**
 * Helper for detmerming what mute value toggles to send to locus.
 * @private
 *
 * @param {string} kind
 * @param {string} offer
 * @param {string} answer
 * @returns {boolean}
 */
function didChange(kind, offer, answer) {
  const o = parse(offer).media.find((m) => m.type === kind);
  const a = parse(answer).media.find((m) => m.type === kind);

  if (!o && !a) {
    return false;
  }

  if (!o && a.direction.includes(`send`)) {
    return true;
  }

  if (!a && o.direction.includes(`send`)) {
    return true;
  }

  if (o.direction === a.direction) {
    return false;
  }

  if (o.direction.includes(`send`) && a.direction.includes(`send`) || !o.direction.includes(`send`) && !a.direction.includes(`send`)) {
    return false;
  }
  return true;
}

const capitalize = {
  audio: `Audio`,
  video: `Video`
};

/**
 * @event ringing
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.membership:notified}
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.active}
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 * @deprecated with {@link config.phone.enableExperimentalGroupCallingSupport} enabled;
 * instead, listen for {@link Call.inactive}
 */

/**
 * @event active
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event initializing
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event inactive
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event terminating
 * @instance
 * @memberof Call
 * only emitted if enableExperimentalGroupCallingSupport is enabled
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * @event membership:notified
 * @instance
 * @memberof Call
 * @type {CallMembership}
 * This replaces the {@link Call.ringing} event, but note that it's subtly
 * different. {@link Call.ringing} is emitted when the remote party calls
 * {@link Call#acknowledge()} whereas {@link Call.membership:notified} emits
 * shortly after (but as a direct result of) locally calling
 * {@link Phone#dial()}
 */

/**
 * @event membership:connected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:declined
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:disconnected
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:waiting
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event membership:change
 * @instance
 * @memberof Call
 * @type {CallMembership}
 */

/**
 * @event memberships:add
 * @instance
 * @memberof Call
 * Emitted when a new {@link CallMembership} is added to
 * {@link Call#memberships}. Note that {@link CallMembership#state} still needs
 * to be read to determine if the instance represents someone actively
 * participating the call.
 */

/**
 * @event memberships:remove
 * @instance
 * @memberof Call
 * Emitted when a {@link CallMembership} is removed from {@link Call#memberships}.
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} FeedbackObject
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 */
const Call = SparkPlugin.extend({
  namespace: `Phone`,

  children: {
    media: WebRTCMediaEngine
  },

  collections: {
    /**
     * @instance
     * @memberof Call
     * @type CallMemberships
     */
    memberships: CallMemberships
  },

  session: {
    activeParticipantsCount: {
      default: 0,
      required: true,
      type: `number`
    },
    /**
     * Indicates if the other party in the call has turned off their microphone.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteAudioMuted: {
      default: false,
      required: false,
      type: `boolean`
    },

    /**
     * Indicates if the other party in the call has turned off their camera.
     * `undefined` for multiparty calls
     * @instance
     * @memberof Call
     * @readonly
     * @type {boolean}
     */
    remoteVideoMuted: {
      default: false,
      required: false,
      type: `boolean`
    },

    correlationId: `string`,
    /**
     * @instance
     * @memberof Call
     * @readonly
     * @type {string}
     */
    facingMode: {
      type: `string`,
      values: [`user`, `environment`]
    },
    /**
     * Derived from locus.id and locus.fullState.lastActive. Not actually a
     * "derived" property because it shouldn't be reset in event a locus
     * replacement. Marked as private because this isn't necessarily the callId
     * that we'll eventually expose as a first-class feature.
     * @instance
     * @memberof Call
     * @private
     * @readonly
     * @type {string}
     */
    internalCallId: {
      setOnce: true,
      type: `string`
    },
    locus: `object`,
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: `object`,

    locusJoinInFlight: {
      default: false,
      type: `boolean`
    },
    locusLeaveInFlight: {
      default: false,
      type: `boolean`
    },
    /**
     * Test helper. Shortcut to the current user's membership object. not
     * official for now, but may get published at some point
     * @instance
     * @memberof Call
     * @private
     * @type {CallMembership}
     */
    me: {
      type: `object`
    }
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: [`locus`],
      fn() {
        return get(this, `locus.url`);
      }
    },
    isActive: {
      deps: [`locus`],
      fn() {
        return !!(this.locus && isActive(this.locus));
      }
    },
    joinedOnThisDevice: {
      deps: [`locus`],
      default: false,
      fn() {
        return !!(this.locus && joinedOnThisDevice(this.spark, this.locus));
      }
    },
    locusUrl: {
      deps: [`locus`],
      fn() {
        return get(this, `locus.url`);
      }
    },
    device: {
      deps: [`locus`],
      fn() {
        return this.locus.self && this.locus.self.devices.find((item) => item.url === this.spark.internal.device.url);
      }
    },
    mediaConnection: {
      deps: [`locus`],
      fn() {
        const device = this.locus.self && this.locus.self.devices.find((item) => item.url === this.spark.internal.device.url);
        return get(device, `mediaConnections[0]`);
      }
    },
    mediaId: {
      deps: [`locus`],
      fn() {
        const device = this.locus.self && this.locus.self.devices.find((item) => item.url === this.spark.internal.device.url);
        return get(device, `mediaConnections[0].mediaId`);
      }
    },
    /**
     * The other participant in a two-party call. `undefined` for multiparty
     * calls
     * @instance
     * @memberof Call
     * @readyonly
     * @type {CallMembership}
     */
    remoteMember: {
      deps: [
        `memberships`,
        `locus`
      ],
      fn() {
        if (isCall(this.locus)) {
          return this.memberships.find((m) => !m._self);
        }

        return undefined;
      }
    },
    direction: {
      deps: [`locus`],
      fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return `out`;
        }
        return direction(this.locus);
      }
    },
    from: {
      deps: [
        `memberships`
      ],
      fn() {
        if (this.isCall) {
          return this.memberships.find((m) => m.isInitiator);
        }
        return undefined;
      }
    },
    to: {
      deps: [
        `memberships`
      ],
      fn() {
        if (this.isCall) {
          return this.memberships.find((m) => !m.isInitiator);
        }
        return undefined;
      }
    },
    /**
     * <b>active</b> - At least one person (not necessarily this user) is
     * participating in the call<br/>
     * <b>inactive</b> - No one is participating in the call<br/>
     * <b>initializing</b> - reserved for future use<br/>
     * <b>terminating</b> - reserved for future use<br/>
     * Only defined if
     * {@link config.phone.enableExperimentalGroupCallingSupport} has been
     * enabled
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    state: {
      deps: [
        `locus`
      ],
      fn() {
        if (this.config.enableExperimentalGroupCallingSupport) {
          return getState(this.locus);
        }

        return undefined;
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet
     * accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * <b>replaced</b> - In (hopefully) rare cases, the underlying data backing
     * a Call instance may change in such a way that further interaction with
     * that Call is handled by a different instance. In such cases, the first
     * Call's status, will transition to `replaced`, which is almost the same
     * state as `disconnected`. Generally speaking, such a transition should not
     * happen for a Call instance that is actively sending/receiving media.
     * @deprecated The {@link Call#status} attribute will likely be replaced by
     * the {@link Call#state}.
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: [
        `locus`
      ],
      fn() {
        return getStatus(this.spark, this.locus, this.previousAttributes().locus);
      }
    },
    /**
     * Access to the remote party’s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: [`media.remoteMediaStream`],
      fn() {
        return this.media.remoteMediaStream;
      }
    },
    receivingAudio: {
      deps: [`media.receivingAudio`],
      fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: [`media.receivingVideo`],
      fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: [`media.sendingAudio`],
      fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: [`media.sendingVideo`],
      fn() {
        return this.media.sendingVideo;
      }
    },
    isCall: {
      deps: [`locus`],
      fn() {
        return isCall(this.locus);
      }
    },
    supportsDtmf: {
      deps: [`locus`],
      fn() {
        return get(this, `locus.self.enableDTMF`);
      }
    }
  },

  @oneFlight
  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge() {
    this.logger.info(`call: acknowledging`);
    return this.spark.internal.locus.alert(this.locus)
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this.logger.info(`call: acknowledged`)));
  },

  @oneFlight
  @whileInFlight(`locusJoinInFlight`)
  // Note: the `whileInFlight` decorator screws up name inferrence, so we need
  // to include @name below.
  /**
   * Answers an incoming call.
   * @instance
   * @name answer
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer(options) {
    this.logger.info(`call: answering`);
    if (!this.locus) {
      this.logger.info(`call: no locus provided, answer() is a noop`);
      return Promise.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    // this.media.pc.remoteDescription.sdp is a temporary proxy for
    // pc.connectionState until chrome catches up to the spec
    if (this.joinedOnThisDevice && this.media.pc.remoteDescription && this.media.pc.remoteDescription.sdp) {
      this.logger.info(`call: already joined on this device`);
      return Promise.resolve();
    }
    return this._join(`join`, this.locus, options)
      .then(tap(() => this.logger.info(`call: answered`)));
  },

  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline() {
    return this.reject();
  },

  @oneFlight
  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial(invitee, options) {
    this.locusJoinInFlight = true;
    this.logger.info(`call: dialing`);

    let locusMethodName = `create`;

    if (base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      const parsed = base64.decode(invitee).split(`/`);
      const resourceType = parsed[3];
      const id = parsed[4];
      if (resourceType === `PEOPLE`) {
        invitee = id;
      }

      if (resourceType === `ROOM`) {
        if (!get(this, `config.enableExperimentalGroupCallingSupport`)) {
          throw new Error(`Group calling is not enabled. Please enable config.phone.enableExperimentalGroupCallingSupport`);
        }

        locusMethodName = `join`;
        invitee = {
          url: `${this.spark.internal.device.services.conversationServiceUrl}/conversations/${id}/locus`
        };
      }
    }

    // Note: mercury.connect() will call device.register() if needed. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.internal.mercury.connect()
      .then(() => this._join(locusMethodName, invitee, options))
      .then(tap(() => this.logger.info(`call: dialed`)))
      .catch((reason) => {
        this.trigger(`error`, reason);
      })
      .then(() => {
        this.locusJoinInFlight = false;
      });

    return this;
  },

  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup() {
    // Note: not a @oneFlight because this function must call itself
    if (this.direction === `in` && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info(`call: hanging up`);

    this.media.stop();

    if (this.locusJoinInFlight) {
      this.logger.info(`call: locus join in flight, waiting for rest call to complete before hanging up`);
      return this.when(`change:locusJoinInFlight`)
        .then(() => this.hangup());
    }

    if (!this.locus) {
      return this._finish()
        .then(() => this.logger.info(`call: hang up complete, call never created`));
    }

    return this._hangup();
  },

  /**
   * Initializer
   * @instance
   * @memberof Call
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize(...args) {
    Reflect.apply(SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.memberships, `change:audioMuted`, () => {
      if (this.remoteMember) {
        this.remoteAudioMuted = this.remoteMember.audioMuted;
      }
    });

    this.listenTo(this.memberships, `change:videoMuted`, () => {
      if (this.remoteMember) {
        this.remoteVideoMuted = this.remoteMember.videoMuted;
      }
    });

    this.on(`change:remoteMember`, () => {
      if (this.remoteMember) {
        this.remoteAudioMuted = this.remoteMember.audioMuted;
        this.remoteVideoMuted = this.remoteMember.videoMuted;
      }
      else {
        this.remoteAudioMuted = undefined;
        this.remoteVideoMuted = undefined;
      }
    });

    this.listenTo(this.memberships, `add`, (model) => this.trigger(`memberships:add`, model));
    this.listenTo(this.memberships, `remove`, (model) => this.trigger(`memberships:remove`, model));
    this.listenTo(this.memberships, `change`, (model) => this.trigger(`membership:change`, model));
    this.listenTo(this.memberships, `change:state`, (model) => {
      this.activeParticipantsCount = this
      .memberships
      .filter((m) => m.state === `connected`)
      .length;

      this.trigger(`membership:${model.state}`, model);
    });

    if (this.locus) {
      this.internalCallId = makeInternalCallId(this.locus);
    }
    else {
      this.once(`change:locus`, () => {
        this.internalCallId = makeInternalCallId(this.locus);
      });
    }

    this.memberships.listenToAndRun(this, `change:locus`, () => {
      if (this.locus && this.locus.participants) {

        // Reminder: we're parsing here instead of CallMembership(s) so that we
        // can avoid making those classes spark aware and therefore keep them a
        // lot simpler
        this.memberships.set(participantsToCallMemberships(this.spark, this.locus));
        this.me = this.memberships.find((m) => m._self);
      }
    });

    this.listenTo(this.spark.internal.mercury, `event:locus`, (event) => this._onLocusEvent(event));
    this.listenTo(this.spark.internal.mercury, `event:locus.difference`, (event) => this._onLocusEvent(event));

    this.listenTo(this.media, `error`, (error) => this.trigger(`error`, error));
    if (this.config.enableExperimentalGroupCallingSupport) {
      this.on(`inactive`, () => this._finish());
    }
    else {
      this.on(`disconnected`, () => this._finish());
    }
    this.on(`replaced`, () => this._finish());

    this.listenTo(this.media, `negotiationneeded`, debounce(() => {
      this.media.createOffer()
        .then(() => this._updateMedia({
          sdp: this.media.offerSdp,
          mediaId: this.mediaId
        }))
        .then(() => this._pollForExpectedLocusAndSdp())
        .then(() => {
          const sdp = JSON.parse(this.mediaConnection.remoteSdp).sdp;
          return this.media.acceptAnswer(sdp);
        })
        .catch((reason) => this.emit(`error`, reason));
    }));

    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on(`change:media.localMediaStream`, () => {
      this.localMediaStream = this.media.localMediaStream;
    });

    this.on(`change:localMediaStream`, () => {
      if (this.localMediaStream && this.localMediaStream !== this.media.localMediaStream) {
        [
          `audio`,
          `video`
        ]
          .forEach((kind) => {
            // eslint-disable-next-line max-nested-callbacks
            const track = this.localMediaStream.getTracks().find((t) => t.kind === kind);
            if (track) {
              this.media.setMedia(kind, boolToStatus(track.enabled, this[`receiving${capitalize[kind]}`]), track);
            }
            else {
              this.media.setMedia(kind, boolToStatus(false, this[`receiving${capitalize[kind]}`]));
            }
          });
        this.localMediaStream = this.media.localMediaStream;
      }
    });

    [
      `remoteMediaStream`,
      `localMediaStream`,
      `remoteAudioMuted`,
      `remoteVideoMuted`
    ].forEach((key) => {
      this.on(`change:${key}`, () => this.trigger(`${key}:change`));
    });

    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on(`change:isActive`, () => {
      if (!this.isActive) {
        if (this.joinedOnThisDevice) {
          this.logger.info(`call: hanging up due to locus going inactive`);
          this.hangup();
        }
      }
    });

    this.on(`disconnected`, () => this.hangup());

    this.on(`change:activeParticipantsCount`, () => {
      if (!this.joinedOnThisDevice) {
        return;
      }

      if (this.activeParticipantsCount !== 1) {
        return;
      }

      if (this.isCall && !this.config.hangupIfLastActive.call) {
        return;
      }

      if (!this.isCall && !this.config.hangupIfLastActive.meeting) {
        return;
      }

      const previousLocus = this.previousAttributes().locus;
      if (!previousLocus) {
        return;
      }

      if (activeParticipants(previousLocus).length > 1) {
        this.logger.info(`call: hanging up due to last participant in call`);
        this.hangup();
      }
    });

    this.on(`change:status`, () => {
      process.nextTick(() => this.trigger(this.status));
    });

    this.on(`change:state`, () => {
      if (this.config.enableExperimentalGroupCallingSupport) {
        process.nextTick(() => this.trigger(this.state));
      }
    });
  },

  @oneFlight
  /**
   * Rejects an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a no-op.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  reject() {
    if (this.direction === `out`) {
      return Promise.resolve();
    }

    this.logger.info(`call: rejecting`);
    /* eslint no-invalid-this: [0] */
    return this.spark.internal.locus.decline(this.locus)
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this._finish()))
      .then(tap(() => this.logger.info(`call: rejected`)));
  },

  /**
   * Send DTMF tones to the current call
   * @param {string} tones
   * @returns {Promise}
   */
  sendDtmf(tones) {
    if (!this.supportsDtmf) {
      return Promise.reject(new Error(`this call does not support dtmf`));
    }

    return this.spark.internal.locus.sendDtmf(this.locus, tones);
  },

  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {FeedbackObject} feedback
   * @returns {Promise}
   */
  sendFeedback(feedback) {
    return this.spark.internal.metrics.submit(`meetup_call_user_rating`, feedback);
  },

  startReceivingAudio() {
    return this._changeReceivingMedia(`audio`, true);
  },

  startReceivingVideo() {
    return this._changeReceivingMedia(`video`, true);
  },

  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio() {
    return this._changeSendingMedia(`audio`, true);
  },

  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo() {
    return this._changeSendingMedia(`video`, true);
  },

  stopReceivingAudio() {
    return this._changeReceivingMedia(`audio`, false);
  },

  stopReceivingVideo() {
    return this._changeReceivingMedia(`video`, false);
  },

  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio() {
    return this._changeSendingMedia(`audio`, false);
  },

  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo() {
    return this._changeSendingMedia(`video`, false);
  },

  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @instance
   * @memberof Call
   * @returns {undefined}
   */
  toggleFacingMode() {
    if (!this.sendingVideo) {
      throw new Error(`Cannot toggle facingMode if we're not sending video`);
    }

    if (this.facingMode !== `user` && this.facingMode !== `environment`) {
      throw new Error(`Cannot determine current facing mode; specify a new localMediaStream to change cameras`);
    }

    const constraint = {
      facingMode: {
        ideal: this.facingMode === `user` ? `environment` : `user`
      }
    };

    this.media.setMedia(`video`, boolToStatus(true, this.sendingVideo), constraint);
    return new Promise((resolve) => {
      this.media.once(`change:answerSdp`, () => {
        this.facingMode = constraint.facingMode.ideal;
        resolve();
      });
    });
  },

  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },

  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },

  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },

  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },

  _changeReceivingMedia(kind, value) {
    return new Promise((resolve) => {
      const sdp = parse(this.media.offerSdp);
      const section = find(sdp.media, {type: kind});
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes(`recv`)) {
        this.logger.info(`_changeReceivingMedia: expecting to renegotiate, waiting for media to emit "answeraccepted"`);
        this.media.once(`answeraccepted`, () => resolve(this._updateMuteToggles()));
      }
      else {
        this.logger.info(`_changeReceivingMedia: expecting to renegotiate, waiting for call to emit "change:receiving${capitalize[kind]}"`);
        this.once(`change:receiving${capitalize[kind]}`, () => resolve());
      }

      const newDirection = boolToStatus(this.media[`sending${capitalize[kind]}`], value);
      this.media.setMedia(kind, newDirection);
    });
  },

  _changeSendingMedia(kind, value) {
    this.logger.info(`_changeSendingMedia: changing sending "${kind}" to "${value}"`);
    return new Promise((resolve) => {
      const sdp = parse(this.media.offerSdp);
      const section = find(sdp.media, {type: kind});
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes(`send`)) {
        this.logger.info(`_changeSendingMedia: expecting to renegotiate, waiting for media to emit "answeraccepted"`);
        this.media.once(`answeraccepted`, () => resolve());
      }
      else {
        this.logger.info(`_changeSendingMedia: expecting to renegotiate, waiting for call to emit "change:sending${capitalize[kind]}"`);
        this.once(`change:sending${capitalize[kind]}`, () => resolve(this._updateMuteToggles()));
      }

      const newDirection = boolToStatus(value, this.media[`receiving${capitalize[kind]}`]);
      this.media.setMedia(kind, newDirection);
    });
  },

  @oneFlight
  @whileInFlight(`locusLeaveInFlight`)
  /**
   * Does the internal work necessary to end a call while allowing hangup() to
   * call itself without getting stuck in promise change because of oneFlight
   * @private
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  _hangup() {
    this.logger.info(`_hangup: attempting to leave locus`);
    const status = get(this, this.config.enableExperimentalGroupCallingSupport ? `me.state` : `status`);
    if (status === `disconnected`) {
      this.logger.info(`already hung up, not calling locus again`);
      return Promise.resolve();
    }

    if (status === `declined`) {
      this.logger.info(`call was declined, not leaving again`);
      return Promise.resolve();
    }

    if (status !== `connected`) {
      this.logger.info(`call is neither connected, disconnected, or declined, declining instead of leaving`);
      return this.decline();
    }

    this.logger.info(`_hangup: leaving locus`);
    return this.spark.internal.locus.leave(this.locus)
      .catch((err) => {
        this.logger.error(`_hangup: locus leave error: `, err.stack || err.toString());
        return Promise.reject(err);
      })
      .then(tap(() => this.logger.info(`_hangup ${this.locus.id}: finished leaving via locus`)))
      .then(tap(() => this.logger.info(`_hangup ${this.locus.id}: setting locus`)))
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this.logger.info(`_hangup ${this.locus.id}: finished setting locus`)))
      // Note: not stopping event-listening here; that'll happening
      // automatically when `disconnected` fires.
      .then(tap(() => this.logger.info(`call: hung up`)));
  },

  _finish() {
    return new Promise((resolve) => {
      // need to do this on next tick otherwise this.off() prevents remaining
      // events from being received (e.g. other listeners for `disconnected`
      // won't execute)
      process.nextTick(() => {
        this.media.stop();
        this.stopListening(this.spark.internal.mercury);
        this.off();
        resolve();
      });
    });
  },

  @oneFlight
  // The complexity in _join is largely driven up by fairly readable `||`s
  // eslint-disable-next-line complexity
  _join(locusMethodName, target, options = {}) {

    if (options.localMediaStream) {
      this.localMediaStream = options.localMediaStream;
    }
    else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              ideal: this.spark.phone.defaultFacingMode
            }
          }
        };
      }

      const mode = get(options, `constraints.video.facingMode.ideal`, get(options, `constraints.video.facingMode.exact`));
      if (mode === `user` || mode === `environment`) {
        this.facingMode = mode;
      }

      const recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = defaults(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });

      if (options.constraints.fake) {
        this.media.constraints.fake = true;
      }

      this.media.setMedia(`audio`, boolToStatus(options.constraints.audio, options.offerOptions.offerToReceiveAudio), options.constraints.audio);
      this.media.setMedia(`video`, boolToStatus(options.constraints.video, options.offerOptions.offerToReceiveVideo), options.constraints.video);
    }

    if (!target.correlationId) {
      this.correlationId = options.correlationId = uuid.v4();
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    // reminder: not doing this copy in initialize() because config may not yet
    // be available
    this.media.bandwidthLimit = {
      audioBandwidthLimit: this.config.audioBandwidthLimit,
      videoBandwidthLimit: this.config.videoBandwidthLimit
    };

    return this.media.createOffer()
      .then(tap(() => this.logger.info(`created offer`)))
      .then(() => this.spark.internal.locus[locusMethodName](target, {
        localSdp: this.media.offerSdp,
        correlationId: this.correlationId
      }))
      .then(tap(() => this.logger.info(`sent offer to locus`)))
      .then(tap(() => this.logger.info(`setting locus`)))
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this.logger.info(`successfully set locus`)))
      .then(() => {
        const answer = JSON.parse(this.mediaConnection.remoteSdp).sdp;
        this.logger.info(`accepting answer`);
        this.logger.info(`peer state`, this.media.pc && this.media.pc.signalingState);
        if (!this.media.ended) {
          return this.media.acceptAnswer(answer)
            .then(() => this.logger.info(`answer accepted`))
            .catch((err) => {
              this.logger.error(`failed to accept answer`, err);
              return Promise.reject(err);
            });
        }
        this.logger.info(`call: already ended, not accepting answer`);
        return Promise.resolve();
      });
  },

  /**
   * Handles an incoming mercury event if relevant to this call.
   * @instance
   * @memberof Call
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  _onLocusEvent(event) {
    const devices = get(event, `data.locus.self.devices`);
    const device = devices && find(devices, (item) => item.url === this.spark.internal.device.url);
    if (this.locus && makeInternalCallId(event.data.locus) === this.internalCallId || device && this.correlationId && this.correlationId === device.correlationId) {
      this.logger.info(`locus event: ${event.data.eventType}`);
      this._setLocus(event.data.locus);
    }

    if (event.data.locus.replaces) {
      for (const replaced of event.data.locus.replaces) {
        if (`${replaced.locusUrl}_${replaced.lastActive}` === this.internalCallId) {
          this._setLocus(event.data.locus);
          this.logger.info(`locus replacement event: ${event.data.eventType}`, this.locusUrl, `->`, event.data.locus.url);
          return;
        }
      }
    }
  },

  @retry
  /**
   * The response to a PUT to LOCUS/media may not be fully up-to-date when we
   * receive it. This method polls locus until we get a locus with the status
   * properties we expect (or three errors occur)
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise<Types~Locus>}
   */
  _pollForExpectedLocusAndSdp() {
    return new Promise((resolve, reject) => {
      const offer = parse(this.media.offerSdp);

      const audioOfferDirection = getMediaDirectionFromSDP(`audio`, offer);
      const videoOfferDirection = getMediaDirectionFromSDP(`video`, offer);

      const self = this;
      let count = 0;
      const validate = () => {
        count += 1;
        try {
          this.logger.info(`iteration ${count}: checking if current locus has the expected audio and video directions`);
          if (isExpectedDirection(JSON.parse(this.mediaConnection.remoteSdp).sdp)) {
            this.logger.info(`iteration ${count}: the current locus sdp has the expected audio and video directions`);
            try {
              this._validateLocusMediaState(this.locus);
              this.logger.info(`iteration ${count}: the current locus has the expected audio and video directions; syncing`);
              resolve();
            }
            catch (err) {
              this.logger.info(`iteration ${count}: the current locus does not have the expected audio and video directions; syncing`);
            }
          }
          else {
            this.logger.info(`iteration ${count}: the current locus sdp does not have the expected audio and video directions; syncing`);
          }

          if (count > 4) {
            reject(new Error(`After ${count} attempts polling locus`));
          }

          setTimeout(() => this.spark.internal.locus.sync(this.locus)
            .then((locus) => this._setLocus(locus))
            .then(validate)
            .catch(reject), 1000 * 2 ** count);
        }
        catch (err) {
          reject(err);
        }
      };

      validate();
      /**
       * Determine if the incoming sdp has the expected media directions
       * @private
       * @param {string} sdp
       * @returns {boolean}
       */
      function isExpectedDirection(sdp) {
        const answer = parse(sdp);

        const audioAnswerDirection = getMediaDirectionFromSDP(`audio`, answer);
        const videoAnswerDirection = getMediaDirectionFromSDP(`video`, answer);

        const expectedAudioAnswerDirection = reverseMediaDirection(audioOfferDirection);
        const expectedVideoAnswerDirection = reverseMediaDirection(videoOfferDirection);

        self.logger.info(`audio: ${audioOfferDirection}, ${audioAnswerDirection}, ${expectedAudioAnswerDirection}`);
        self.logger.info(`video: ${videoOfferDirection}, ${videoAnswerDirection}, ${expectedVideoAnswerDirection}`);

        return audioAnswerDirection === expectedAudioAnswerDirection && videoAnswerDirection === expectedVideoAnswerDirection;
      }
    });
  },

  /**
   * Assigns a new locus to this.locus according to locus sequencing rules
   * @instance
   * @memberof Call
   * @param {Types~Locus} incoming
   * @param {boolean} recursing - when true, indicates that this method has
   * called itself and we should fall back to {@link locus.get()} instead of
   * calling {@link locus.sync()}
   * @private
   * @returns {Promise}
   */
  _setLocus(incoming, recursing = false) {
    const current = this.locus;
    if (!current) {
      this.locus = incoming;
      return Promise.resolve();
    }
    const action = this.spark.internal.locus.compare(current, incoming);

    switch (action) {
      case USE_INCOMING:
        this.locus = this.spark.internal.locus.merge(this.locus, incoming);
        if (this.device) {
          this.correlationId = this.device.correlationId;
        }
        break;
      case FETCH:
        if (recursing) {
          this.logger.info(`call: fetching locus according to sequencing algorithm`);
          return this.spark.internal.locus.get(current)
            .then((locus) => this._setLocus(locus, true));
        }

        this.logger.info(`call: syncing locus according to sequencing algorithm`);

        return this.spark.internal.locus.sync(current)
          .then((locus) => this._setLocus(locus, true));

      default:
      // do nothing
    }

    return Promise.resolve();
  },

  /**
   * Changes the status of media
   * @instance
   * @memberof Call
   * @param {Object} payload
   * @private
   * @returns {Promise}
   */
  _updateMedia(payload) {
    if (payload.sdp && !payload.sdp.includes(`b=`)) {
      throw new Error(`outbound sdp should always have a 'b=' line`);
    }
    return this.spark.internal.locus.updateMedia(this.locus, payload)
      .then((locus) => this._setLocus(locus));
  },

  @oneFlight
  /**
   * Tells locus we've got a new media direction
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _updateMuteToggles() {
    return this._updateMedia({
      sdp: this.media.offerSdp,
      mediaId: this.mediaId,
      audioMuted: didChange(`audio`, this.media.offerSdp, this.media.answerSdp) ? this.sendingAudio : !this.sendingAudio,
      videoMuted: didChange(`video`, this.media.offerSdp, this.media.answerSdp) ? this.sendingVideo : !this.sendingVideo
    })
      .then(() => this._waitForExpectedLocus());
  },

  /**
   * Checks that this.locus has the expected state
   * @instance
   * @memberof Call
   * @param {Types~Locus} locus
   * @private
   * @returns {Promise}
   */
  _validateLocusMediaState(locus) {
    const locusAudio = locus.self.status.audioStatus.toLowerCase();
    const mediaAudio = this.media.audioDirection;

    if (locusAudio !== mediaAudio) {
      this.logger.warn(`locus: expected audio ${locusAudio} (locus) to equal ${mediaAudio} (local media)`);
      throw new Error(`locus.self.status.audioStatus indicates the received DTO is out of date`);
    }

    const locusVideo = locus.self.status.videoStatus.toLowerCase();
    const mediaVideo = this.media.videoDirection;
    if (locusVideo !== mediaVideo) {
      this.logger.warn(`locus: expected video ${locusVideo} (locus) to equal ${mediaVideo} (local media)`);
      throw new Error(`locus.self.status.videoStatus indicates the received DTO is out of date`);
    }

    return locus;
  },

  /**
   * Waits until this.locus describes the expected state
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _waitForExpectedLocus() {
    return new Promise((resolve) => {
      const listener = () => {
        try {
          this._validateLocusMediaState(this.locus);
          this.off(`change:locus`, listener);
          resolve();
        }
        catch (err) {
          this.logger.warn(`locus: current locus not in expected state; waiting for next locus`);
        }
      };
      this.on(`change:locus`, listener);
      listener();
    });
  }
});

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

export default Call;
