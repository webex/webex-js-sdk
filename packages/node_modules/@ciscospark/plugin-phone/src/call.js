/**!
 *
 * Copyright (c) 2016-2017 Cisco Systems, Inc. See LICENSE file.
 * @private
 */

/* eslint-env browser: true */
/* global RTCPeerConnection, RTCSessionDescription */

import {SparkPlugin} from '@ciscospark/spark-core';
import {
  base64,
  oneFlight,
  retry,
  tap,
  whileInFlight
} from '@ciscospark/common';
import {
  USE_INCOMING,
  FETCH
} from '@ciscospark/internal-plugin-locus';
import {debounce, defaults, find, get, set} from 'lodash';
import {
  getState,
  activeParticipants,
  direction,
  isActive,
  joined,
  joinedOnThisDevice,
  remoteAudioMuted,
  remoteParticipant,
  remoteVideoMuted
} from './state-parsers';
import boolToStatus from './bool-to-status';

import WebRTCMedia from './web-rtc-media';
import uuid from 'uuid';

import {parse} from 'sdp-transform';

/**
 * @event ringing
 * @instance
 * @memberof Call
 */

/**
 * @event connected
 * @instance
 * @memberof Call
 */

/**
 * @event disconnected
 * @instance
 * @memberof Call
 */

/**
 * @event localMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event remoteMediaStream:change
 * @instance
 * @memberof Call
 */

/**
 * @event error
 * @instance
 * @memberof Call
 */

/**
 * Payload for {@link Call#sendFeedback}
 * @typedef {Object} Types~Feedback
 * @property {number} userRating Number between 1 and 5 (5 being best) to let
 * the user score the call
 * @property {string} userComments Freeform feedback from the user about the
 * call
 * @property {Boolean} includeLogs set to true to submit client logs to the
 * Cisco Spark cloud. Note: at this time, all logs, not just call logs,
 * generated by the sdk will be uploaded to the Spark Cloud. Care has been taken
 * to avoid including PII in these logs, but if you've taken advantage of the
 * SDK's logger, you should make sure to avoid logging PII as well.
 */

/**
 * @class
 * @extends SparkPlugin
 */
const Call = SparkPlugin.extend({
  namespace: `Phone`,

  children: {
    media: WebRTCMedia
  },

  session: {
    correlationId: `string`,
    /**
     * @instance
     * @memberof Call
     * @type {string}
     * @readonly
     */
    facingMode: {
      type: `string`,
      values: [`user`, `environment`]
    },
    locus: `object`,
    /**
     * Returns the local MediaStream for the call. May initially be `null`
     * between the time @{Phone#dial is invoked and the  media stream is
     * acquired if {@link Phone#dial} is invoked without a `localMediaStream`
     * option.
     *
     * This property can also be set mid-call in which case the streams sent to
     * the remote party are replaced by this stream. On success, the
     * {@link Call}'s {@link localMediaStream:change} event fires, notifying any
     * listeners that we are now sending media from a new source.
     * @instance
     * @memberof Call
     * @type {MediaStream}
     */
    localMediaStream: `object`,

    locusJoinInFlight: {
      default: false,
      type: `boolean`
    },
    locusLeaveInFlight: {
      default: false,
      type: `boolean`
    }
  },

  // Note, in its current form, any derived property that is an object will emit
  // a change event everytime a locus gets replaced, even if no values change.
  // For the moment, this is probably ok; once we have multi-party, regular
  // change events on activeParticipants may be a problem.
  derived: {
    id: {
      deps: [`locus`],
      fn() {
        return this.locus && this.locus.url;
      }
    },
    isActive: {
      deps: [`locus`],
      fn() {
        return this.locus && isActive(this.locus);
      }
    },
    activeParticipants: {
      deps: [`locus`],
      fn() {
        return activeParticipants(this.locus);
      }
    },
    activeParticipantsCount: {
      deps: [`activeParticipants`],
      fn() {
        return this.activeParticipants.length;
      }
    },
    joined: {
      deps: [`locus`],
      default: false,
      fn() {
        return this.locus && joined(this.locus);
      }
    },
    joinedOnThisDevice: {
      deps: [`locus`],
      default: false,
      fn() {
        return this.locus && joinedOnThisDevice(this.spark, this.locus);
      }
    },
    locusUrl: {
      deps: [`locus`],
      fn() {
        return this.locus.url;
      }
    },
    device: {
      deps: [`locus`],
      fn() {
        return this.locus.self && find(this.locus.self.devices, (item) => item.url === this.spark.internal.device.url);
      }
    },
    mediaConnection: {
      deps: [`device`],
      fn() {
        return this.device && this.device.mediaConnections && this.device.mediaConnections[0];
      }
    },
    mediaId: {
      deps: [`mediaConnection`],
      fn() {
        return this.mediaConnection && this.mediaConnection.mediaId;
      }
    },
    remoteAudioMuted: {
      deps: [`locus`],
      fn() {
        return remoteAudioMuted(remoteParticipant(this.locus));
      }
    },
    remoteVideoMuted: {
      deps: [`locus`],
      fn() {
        return remoteVideoMuted(remoteParticipant(this.locus));
      }
    },
    direction: {
      deps: [`locus`],
      fn() {
        // This seems brittle, but I can't come up with a better way. The only
        // way we should have a Call without a locus is if we just initiated a
        // call but haven't got the response from locus yet.
        if (!this.locus) {
          return `out`;
        }
        return direction(this.locus);
      }
    },
    from: {
      deps: [
        `memberships`
      ],
      fn() {
        return this.memberships.find((m) => m.isInitiator);
      }
    },
    to: {
      deps: [
        `memberships`
      ],
      fn() {
        return this.memberships.find((m) => !m.isInitiator);
      }
    },
    local: {
      deps: [`locus`],
      fn() {
        return this.locus && this.locus.self;
      }
    },
    remote: {
      deps: [`locus`],
      fn() {
        return this.locus && remoteParticipant(this.locus);
      }
    },
    memberships: {
      deps: [`locus`],
      fn() {
        return this.locus.participants
          .filter((participant) => participant.type === `USER`)
          .map((participant) => ({
            personId: this.spark.people.inferPersonIdFromUuid(participant.person.id),
            isInitiator: this.direction === `out` ? participant.url === this.locus.self.url : participant.url !== this.locus.self.url,
            state: participant.state && participant.state.toLowerCase()
          }));
      }
    },
    /**
     * <b>initiated</b> - Offer was sent to remote party but they have not yet accepted <br>
     * <b>ringing</b> - Remote party has acknowledged the call <br>
     * <b>connected</b> - At least one party is still on the call <br>
     * <b>disconnected</b> - All parties have dropped <br>
     * @instance
     * @memberof Call
     * @member {string}
     * @readonly
     */
    status: {
      deps: [
        `locus`
      ],
      fn() {
        return getState(this.spark, this.locus);
      }
    },
    /**
     * Access to the remote partyâ€™s `MediaStream`.
     * @instance
     * @memberof Call
     * @member {MediaStream}
     * @readonly
     */
    remoteMediaStream: {
      deps: [`media.remoteMediaStream`],
      fn() {
        return this.media.remoteMediaStream;
      }
    },
    receivingAudio: {
      deps: [`media.receivingAudio`],
      fn() {
        return this.media.receivingAudio;
      }
    },
    receivingVideo: {
      deps: [`media.receivingVideo`],
      fn() {
        return this.media.receivingVideo;
      }
    },
    sendingAudio: {
      deps: [`media.sendingAudio`],
      fn() {
        return this.media.sendingAudio;
      }
    },
    sendingVideo: {
      deps: [`media.sendingVideo`],
      fn() {
        return this.media.sendingVideo;
      }
    }
  },

  @oneFlight
  /**
   * Use to acknowledge (without answering) an incoming call. Will cause the
   * initiator's Call instance to emit the ringing event.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  acknowledge() {
    this.logger.info(`call: acknowledging`);
    return this.spark.internal.locus.alert(this.locus)
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this.logger.info(`call: acknowledged`)));
  },

  @oneFlight
  @whileInFlight(`locusJoinInFlight`)
  /**
   * Answers an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a noop
   * @instance
   * @memberof Call
   * @param {Object} options
   * @param {MediaStreamConstraints} options.constraints
   * @returns {Promise}
   */
  answer(options) {
    this.logger.info(`call: answering`);
    if (!this.locus || this.direction === `out`) {
      this.logger.info(`call: outbound call, answer() is a noop`);
      return Promise.resolve();
    }
    // Locus may think we're joined on this device if we e.g. reload the page,
    // so, we need to check if we also have a working peer connection
    if (this.joinedOnThisDevice && this.media.peer) {
      this.logger.info(`call: already joined on this device`);
      return Promise.resolve();
    }
    return this._join(`join`, this.locus, options)
      .then(tap(() => this.logger.info(`call: answered`)));
  },

  /**
   * Alias of {@link Call#reject}
   * @see {@link Call#reject}
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  decline() {
    return this.reject();
  },

  @oneFlight
  /**
   * Used by {@link Phone#dial} to initiate an outbound call
   * @instance
   * @memberof Call
   * @param {[type]} invitee
   * @param {[type]} options
   * @private
   * @returns {[type]}
   */
  dial(invitee, options) {
    this.locusJoinInFlight = true;
    this.logger.info(`call: dialing`);

    if (base64.validate(invitee)) {
      // eslint-disable-next-line no-unused-vars
      const parsed = base64.decode(invitee).split(`/`);
      const resourceType = parsed[3];
      const id = parsed[4];
      if (resourceType === `PEOPLE`) {
        invitee = id;
      }
    }

    this.logger.info(this.registered, !!this.spark.internal.device.url, this.connected, this.spark.internal.mercury.connected, this.spark.internal.device.url);

    // Note: mercury.connect() will call device.register() if needed. We're not
    // using phone.register() here because it guarantees a device refresh, which
    // is probably unnecessary.
    this.spark.internal.mercury.connect()
      .then(() => this._join(`create`, invitee, options))
      .then(tap(() => this.logger.info(`call: dialed`)))
      .catch((reason) => {
        this.trigger(`error`, reason);
      })
      .then(() => {
        this.locusJoinInFlight = false;
      });

    return this;
  },

  /**
   * Disconnects the active call. Applies to both incoming and outgoing calls.
   * This method may be invoked in any call state and the SDK should take care
   * to tear down the call and free up all resources regardless of the state.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  hangup() {
    // Note: not a @oneFlight because this function must call itself
    if (this.direction === `in` && !this.joinedOnThisDevice) {
      return this.reject();
    }

    this.logger.info(`call: hanging up`);

    this.media.end();

    if (this.locusJoinInFlight) {
      this.logger.info(`call: locus join in flight, waiting for rest call to complete before hanging up`);
      return this.when(`change:locusJoinInFlight`)
        .then(() => this.hangup());
    }

    if (!this.locus) {
      this.stopListening(this.spark.internal.mercury);
      this.off();
      this.logger.info(`call: hang up complete, call never created`);
      return Promise.resolve();
    }

    return this._hangup();
  },

  /**
   * Initializer
   * @instance
   * @memberof Call
   * @private
   * @param {Object} attrs
   * @param {Object} options
   * @returns {undefined}
   */
  initialize(...args) {
    Reflect.apply(SparkPlugin.prototype.initialize, this, args);

    this.listenTo(this.spark.internal.mercury, `event:locus`, (event) => this._onLocusEvent(event));
    this.listenTo(this.media, `error`, (error) => this.trigger(`error`, error));
    this.on(`disconnected`, () => {
      // need to do this on next tick otherwise this.off() prevents remaining
      // events from being received (e.g. other listeners for `disconnected`
      // won't execute)
      process.nextTick(() => {
        this.stopListening(this.spark.internal.mercury);
        this.off();
      });
    });

    this.listenTo(this.media, `negotiationneeded`, debounce(() => {
      this.media.createOffer()
        .then(() => this._updateMedia({
          sdp: this.media.offerSdp,
          mediaId: this.mediaId
        }))
        .then(() => this._pollForExpectedLocus())
        .then(() => {
          const sdp = JSON.parse(this.mediaConnection.remoteSdp).sdp;
          return this.media.acceptAnswer(sdp);
        })
        .catch((reason) => this.emit(`error`, reason));
    }));

    // Reminder: this is not a derived property so that we can reassign the
    // stream midcall
    this.on(`change:media.localMediaStream`, () => {
      this.localMediaStream = this.media.localMediaStream;
    });

    this.on(`change:localMediaStream`, () => {
      if (this.media.localMediaStream !== this.localMediaStream) {
        this.media.localMediaStream = this.localMediaStream;
      }


      if (this.facingMode) {
        const mode = get(this, `media.videoConstraint.facingMode.ideal`, get(this, `media.videoConstraint.facingMode.ideal`));

        if (mode === `user`) {
          this.facingMode = `user`;
        }

        if (mode === `environment`) {
          this.facingMode = `environment`;
        }
      }
    });

    [
      `remoteMediaStream`,
      `localMediaStream`,
      `remoteAudioMuted`,
      `remoteVideoMuted`
    ].forEach((key) => {
      this.on(`change:${key}`, () => this.trigger(`${key}:change`));
    });

    // This handler is untested because there's no way to provoke it. It's
    // probably actually only relevant for group calls.
    this.on(`change:isActive`, () => {
      if (!this.isActive) {
        if (this.joinedOnThisDevice) {
          this.logger.info(`call: hanging up due to locus going inactive`);
          this.hangup();
        }
      }
    });

    this.on(`change:activeParticipantsCount`, () => {
      const previousLocus = this.previousAttributes().locus;
      if (this.joinedOnThisDevice && this.activeParticipantsCount === 1 && previousLocus && activeParticipants(previousLocus).length > 1) {
        this.logger.info(`call: hanging up due to last participant in call`);
        this.hangup();
      }
    });

    this.on(`change:status`, () => {
      process.nextTick(() => this.trigger(this.status));
    });
  },

  @oneFlight
  /**
   * Rejects an incoming call. Only applies to incoming calls. Invoking this
   * method on an outgoing call is a no-op.
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  reject() {
    if (this.direction === `out`) {
      return Promise.resolve();
    }

    this.logger.info(`call: rejecting`);
    /* eslint no-invalid-this: [0] */
    return this.spark.internal.locus.decline(this.locus)
      .then((locus) => this._setLocus(locus))
      .then(tap(() => this.stopListening(this.spark.internal.mercury)))
      .then(tap(() => this.off()))
      .then(tap(() => this.logger.info(`call: rejected`)));
  },

  /**
   * Sends feedback about the call to the Cisco Spark cloud
   * @instance
   * @memberof Call
   * @param {Types~Feedback} feedback
   * @returns {Promise}
   */
  sendFeedback(feedback) {
    return this.spark.internal.metrics.submit(`meetup_call_user_rating`, feedback);
  },

  startReceivingAudio() {
    return this._changeReceivingMedia(`offerToReceiveAudio`, true);
  },

  startReceivingVideo() {
    return this._changeReceivingMedia(`offerToReceiveVideo`, true);
  },

  /**
   * Starts sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingAudio() {
    return this._changeSendingMedia(`audio`, true);
  },

  /**
   * Starts sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  startSendingVideo() {
    return this._changeSendingMedia(`video`, true);
  },

  stopReceivingAudio() {
    return this._changeReceivingMedia(`offerToReceiveAudio`, false);
  },

  stopReceivingVideo() {
    return this._changeReceivingMedia(`offerToReceiveVideo`, false);
  },

  /**
   * Stops sending audio to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingAudio() {
    return this._changeSendingMedia(`audio`, false);
  },

  /**
   * Stops sending video to the Cisco Spark Cloud. (stops broadcast immediately,
   * even if renegotiation has not completed)
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  stopSendingVideo() {
    return this._changeSendingMedia(`video`, false);
  },

  /**
   * Replaces the current mediaStrem with one with identical constraints, except
   * for an opposite facing mode. If the current facing mode cannot be
   * determined, the facing mode will be set to `user`. If the call is audio
   * only, this function will throw.
   * @instance
   * @memberof Call
   * @returns {undefined}
   */
  toggleFacingMode() {
    const constraints = {
      audio: Object.assign({}, this.media.audioConstraint),
      video: this.media.videoConstraint
    };

    if (!constraints.video) {
      throw new Error(`Cannot toggle facignMode on audio-only call`);
    }

    if (this.facingMode !== `user` && this.facingMode !== `environment`) {
      throw new Error(`Cannot determine current facing mode; specify a new localMediaStream to change cameras`);
    }

    if (constraints.video === true) {
      constraints.video = {
        facingMode: {
          ideal: this.facingMode
        }
      };
    }

    if (this.facingMode === `user`) {
      set(constraints, `video.facingMode.ideal`, `environment`);
    }
    else {
      set(constraints, `video.facingMode.ideal`, `user`);
    }

    return this.spark.phone.createLocalMediaStream(constraints)
      .then((stream) => new Promise((resolve) => {
        this.media.once(`answeraccepted`, resolve);
        this.localMediaStream = stream;
      }))
      .then(() => {
        this.facingMode = constraints.video.facingMode.ideal || constraints.video.facingMode.exact;
      });
  },

  /**
   * Toggles receiving audio from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingAudio() {
    return this.receivingAudio ? this.stopReceivingAudio() : this.startReceivingAudio();
  },

  /**
   * Toggles receiving video from the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleReceivingVideo() {
    return this.receivingVideo ? this.stopReceivingVideo() : this.startReceivingVideo();
  },

  /**
   * Toggles sending audio to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingAudio() {
    return this.sendingAudio ? this.stopSendingAudio() : this.startSendingAudio();
  },

  /**
   * Toggles sending video to the Cisco Spark Cloud
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  toggleSendingVideo() {
    return this.sendingVideo ? this.stopSendingVideo() : this.startSendingVideo();
  },

  _changeReceivingMedia(key, value) {
    return new Promise((resolve) => {
      this.once(`change:receiving${key === `offerToReceiveAudio` ? `Audio` : `Video`}`, () => resolve());
      this.media.set(key, value);
    });
  },

  _changeSendingMedia(key, value) {
    return new Promise((resolve) => {
      const sdp = parse(this.media.offerSdp);
      const section = find(sdp.media, {type: key});
      // If the current offer is going to trigger a renegotiation, then we don't
      // need to renegotiate here.
      if (!section || !section.direction.includes(`send`)) {
        this.media.once(`answeraccepted`, resolve);
      }
      else {
        this.once(`change:sending${key === `audio` ? `Audio` : `Video`}`, () => resolve(this._updateSendingMedia()));
      }
      this.media.set(key, value);
    });
  },

  @oneFlight
  @whileInFlight(`locusLeaveInFlight`)
  /**
   * Does the internal work necessary to end a call while allowing hangup() to
   * call itself without getting stuck in promise change because of oneFlight
   * @private
   * @instance
   * @memberof Call
   * @returns {Promise}
   */
  _hangup() {
    return this.spark.internal.locus.leave(this.locus)
      .then((locus) => this._setLocus(locus))
      // Note: not stopping event-listening here; that'll happening
      // automatically when `disconnected` fires.
      .then(tap(() => this.logger.info(`call: hung up`)));
  },

  @oneFlight
  // The complexity in _join is largely driven up by fairly readable `||`s
  // eslint-disable-next-line complexity
  _join(locusMethodName, target, options = {}) {

    if (options.localMediaStream) {
      this.media.set(`localMediaStream`, options.localMediaStream);
    }
    else {
      if (!options.constraints) {
        options.constraints = {
          audio: true,
          video: {
            facingMode: {
              ideal: this.spark.phone.defaultFacingMode
            }
          }
        };
      }
      const mode = get(options, `constraints.video.facingMode.ideal`, get(options, `constraints.video.facingMode.exact`));
      if (mode === `user` || mode === `environment`) {
        this.facingMode = mode;
      }

      const recvOnly = !options.constraints.audio && !options.constraints.video;
      options.offerOptions = defaults(options.offerOptions, {
        offerToReceiveAudio: recvOnly || !!options.constraints.audio,
        offerToReceiveVideo: recvOnly || !!options.constraints.video
      });
    }

    const mediaOptions = {};
    if (options.constraints) {
      mediaOptions.audio = options.constraints.audio;
      mediaOptions.video = options.constraints.video;
    }

    if (options.offerOptions) {
      mediaOptions.offerToReceiveAudio = options.offerOptions.offerToReceiveAudio;
      mediaOptions.offerToReceiveVideo = options.offerOptions.offerToReceiveVideo;
    }

    if (mediaOptions.offerOptions || options.constraints) {
      this.media.set(mediaOptions);
    }

    if (!target.correlationId) {
      this.correlationId = options.correlationId = uuid.v4();
    }

    if (!this.correlationId) {
      this.correlationId = target.correlationId;
    }

    return this.media.createOffer()
      .then(() => this.spark.internal.locus[locusMethodName](target, {
        localSdp: this.media.offerSdp,
        correlationId: this.correlationId
      }))
      .then((locus) => {
        this._setLocus(locus);
        const answer = JSON.parse(this.mediaConnection.remoteSdp).sdp;
        this.logger.info(`accepting offer`);
        this.logger.info(`peer state`, this.media.peer && this.media.peer.signalingState);
        if (!this.media.ended) {
          return this.media.acceptAnswer(answer)
            .then(() => this.logger.info(`offer accepted`));
        }
        this.logger.info(`call: already ended, not accepting answer`);
        return Promise.resolve();
      });
  },

  /**
   * Handles an incoming mercury event if relevant to this call.
   * @instance
   * @memberof Call
   * @param {Types~MercuryEvent} event
   * @private
   * @returns {undefined}
   */
  _onLocusEvent(event) {
    const device = find(event.data.locus.self.devices, (item) => item.url === this.spark.internal.device.url);
    if (this.locus && event.data.locus.url === this.locus.url || this.correlationId && this.correlationId === device.correlationId) {
      this.logger.info(`locus event: ${event.data.eventType}`);
      this._setLocus(event.data.locus);
    }
  },

  @retry
  /**
   * The response to a PUT to LOCUS/media may not be fully up-to-date when we
   * receive it. This method polls locus until we get a locus with the status
   * properties we expect (or three errors occur)
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise<Types~Locus>}
   */
  _pollForExpectedLocus() {
    return new Promise((resolve) => {
      try {
        this._validateLocusMediaState(this.locus);
        resolve();
      }
      catch (err) {
        this.logger.warn(`locus: received locus does not contain expected state; fetching again`);
        resolve(this.spark.internal.locus.get(this.locus)
          .then((locus) => this._setLocus(locus))
          .then(() => this._validateLocusMediaState(this.locus)));
      }
    });
  },

  /**
   * Assigns a new locus to this.locus according to locus sequencing rules
   * @instance
   * @memberof Call
   * @param {Types~Locus} incoming
   * @private
   * @returns {Promise}
   */
  _setLocus(incoming) {
    const current = this.locus;
    if (!current) {
      this.locus = incoming;
      return Promise.resolve();
    }
    const action = this.spark.internal.locus.compare(current, incoming);

    switch (action) {
    case USE_INCOMING:
      this.locus = incoming;
      // certain reasons for setting a locus (such as from calling
      // acknowledge())
      if (this.device) {
        this.correlationId = this.device.correlationId;
      }
      break;
    case FETCH:
      return this.spark.internal.locus.get(current)
         .then((locus) => this._setLocus(locus));
    default:
      // do nothing
    }

    return Promise.resolve();
  },

  /**
   * Changes the status of media
   * @instance
   * @memberof Call
   * @param {Object} payload
   * @private
   * @returns {Promise}
   */
  _updateMedia(payload) {
    if (payload.sdp && !payload.sdp.includes(`b=`)) {
      throw new Error(`outbound sdp should always have a 'b=' line`);
    }
    return this.spark.internal.locus.updateMedia(this.locus, payload)
      .then((locus) => this._setLocus(locus));
  },

  @oneFlight
  /**
   * Changes the status of outbound media
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _updateSendingMedia() {
    return this._updateMedia({
      sdp: this.media.offerSdp,
      mediaId: this.mediaId,
      audioMuted: !this.sendingAudio,
      videoMuted: !this.sendingVideo
    })
      .then(() => this._waitForExpectedLocus());
  },

  /**
   * Checks that this.locus has the expected state
   * @instance
   * @memberof Call
   * @param {Types~Locus} locus
   * @private
   * @returns {Promise}
   */
  _validateLocusMediaState(locus) {
    const locusAudio = locus.self.status.audioStatus.toLowerCase();
    const mediaAudio = boolToStatus(this.media.audio, this.media.offerToReceiveAudio);
    if (locusAudio !== mediaAudio) {
      this.logger.warn(`locus: expected audio ${locusAudio} (locus) to equal ${mediaAudio} (local media)`);
      throw new Error(`locus.self.status.audioStatus indicates the received DTO is out of date`);
    }

    const locusVideo = locus.self.status.videoStatus.toLowerCase();
    const mediaVideo = boolToStatus(this.media.video, this.media.offerToReceiveVideo);
    if (locusVideo !== mediaVideo) {
      this.logger.warn(`locus: expected video ${locusVideo} (locus) to equal ${mediaVideo} (local media)`);
      throw new Error(`locus.self.status.videoStatus indicates the received DTO is out of date`);
    }

    return locus;
  },

  /**
   * Waits until this.locus describes the expected state
   * @instance
   * @memberof Call
   * @private
   * @returns {Promise}
   */
  _waitForExpectedLocus() {
    return new Promise((resolve) => {
      const listener = () => {
        try {
          this._validateLocusMediaState(this.locus);
          this.off(`change:locus`, listener);
          resolve();
        }
        catch (err) {
          this.logger.warn(`locus: current locus not in expected state; waiting for next locus`);
        }
      };
      this.on(`change:locus`, listener);
      listener();
    });
  }
});

Call.make = function make(attrs, options) {
  return new Call(attrs, options);
};

export default Call;
