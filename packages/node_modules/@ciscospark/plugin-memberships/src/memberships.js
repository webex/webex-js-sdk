/*!
 * Copyright (c) 2015-2019 Cisco Systems, Inc. See LICENSE file.
 */

import {SparkPlugin, Page} from '@ciscospark/spark-core';
import {cloneDeep} from 'lodash';
import {
  WEBEX_EVENT,
  WEBEX_SPACE_TYPE,
  API_ACTIVITY_FIELD,
  API_ACTIVITY_VERB,
  SDK_EVENT_RESOURCE,
  SDK_EVENT,
  SDK_EVENT_OWNER,
  SDK_EVENT_STATUS,
  hydraTypes,
  constructHydraId
} from '@ciscospark/common';

const debug = require('debug')('memberships');

/**
 * @typedef {Object} MembershipObject
 * @property {string} id - Unique identifier for the membership
 * @property {string} roomId - The room ID
 * @property {string} personId - The person ID
 * @property {email} personEmail - The email address of the person / room member
 * @property {boolean} isModerator - Indicates whether the specified person should be a room moderator
 * @property {boolean} isMonitor - Indicates whether the specified member is a room monitor
 * @property {isoDate} created - The date and time that this membership was created
 */

/**
 * Memberships represent a person's relationship to a room. Use this API to list
 * members of any room that you're in or create memberships to invite someone
 * to a room. Memberships can also be updated to make someone a moderator
 * or deleted to remove them from the room.
 * @class
 * @name Memberships
 */
const Memberships = SparkPlugin.extend({
  /**
   * Connect to the web socket to listen to incoming messages.
   * @returns {Promise}
   */
  listen() {
    // Create a common envelope that we will wrap all events in
    this.eventEnvelope = {
      resource: SDK_EVENT_RESOURCE.MEMBERSHIPS,
      // id -- webhook id concept does not correlate to SDK socket event
      // name -- webhook name concept does not correlate to SDK socket event
      // targetUrl -- targetUrl concept does not correlate to SDK socket event
      // secret -- secret concept does not correlate to SDK socket event
      ownedBy: SDK_EVENT_OWNER.CREATOR,
      status: SDK_EVENT_STATUS.ACTIVE,
      created: new Date().toISOString(),
      data: {}
    };

    // We need to query for some of the envelope info...
    this.spark.people.get('me')
      .then((person) => {
        this.eventEnvelope.createdBy = person.id;
        this.eventEnvelope.orgId = person.orgId;
      }).catch((e) => {
        console.error(`Unable to get person info for memberships \
          event envelope ${e.message}`);
      });

    // Register to listen to events
    return this.spark.internal.mercury.connect().then(() => {
      this.listenTo(this.spark.internal.mercury,
        WEBEX_EVENT.TEAMS_ACTIVITY,
        (event) => this.onWebexApiEvent(event));
    });
  },

  /**
   * Trigger a membership related events.
   * @param {Object} event
   * @returns {undefined} -- nothing //linter requires return in JSDoc
   */
  onWebexApiEvent(event) {
    const {activity} = event.data;

    /* eslint-disable no-case-declarations */
    switch (activity.verb) {
      case API_ACTIVITY_VERB.ADD:
        const membershipCreatedEventData =
          this.getMembershipEvent(activity, SDK_EVENT.CREATED);

        if (membershipCreatedEventData) {
          debug(`membership "created" payload: \
            ${JSON.stringify(membershipCreatedEventData)}`);
          this.trigger(SDK_EVENT.CREATED, membershipCreatedEventData);
        }
        break;

      case API_ACTIVITY_VERB.LEAVE:
        const membershipDeletedEventData =
          this.getMembershipEvent(activity, SDK_EVENT.DELETED);

        if (membershipDeletedEventData) {
          debug(`membership "deleted" payload: \
            ${JSON.stringify(membershipDeletedEventData)}`);
          this.trigger(SDK_EVENT.DELETED, membershipDeletedEventData);
        }
        break;

      case API_ACTIVITY_VERB.ADD_MODERATOR:
      case API_ACTIVITY_VERB.REMOVE_MODERATOR:
      case API_ACTIVITY_VERB.HIDE:
        const membershipUpdatedEventData =
          this.getMembershipEvent(activity, SDK_EVENT.UPDATED);

        if (membershipUpdatedEventData) {
          debug(`membership "updated" payload: \
            ${JSON.stringify(membershipUpdatedEventData)}`);
          this.trigger(SDK_EVENT.UPDATED, membershipUpdatedEventData);
        }
        break;

      case API_ACTIVITY_VERB.ACKNOWLEDGE:
        const membershipSeenEventData =
          this.getMembershipEvent(activity, SDK_EVENT.SEEN);

        if (membershipSeenEventData) {
          debug(`membership "updated" payload: \
            ${JSON.stringify(membershipSeenEventData)}`);
          this.trigger(SDK_EVENT.SEEN, membershipSeenEventData);
        }
        break;

      default:
        break;
    }
  },

  /**
   * Constructs the data object for an event on the memberships resource,
   * adhering to Hydra's Webehook data structure memberships.
   * @param {Object} activity from mercury
   * @param {Object} event type of "webhook" event
   * @returns {Object} constructed event
   */
  getMembershipEvent(activity, event) {
    const sdkEvent = cloneDeep(this.eventEnvelope);
    let member;
    let space;

    sdkEvent.event = event;
    sdkEvent.data.created = activity.published;
    sdkEvent.actorId = constructHydraId(hydraTypes.PEOPLE, activity.actor.id);
    if (activity.verb !== API_ACTIVITY_VERB.HIDE) {
      sdkEvent.data.roomId =
      constructHydraId(hydraTypes.ROOM, activity.target.id);
      sdkEvent.data.roomType =
        activity.target.tags.includes('ONE_ON_ONE') ?
          WEBEX_SPACE_TYPE.DIRECT : WEBEX_SPACE_TYPE.GROUP;
      sdkEvent.data.isRoomHidden = false; // any activity unhides a space.
    }
    else {
      sdkEvent.data.roomId =
      constructHydraId(hydraTypes.ROOM, activity.object.id);
      sdkEvent.data.roomType = WEBEX_SPACE_TYPE.DIRECT; // currently hidden attribute is only set on 1-1
      sdkEvent.data.isRoomHidden = true;
    }
    if ((activity.object.roomProperties) && (activity.object.roomProperties.isModerator)) {
      sdkEvent.data.isModerator = true;
    }
    else {
      sdkEvent.data.isModerator = false;
    }
    sdkEvent.data.isMonitor = false;

    if (activity.verb === API_ACTIVITY_VERB.ACKNOWLEDGE) {
      // For a read receipt the person is the "actor" or the one who did the reading
      member = API_ACTIVITY_FIELD.ACTOR;
      space = API_ACTIVITY_FIELD.TARGET; // and the space is the "target"
      // And the "object" is the message that was last seen
      sdkEvent.data.lastSeenId =
        constructHydraId(hydraTypes.MESSAGE, activity.object.id);
    }
    else if (activity.verb === API_ACTIVITY_VERB.HIDE) {
      // For a hide activity the person is also the "actor"
      member = API_ACTIVITY_FIELD.ACTOR;
      space = API_ACTIVITY_FIELD.OBJECT; // but the space is now the "object"
    }
    else {
      // For most memberships events the person is the 'object" or the one whose membership it is
      member = API_ACTIVITY_FIELD.OBJECT;
      space = API_ACTIVITY_FIELD.TARGET; // and the space is the "target"
    }
    if ((!activity[member]) || (!activity[space])) {
      console.error('Unable to generate SDK event ' +
        'from mercury socket activity');

      return null;
    }
    sdkEvent.data.id = constructHydraId(hydraTypes.MEMBERSHIP,
      `${activity[member].entryUUID}:${activity[space].id}`);
    sdkEvent.data.personId =
      constructHydraId(hydraTypes.PEOPLE, activity[member].entryUUID);
    sdkEvent.data.personEmail =
      activity[member].emailAddress || activity[member].entryEmail;
    sdkEvent.data.personDisplayName = activity[member].displayName;
    sdkEvent.data.personOrgId =
      constructHydraId(hydraTypes.ORGANIZATION, activity[member].orgId);

    return sdkEvent;
  },


  /**
   * Adds a person to a room. The person can be added by ID (`personId`) or by
   * Email Address (`personEmail`). The person can be optionally added to the room
   * as a moderator.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * ciscospark.rooms.create({title: 'Create Membership Example'})
   *   .then(function(room) {
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *    });
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert(membership.id);
   *     assert(membership.roomId);
   *     assert(membership.personId);
   *     assert(membership.personEmail);
   *     assert('isModerator' in membership);
   *     assert('isMonitor' in membership);
   *     assert(membership.created);
   *     return 'success';
   *   });
   *   // => success
   */
  create(membership) {
    return this.request({
      method: 'POST',
      service: 'hydra',
      resource: 'memberships',
      body: membership
    })
      .then((res) => res.body);
  },

  /**
   * Returns a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership;
   * ciscospark.rooms.create({title: 'Get Membership Example'})
   *   .then(function(room) {
   *     return ciscospark.memberships.create({
   *       personEmail: 'alice@example.com',
   *       roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.memberships.get(m.id);
   *   })
   *   .then(function(m) {
   *     var assert = require('assert');
   *     assert.deepEqual(m, membership);
   *     return 'success';
   *   });
   *   // => success
   */
  get(membership) {
    const id = membership.id || membership;

    return this.request({
      service: 'hydra',
      resource: `memberships/${id}`
    })
      .then((res) => res.body.items || res.body);
  },

  /**
   * Returns a list of memberships. In most cases the results will only contain
   * rooms that the authentiated user is a member of. You can filter the results
   * by room to list people in a room or by person to find rooms that a
   * specific person is a member of.
   * @instance
   * @memberof Memberships
   * @param {Object} options
   * @param {string} options.personId
   * @param {string} options.personEmail
   * @param {string} options.roomId
   * @param {number} options.max
   * @returns {Promise<Page<MembershipObject>>}
   * @example
   * var room;
   * ciscospark.rooms.create({title: 'List Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     for (var i = 0; i < memberships.length; i+= 1) {
   *       assert.equal(memberships.items[i].roomId, room.id);
   *     }
   *     return 'success';
   *   });
   *   // => success
   */
  list(options) {
    return this.request({
      service: 'hydra',
      resource: 'memberships',
      qs: options
    })
      .then((res) => new Page(res, this.spark));
  },

  /**
   * Deletes a single membership.
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise}
   * @example
   * var membership, room;
   * ciscospark.rooms.create({title: 'Remove Membership Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.create({
   *      personEmail: 'alice@example.com',
   *      roomId: room.id
   *     });
   *   })
   *   .then(function(m) {
   *     membership = m;
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 2);
   *     return ciscospark.memberships.remove(membership);
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     var assert = require('assert');
   *     assert.equal(memberships.length, 1);
   *     return 'success';
   *   });
   *   // => success
   */
  remove(membership) {
    const id = membership.id || membership;

    return this.request({
      method: 'DELETE',
      service: 'hydra',
      resource: `memberships/${id}`
    })
      .then((res) => {
        // Firefox has some issues with 204s and/or DELETE. This should move to
        // http-core
        if (res.statusCode === 204) {
          return undefined;
        }

        return res.body;
      });
  },

  /**
   * Used to update a single membership's properties
   * @instance
   * @memberof Memberships
   * @param {MembershipObject|uuid} membership
   * @returns {Promise<MembershipObject>}
   * @example
   * var membership, room;
   * ciscospark.rooms.create({title: 'Memberships Example'})
   *   .then(function(r) {
   *     room = r;
   *     return ciscospark.memberships.list({roomId: room.id});
   *   })
   *   .then(function(memberships) {
   *     membership = memberships.items[0];
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, false);
   *     membership.isModerator = true;
   *     return ciscospark.memberships.update(membership);
   *   })
   *   .then(function() {
   *     return ciscospark.memberships.get(membership.id);
   *   })
   *   .then(function(membership) {
   *     var assert = require('assert');
   *     assert.equal(membership.isModerator, true);
   *     return 'success';
   *   });
   *   // => success
   */
  update(membership) {
    const id = membership.id || membership;

    return this.request({
      method: 'PUT',
      service: 'hydra',
      resource: `memberships/${id}`,
      body: membership
    })
      .then((res) => res.body);
  }
});

export default Memberships;
