/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */


/* istanbul ignore next */
if (typeof Promise === 'undefined') {
  // eslint-disable-next-line global-require
  require('es6-promise').polyfill();
}

/* eslint-env mocha */
/* eslint camelcase: [0] */

const _ = require('lodash');
const assert = require('assert');
const retry = require('@ciscospark/test-helper-retry');

let TestUsers;
try {
  /* eslint global-require: [0] */
  TestUsers = require('@ciscospark/test-users-legacy');
}
catch (e) {
  // ignore
}

const allUsers = [];
if (after) {
  after(function () {
    /* eslint no-invalid-this: [0] */
    this.timeout(120000);
    allUsers.forEach((user) => user.spark && user.spark.internal.mercury && user.spark.internal.mercury.disconnect());

    return _remove(allUsers);
  });
}

/**
 * Helper
 * @param {Object} options
 * @private
 * @returns {Promise<Array<User>>}
 */
function _create(options) {
  options = options || {};
  let count = options.count;
  if (!count) {
    count = 1;
  }

  const promises = [];
  for (let i = 0; i < count; i += 1) {
    promises.push(retry(makeUser));
  }
  return Promise.all(promises);

  /**
   * Helper
   * @private
   * @returns {Promise<User>}
   */
  function makeUser() {
    const config = _.defaults({
      scopes: process.env.CISCOSPARK_SCOPE
    }, options.config);
    return TestUsers.create(config)
      .then((user) => {
        allUsers.push(user);
        return user;
      });
  }
}

/**
 * Gets users from environment variable
 * @param {Object} options
 * @returns {Array<User>}
 */
function _extractFromEnv(options) {
  /* eslint complexity: [0] */
  let count = options.count;
  if (!count) {
    count = 1;
  }

  const users = [{
    id: process.env.CISCOSPARK_ID || process.env.CISCOSPARK_ID_0,
    token: {
      access_token: process.env.CISCOSPARK_ACCESS_TOKEN || process.env.CISCOSPARK_ACCESS_TOKEN_0,
      refresh_token: process.env.CISCOSPARK_REFRESH_TOKEN || process.env.CISCOSPARK_REFRESH_TOKEN_0
    },
    email: process.env.CISCOSPARK_EMAIL || process.env.CISCOSPARK_EMAIL_0,
    name: process.env.CISCOSPARK_NAME || process.env.CISCOSPARK_NAME_0,
    password: process.env.CISCOSPARK_PASSWORD || process.env.CISCOSPARK_PASSWORD_0
  }];

  for (let i = 1; i < count; i += 1) {
    users.push({
      id: process.env[`CISCOSPARK_ID_${i}`],
      token: {
        access_token: process.env[`CISCOSPARK_ACCESS_TOKEN_${i}`],
        refresh_token: process.env[`CISCOSPARK_REFRESH_TOKEN_${i}`]
      },
      email: process.env[`CISCOSPARK_EMAIL_${i}`],
      name: process.env[`CISCOSPARK_NAME_${i}`],
      password: process.env[`CISCOSPARK_PASSWORD_${i}`]
    });
  }

  for (let j = 0; j < count; j += 1) {
    assert(users[j].access_token, `No access token available for user${j}`);
  }

  return users;
}

/**
 * Helper
 * @param {Array<User>} users
 * @returns {Promise}
 */
function _remove(users) {
  return Promise.all(users.map((user) => {
    if (user.token && !user.token.authorization) {
      Reflect.deleteProperty(user, 'token');
    }
    TestUsers.remove(user)
      .catch((reason) => {
        console.warn('failed to delete test user', reason);
      });

    // Edge times out waiting for the delete calls to complete (and test user
    // deletion isn't really something we need to wait for anyway) so we'll just
    // give enough time for the requests to go out, then allow the browser to
    // close, even if the requests haven't returned.
    return new Promise((resolve) => {
      setTimeout(resolve, 500);
    });
  }));
}

module.exports = {
  create: function create(options) {
    assert(process.env.CISCOSPARK_CLIENT_ID, 'CISCOSPARK_CLIENT_ID must be defined');
    assert(process.env.CISCOSPARK_CLIENT_SECRET, 'CISCOSPARK_CLIENT_SECRET must be defined');

    return new Promise((resolve) => {
      resolve(TestUsers ? _create(options) : _extractFromEnv(options));
    });
  },

  remove: function remove(users) {
    if (!TestUsers) {
      return Promise.resolve();
    }

    return _remove(users);
  }
};
