/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

/* eslint camelcase: [0] */

import '@ciscospark/internal-plugin-calendar';
import CiscoSpark from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import retry from '@ciscospark/test-helper-retry';
import testUsers from '@ciscospark/test-helper-test-users';
import uuid from 'uuid';


/**
 * produces a mock meeting object
 * @param {Object} params
 * @returns {Meeting}
 */
function makeMockMeetingPayload(params) {
  const payload = {
    id: params.meetingId,
    seriesId: params.seriesId,
    start: params.start,
    durationMinutes: params.durationMinutes,
    organizer: params.organizer.id,
    encryptionKeyUrl: ``,
    encryptedSubject: params.title,
    isRecurring: params.isRecurring,
    links: [
      {
        href: `https://calendar-example.com/calendar/api/v1/${params.locusId}`,
        rel: `self`
      }
    ],
    encryptedNotes: params.body,
    encryptedLocation: params.location,
    encryptedParticipants: [
      {
        id: params.participants.participant1.id,
        type: `PERSON`,
        responseType: `NO_RESPONSE`,
        participantType: `OPTIONAL`,
        orgId: params.participants.participant1.orgId,
        encryptedEmailAddress: params.participants.participant1.emailAddress,
        encryptedName: params.participants.participant1.name
      },
      {
        id: params.participants.participant2.id,
        type: `PERSON`,
        responseType: `UNKNOWN_RESPONSE`,
        participantType: `REQUIRED`,
        orgId: params.participants.participant2.orgId,
        encryptedEmailAddress: params.participants.participant2.emailAddress,
        encryptedName: params.participants.participant2.name
      }
    ]
  };

  return payload;
}

function postToWhistler(spark, type, payload) {
  return retry(() => spark.request({
    method: `POST`,
    service: `whistler`,
    resource: `calendarEvent`,
    body: payload,
    qs: {
      changeType: type,
      useProduction: typeof process.env.WDM_SERVICE_URL === `undefined` || process.env.WDM_SERVICE_URL.includes(`wdm-a.wbx2.com`)
    }
  })
    .then((res) => {
      // Test response is using our parameters
      const createdMeeting = res.body;
      assert.isDefined(createdMeeting);
      assert.equal(createdMeeting.meeting.itemId, payload.id);
      assert.equal(createdMeeting.userUUID, payload.organizer);
      assert.equal(createdMeeting.meeting.startDate, payload.start);
      assert.equal(createdMeeting.meeting.duration, payload.durationMinutes);
      return res;
    }));
}

describe.skip(`plugin-calendar`, () => {
  describe(`Calendar`, () => {
    describe(`#list()`, function() {
      this.timeout(retry.timeout(20000));
      let creator, mccoy, spark, spock;

      before(`create test users`, () => testUsers.create({
        count: 3,
        config: {
          entitlements: [
            `spark`,
            `squaredCallInitiation`,
            `squaredInviter`,
            `squaredRoomModeration`,
            `webExSquared`,
            `squaredFusionCal`
          ]
        }
      })
        .then((users) => {
          [creator, spock, mccoy] = users;

          spark = new CiscoSpark({
            credentials: {
              authorization: creator.token
            },
            config: {
              device: {
                preDiscoveryServices: {
                  whistlerServiceUrl: process.env.WHISTLER_API_SERVICE_URL || `https://calendar-whistler.onint.ciscospark.com:8084/api/v1`
                }
              }
            }
          });
        })
      );

      before(`register to wdm, set features, and connect to mercury`, () => spark.internal.device.register()
        .then(() => spark.internal.feature.setFeature(`developer`, `calsvc_calendar_view`, true))
        .then(() => spark.internal.mercury.connect())
      );

      after(() => spark && spark.internal.mercury.disconnect());

      it(`retrieves the meeting list for the default date range`, () => {
        const hour = 1000 * 60 * 60;
        const startInterval = new Date(new Date().getTime() + hour * 2).toISOString();
        const duration = 60;
        const meetingID = uuid.v4();
        const locusID = uuid.v4();
        const seriesID = uuid.v4();

        const meetingParams = {

          meetingId: meetingID,
          seriesId: seriesID, start: startInterval,
          durationMinutes: duration,
          title: `test-plugin-calendar-meeting-${meetingID}`,
          locusId: locusID,
          hasAttachments: false,
          isRecurring: false,
          organizer: creator,
          participants: {
            participant1: mccoy,
            participant2: spock
          },
          location: `@spark`,
          body: `Test Agenda`
        };

        return postToWhistler(spark, `CREATE`, makeMockMeetingPayload(meetingParams))
          .then((res) => {
            const createdMeeting = res.body;
            return spark.internal.calendar.list()
              .then((meetings) => {
                const testMeeting = meetings.find((meeting) => meeting.seriesId === createdMeeting.meeting.meetingSeriesId);
                assert.isDefined(testMeeting);
                assert.equal(createdMeeting.meeting.meetingSeriesId, testMeeting.seriesId);
                assert.equal(createdMeeting.userUUID, testMeeting.organizer);
                assert.equal(createdMeeting.meeting.startDate, testMeeting.start);
                assert.equal(Math.round((new Date(createdMeeting.meeting.endDate).getTime() - new Date(createdMeeting.meeting.startDate).getTime()) / 60000), testMeeting.durationMinutes);

                // Validate decryption of subject, location and agenda
                assert.isDefined(testMeeting.encryptedSubject);
                assert.equal(meetingParams.title, testMeeting.encryptedSubject);
                assert.isDefined(testMeeting.encryptedLocation);
                assert.equal(meetingParams.location, testMeeting.encryptedLocation);
                assert.isDefined(testMeeting.encryptedNotes);
                assert.equal(meetingParams.body, testMeeting.encryptedNotes);
                assert.isDefined(testMeeting.encryptedParticipants);
                const encryptedParticipant1 = testMeeting.encryptedParticipants
                  .find((participant) => participant.id === meetingParams.participants.participant1.id);
                const encryptedParticipant2 = testMeeting.encryptedParticipants
                  .find((participant) => participant.id === meetingParams.participants.participant2.id);
                assert.equal(meetingParams.participants.participant1.emailAddress, encryptedParticipant1.encryptedEmailAddress);
                assert.equal(meetingParams.participants.participant1.name, encryptedParticipant1.encryptedName);
                assert.equal(meetingParams.participants.participant2.emailAddress, encryptedParticipant2.encryptedEmailAddress);
                assert.equal(meetingParams.participants.participant2.name, encryptedParticipant2.encryptedName);
              });
          });
      });

      it(`receives a mercury event for a new meeting`, () => {
        const hour = 1000 * 60 * 60;
        const startInterval = new Date(new Date().getTime() + hour * 2).toISOString();
        const duration = 60;
        const meetingID = uuid.v4();
        const locusID = uuid.v4();
        const seriesID = uuid.v4();

        const meetingParams = {

          meetingId: meetingID,
          seriesId: seriesID, start: startInterval,
          durationMinutes: duration,
          title: `test-plugin-calendar-meeting-${meetingID}`,
          locusId: locusID,
          hasAttachments: false,
          isRecurring: false,
          organizer: creator,
          participants: {
            participant1: mccoy,
            participant2: spock
          },
          location: `@spark`,
          body: `Test Agenda`
        };

        const mercuryPromise = new Promise((resolve) => {
          spark.internal.mercury.on(`event:calendar.meeting.create`, (event) => {
            resolve(event.data.calendarMeetingExternal);
          });
        });

        return postToWhistler(spark, `CREATE`, makeMockMeetingPayload(meetingParams))
          .then((res) => {
            const createdMeeting = res.body;
            return mercuryPromise
              .then((calendarMeetingExternal) => {
                assert.equal(createdMeeting.meeting.meetingSeriesId, calendarMeetingExternal.seriesId);
                assert.equal(createdMeeting.userUUID, calendarMeetingExternal.organizer);
                assert.equal(createdMeeting.meeting.startDate, calendarMeetingExternal.start);
                assert.equal(Math.round((new Date(createdMeeting.meeting.endDate).getTime() - new Date(createdMeeting.meeting.startDate).getTime()) / 60000), calendarMeetingExternal.durationMinutes);

                // Validate decryption of subject, location and agenda
                assert.isDefined(calendarMeetingExternal.encryptedSubject);
                assert.equal(meetingParams.title, calendarMeetingExternal.encryptedSubject);
                assert.isDefined(calendarMeetingExternal.encryptedLocation);
                assert.equal(meetingParams.location, calendarMeetingExternal.encryptedLocation);
                assert.isDefined(calendarMeetingExternal.encryptedNotes);
                assert.equal(meetingParams.body, calendarMeetingExternal.encryptedNotes);
                assert.isDefined(calendarMeetingExternal.encryptedParticipants);
                const encryptedParticipant1 = calendarMeetingExternal.encryptedParticipants
                  .find((participant) => participant.id === meetingParams.participants.participant1.id);
                const encryptedParticipant2 = calendarMeetingExternal.encryptedParticipants
                  .find((participant) => participant.id === meetingParams.participants.participant2.id);
                assert.equal(meetingParams.participants.participant1.emailAddress, encryptedParticipant1.encryptedEmailAddress);
                assert.equal(meetingParams.participants.participant1.name, encryptedParticipant1.encryptedName);
                assert.equal(meetingParams.participants.participant2.emailAddress, encryptedParticipant2.encryptedEmailAddress);
                assert.equal(meetingParams.participants.participant2.name, encryptedParticipant2.encryptedName);
              });
          });
      });
    });
  });
});
