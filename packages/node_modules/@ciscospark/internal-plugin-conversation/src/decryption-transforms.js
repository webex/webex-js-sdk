/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {
  curry
} from 'lodash';
import S from 'string';

import toArray from './to-array';

const decryptTextProp = curry((name, ctx, key, object) => ctx.transform(`decryptTextProp`, name, key, object));

// eslint-disable-next-line import/prefer-default-export
export const transforms = toArray(`inbound`, {
  decryptObject(ctx, key, object) {
    if (!object) {
      object = key;
      key = undefined;
    }

    if (!object) {
      return Promise.resolve();
    }

    if (!object.objectType) {
      return Promise.resolve();
    }

    if (!key && object.encryptionKeyUrl) {
      key = object.encryptionKeyUrl;
    }

    // Transcoded content was not showing up on the activities since the
    // decryptFile was not being called. Calling decryptFile for
    // transcodedContent fixes the issue.
    if (object.objectType === `transcodedContent`) {
      return Promise.all(object.files.items.map((item) => ctx.transform(`decryptFile`, key, item)));
    }

    return ctx.transform(`decrypt${S(object.objectType).capitalize().s}`, key, object);
  },

  decryptConversation(ctx, key, conversation) {
    const promises = [];
    if (conversation.activities.items) {
      promises.push(Promise.all(conversation.activities.items.map((item) => ctx.transform(`decryptObject`, null, item))));
    }

    const usableKey = conversation.encryptionKeyUrl || key;
    const decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;

    if (usableKey) {
      promises.push(ctx.transform(`decryptPropDisplayName`, usableKey, conversation)
        .catch((error) => {
          ctx.spark.logger.warn(`plugin-conversation: failed to decrypt display name of `, conversation.url, error);
          Promise.resolve(decryptionFailureMessage);
        })
      );
      promises.push(ctx.transform(`decryptPropContent`, usableKey, conversation));
    }
    if (conversation.avatarEncryptionKeyUrl) {
      promises.push(ctx.transform(`decryptObject`, conversation.avatarEncryptionKeyUrl, conversation.avatar));
    }

    return Promise.all(promises);
  },

  decryptActivity(ctx, key, activity) {
    if (!activity.encryptionKeyUrl && !(activity.object && activity.object.encryptionKeyUrl)) {
      return Promise.resolve(activity);
    }

    const keyUrl = activity.encryptionKeyUrl || activity.object.encryptionKeyUrl || key;
    return ctx.transform(`decryptObject`, keyUrl, activity.object);
  },

  decryptComment(ctx, key, comment) {
    return Promise.all([
      ctx.transform(`decryptPropDisplayName`, key, comment),
      ctx.transform(`decryptPropContent`, key, comment)
    ]);
  },

  decryptContent(ctx, key, content) {
    const promises = content.files.items.map((item) => ctx.transform(`decryptObject`, key, item));
    promises.push(ctx.transform(`decryptComment`, key, content));

    return Promise.all(promises);
  },

  decryptEvent(ctx, key, event) {
    const promises = [
      ctx.transform(`decryptPropDisplayName`, key, event)
    ];

    if (event.location && event.location.split(`.`).length === 5) {
      promises.push(ctx.transform(`decryptPropLocation`, key, event));
    }

    return Promise.all(promises);
  },

  decryptFile(ctx, key, file) {
    return Promise.all([
      file.transcodedCollection && Promise.all(file.transcodedCollection.items.map((item) => ctx.transform(`decryptObject`, key, item))),
      ctx.transform(`decryptPropScr`, key, file),
      ctx.transform(`decryptPropDisplayName`, key, file),
      ctx.transform(`decryptPropContent`, key, file),
      file.image && ctx.transform(`decryptPropScr`, key, file.image)
    ]);
  },

  decryptTranscodedContent(ctx, key, transcodedContent) {
    return Promise.all(transcodedContent.files.items.map((item) => ctx.transform(`decryptFile`, key, item)));
  },

  // TODO is this used for anything other than the now-removed stickies service?
  decryptImageURI(ctx, key, imageURI) {
    return ctx.transform(`decryptPropLocation`, key, imageURI);
  },

  decryptTextProp(ctx, name, key, object) {
    if (!object[name]) {
      return Promise.resolve();
    }
    const decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;

    return ctx.spark.internal.encryption.decryptText(key, object[name])
      .then((plaintext) => {
        if (ctx.spark.config.conversation.keepEncryptedProperties) {
          const encryptedPropName = S(`encrypted_${name}`).camelize().s;
          object[encryptedPropName] = object[name];
        }

        object[name] = plaintext;
      })
      .catch((reason) => {
        ctx.spark.logger.warn(`plugin-conversation: failed to decrypt ${name} `, reason);
        object[name] = decryptionFailureMessage;
        return Promise.resolve(decryptionFailureMessage);
      });
  },

  decryptPropDisplayName: decryptTextProp(`displayName`),

  decryptPropContent: decryptTextProp(`content`),

  decryptPropScr(ctx, key, object) {
    return ctx.spark.internal.encryption.decryptScr(key, object.scr)
      .then((scr) => {
        object.scr = scr;
      });
  },
  decryptPropLocation: decryptTextProp(`location`)
});
