/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {camelCase, capitalize, curry} from 'lodash';
import toArray from './to-array';

const decryptTextProp = curry((name, ctx, key, object) => ctx.transform('decryptTextProp', name, key, object));

// eslint-disable-next-line import/prefer-default-export
export const transforms = toArray('inbound', {
  decryptObject(ctx, key, object) {
    if (!object) {
      object = key;
      key = undefined;
    }

    if (!object) {
      return Promise.resolve();
    }

    if (!object.objectType) {
      return Promise.resolve();
    }

    if (!key && object.encryptionKeyUrl) {
      key = object.encryptionKeyUrl;
    }

    // Transcoded content was not showing up on the activities since the
    // decryptFile was not being called. Calling decryptFile for
    // transcodedContent fixes the issue.
    if (object.objectType === 'transcodedContent') {
      return Promise.all(object.files.items.map((item) => ctx.transform('decryptFile', key, item)));
    }

    return ctx.transform(`decrypt${capitalize(object.objectType)}`, key, object);
  },

  decryptConversation(ctx, key, conversation) {
    const promises = [];
    if (conversation.activities.items) {
      promises.push(Promise.all(conversation.activities.items.map((item) => ctx.transform('decryptObject', null, item))));
    }

    const usableKey = conversation.encryptionKeyUrl || key;
    const decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;

    if (usableKey) {
      promises.push(ctx.transform('decryptPropDisplayName', usableKey, conversation)
        .catch((error) => {
          ctx.spark.logger.warn('plugin-conversation: failed to decrypt display name of ', conversation.url, error);
          Promise.resolve(decryptionFailureMessage);
        }));
      promises.push(ctx.transform('decryptPropContent', usableKey, conversation));
    }
    if (conversation.avatarEncryptionKeyUrl) {
      promises.push(ctx.transform('decryptObject', conversation.avatarEncryptionKeyUrl, conversation.avatar));
    }

    return Promise.all(promises);
  },

  decryptActivity(ctx, key, activity) {
    if (!activity.encryptionKeyUrl && !(activity.object && activity.object.encryptionKeyUrl)) {
      return Promise.resolve(activity);
    }

    const keyUrl = activity.encryptionKeyUrl || activity.object.encryptionKeyUrl || key;
    return ctx.transform('decryptObject', keyUrl, activity.object);
  },

  decryptComment(ctx, key, comment) {
    return Promise.all([
      ctx.transform('decryptPropDisplayName', key, comment),
      ctx.transform('decryptPropContent', key, comment)
    ]);
  },

  decryptContent(ctx, key, content) {
    const promises = content.files.items.map((item) => ctx.transform('decryptObject', key, item));
    promises.push(ctx.transform('decryptComment', key, content));

    return Promise.all(promises);
  },

  decryptEvent(ctx, key, event) {
    const promises = [
      ctx.transform('decryptPropDisplayName', key, event)
    ];

    if (event.location && event.location.split('.').length === 5) {
      promises.push(ctx.transform('decryptPropLocation', key, event));
    }

    return Promise.all(promises);
  },

  decryptFile(ctx, key, file) {
    return Promise.all([
      file.transcodedCollection && Promise.all(file.transcodedCollection.items.map((item) => ctx.transform('decryptObject', key, item))),
      ctx.transform('decryptPropScr', key, file),
      ctx.transform('decryptPropDisplayName', key, file),
      ctx.transform('decryptPropContent', key, file),
      file.image && ctx.transform('decryptPropScr', key, file.image)
    ]);
  },

  decryptTranscodedContent(ctx, key, transcodedContent) {
    return Promise.all(transcodedContent.files.items.map((item) => ctx.transform('decryptFile', key, item)));
  },

  // TODO is this used for anything other than the now-removed stickies service?
  decryptImageURI(ctx, key, imageURI) {
    return ctx.transform('decryptPropLocation', key, imageURI);
  },

  decryptTextProp(ctx, name, key, object) {
    if (!object[name]) {
      return Promise.resolve();
    }
    const decryptionFailureMessage = ctx.spark.internal.conversation.config.decryptionFailureMessage;

    return ctx.spark.internal.encryption.decryptText(key, object[name])
      .then((plaintext) => {
        if (ctx.spark.config.conversation.keepEncryptedProperties) {
          const encryptedPropName = camelCase(`encrypted_${name}`);
          object[encryptedPropName] = object[name];
        }

        object[name] = plaintext;
      })
      .catch((reason) => {
        ctx.spark.logger.warn(`plugin-conversation: failed to decrypt ${name} `, reason);
        object[name] = decryptionFailureMessage;
        return Promise.resolve(decryptionFailureMessage);
      });
  },

  decryptPropDisplayName: decryptTextProp('displayName'),

  decryptPropContent: decryptTextProp('content'),

  decryptPropScr(ctx, key, object) {
    return ctx.spark.internal.encryption.decryptScr(key, object.scr)
      .then((scr) => {
        object.scr = scr;
      });
  },
  decryptPropLocation: decryptTextProp('location')
});
