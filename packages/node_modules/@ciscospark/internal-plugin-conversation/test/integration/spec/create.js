/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {InvalidUserCreation} from '@ciscospark/internal-plugin-conversation';

import {patterns} from '@ciscospark/common';
import CiscoSpark, {SparkHttpError} from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import testUsers from '@ciscospark/test-helper-test-users';
import {find, last, map} from 'lodash';
import uuid from 'uuid';
import fh from '@ciscospark/test-helper-file';

describe(`plugin-conversation`, function() {
  this.timeout(60000);
  describe(`#create()`, () => {
    let checkov, kirk, mccoy, participants, spark, spock;

    before(() => testUsers.create({count: 4})
      .then((users) => {
        [spock, mccoy, checkov, kirk] = users;
        participants = [spock, mccoy, checkov];

        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return Promise.all([
          spark.internal.mercury.connect(),
          mccoy.spark.internal.mercury.connect()
        ]);
      }));

    let sampleTextOne = `sample-text-one.txt`;
    before(() => fh.fetch(sampleTextOne)
      .then((f) => {sampleTextOne = f;}));

    after(() => Promise.all([
      spark && spark.internal.mercury.disconnect(),
      mccoy && mccoy.spark.internal.mercury.disconnect()
    ]));

    function makeEmailAddress() {
      return `spark-js-sdk--test-${uuid.v4()}@example.com`;
    }

    describe(`when there is only one other participant`, () => {
      it(`creates a 1:1 conversation`, () => spark.internal.conversation.create({participants: [mccoy]})
        .then((conversation) => {
          assert.isConversation(conversation);
          assert.isOneOnOneConversation(conversation);
          assert.isNewEncryptedConversation(conversation);

          assert.lengthOf(conversation.participants.items, 2);
          assert.lengthOf(conversation.activities.items, 1);
        }));

      describe(`when the other user doesn't exist`, () => {
        let email;
        beforeEach(() => {email = makeEmailAddress();});

        it(`invites the other user`, () => spark.internal.conversation.create({participants: [email]})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isOneOnOneConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            const participant = find(conversation.participants.items, {emailAddress: email});
            assert.include(participant.tags, `SIDE_BOARDED`);
            assert.match(participant.id, patterns.uuid);
          }));
      });

      describe(`when the conversation already exists`, () => {
        describe(`with skipOneOnOneFetch=true`, () => {
          it(`fails to create a 1:1 conversation that already exists`, () => assert.isRejected(spark.internal.conversation.create({participants: [mccoy]}, {skipOneOnOneFetch: true}))
            .then((reason) => assert.instanceOf(reason, SparkHttpError.Conflict)));
        });

        it(`returns the preexisting conversation`, () => spark.internal.conversation.create({participants: [checkov]})
          .then((conversation) => spark.internal.conversation.create({participants: [checkov]})
            .then((conversation2) => {
              assert.equal(conversation2.url, conversation.url);
              assert.lengthOf(conversation.activities.items, 1);
              assert.equal(conversation.activities.items[0].verb, `create`);
            })));

        it(`returns the preexisting conversation and posts a comment`, () => spark.internal.conversation.create({participants: [checkov], comment: `hi`})
          .then((conversation) => spark.internal.conversation.create({participants: [checkov]})
            .then((conversation2) => {
              assert.equal(conversation2.url, conversation.url);
              assert.lengthOf(conversation.activities.items, 1);
              assert.equal(conversation.activities.items[0].verb, `post`);
              assert.equal(conversation.activities.items[0].object.displayName, `hi`);
            })));
      });

      describe(`when {forceGrouped: true} is specified`, () => {
        it(`creates a grouped conversation @canary`, () => spark.internal.conversation.create({participants: [mccoy]}, {forceGrouped: true})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));
      });
    });

    describe(`when there is an invalid user in the participants list`, () => {

      describe(`with allowPartialCreation`, () => {
        it(`creates a group conversation`, () => spark.internal.conversation.create({participants: [mccoy, `invalidUser`]}, {allowPartialCreation: true})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));

        it(`creates a group conversation with invalid uuid`, () => testUsers.remove([kirk])
          .then(() => spark.internal.conversation.create({participants: [mccoy.id, kirk.id]}, {allowPartialCreation: true}))
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));

        it(`fails to create a 1:1 conversation`, () => assert.isRejected(spark.internal.conversation.create({participants: [`invalidUser`]}, {allowPartialCreation: true}))
          .then((reason) => assert.instanceOf(reason, InvalidUserCreation)));
      });

      describe(`without allowPartialCreation`, () => {
        it(`fails to create a group conversation without allowPartialCreation param`, () => assert.isRejected(spark.internal.conversation.create({participants: [mccoy, `invalidUser`]})));
      });

    });

    describe(`when {compact: ?} is not specified`, () => {
      it(`creates a compact conversation`, () => spark.internal.conversation.create({participants})
        .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 5}))
        .then((c) => assert.lengthOf(c.activities.items, 1)));
    });

    it(`creates a conversation with a name`, () => spark.internal.conversation.create({displayName: `displayName`, participants})
      .then((c) => spark.internal.conversation.get(c))
      .then((c) => assert.equal(c.displayName, `displayName`)));

    it(`creates a conversation with a comment`, () => spark.internal.conversation.create({comment: `comment`, participants})
      .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 2}))
      .then((c) => assert.equal(c.activities.items[1].object.displayName, `comment`)));

    it(`creates a conversation with a share`, () => spark.internal.conversation.create({participants, files: [sampleTextOne]})
      .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 10}))
      .then((c) => {
        assert.equal(last(c.activities.items).verb, `share`);
        return spark.internal.conversation.download(last(c.activities.items).object.files.items[0]);
      })
      .then((file) => fh.isMatchingFile(file, sampleTextOne)));

    it(`ensures the current user is in the participants list`, () => spark.internal.conversation.create({comment: `comment`, participants: [mccoy, checkov]})
      .then((c) => spark.internal.conversation.get(c, {includeParticipants: true}))
      .then((c) => assert.include(map(c.participants.items, `id`), spock.id)));

    it(`does not allow me to create a conversation with zero participants`, () => assert.isRejected(spark.internal.conversation.create({participants: []}, /`params.participants` is required/)));
  });
});
