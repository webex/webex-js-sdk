/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {InvalidUserCreation} from '@ciscospark/internal-plugin-conversation';
import {patterns} from '@ciscospark/common';
import CiscoSpark, {SparkHttpError} from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import testUsers from '@ciscospark/test-helper-test-users';
import {find, last, map} from 'lodash';
import uuid from 'uuid';
import fh from '@ciscospark/test-helper-file';

describe('plugin-conversation', function () {
  this.timeout(60000);
  describe('#create()', () => {
    let checkov, kirk, mccoy, participants, spark, spock;

    before(() => testUsers.create({count: 4})
      .then((users) => {
        [spock, mccoy, checkov, kirk] = users;
        participants = [spock, mccoy, checkov];

        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        spark.config.conversation.allowedOutboundTags = {
          strong: []
        };
        spark.config.conversation.allowedInboundTags = {
          strong: []
        };

        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return Promise.all([
          spark.internal.mercury.connect(),
          mccoy.spark.internal.mercury.connect()
        ]);
      }));

    let sampleTextOne = 'sample-text-one.txt';
    before(() => fh.fetch(sampleTextOne)
      .then((f) => { sampleTextOne = f; }));

    after(() => Promise.all([
      spark && spark.internal.mercury.disconnect(),
      mccoy && mccoy.spark.internal.mercury.disconnect()
    ]));

    function makeEmailAddress() {
      return `spark-js-sdk--test-${uuid.v4()}@example.com`;
    }

    describe('when there is only one other participant', () => {
      it('creates a 1:1 conversation', () => spark.internal.conversation.create({participants: [mccoy]})
        .then((conversation) => {
          assert.isConversation(conversation);
          assert.isOneOnOneConversation(conversation);
          assert.isNewEncryptedConversation(conversation);

          assert.lengthOf(conversation.participants.items, 2);
          assert.lengthOf(conversation.activities.items, 1);
        }));

      describe('when the other user doesn\'t exist', () => {
        let email;
        beforeEach(() => { email = makeEmailAddress(); });

        it('invites the other user', () => spark.internal.conversation.create({participants: [email]})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isOneOnOneConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            const participant = find(conversation.participants.items, {emailAddress: email});
            assert.include(participant.tags, 'SIDE_BOARDED');
            assert.match(participant.id, patterns.uuid);
          }));
      });

      describe('when the conversation already exists', () => {
        describe('with skipOneOnOneFetch=true', () => {
          it('fails to create a 1:1 conversation that already exists', () => assert.isRejected(spark.internal.conversation.create({participants: [mccoy]}, {skipOneOnOneFetch: true}))
            .then((reason) => assert.instanceOf(reason, SparkHttpError.Conflict)));
        });

        it('returns the preexisting conversation', () => spark.internal.conversation.create({participants: [checkov]})
          .then((conversation) => spark.internal.conversation.create({participants: [checkov]})
            .then((conversation2) => {
              assert.equal(conversation2.url, conversation.url);
              assert.lengthOf(conversation.activities.items, 1);
              assert.equal(conversation.activities.items[0].verb, 'create');
            })));

        it('returns the preexisting conversation and posts a comment', () => spark.internal.conversation.create({participants: [checkov], comment: 'hi'})
          .then((conversation) => spark.internal.conversation.create({participants: [checkov]})
            .then((conversation2) => {
              assert.equal(conversation2.url, conversation.url);
              assert.lengthOf(conversation.activities.items, 1);
              assert.equal(conversation.activities.items[0].verb, 'post');
              assert.equal(conversation.activities.items[0].object.displayName, 'hi');
            })));

        it('returns the preexisting conversation and posts a comment with html', () => spark.internal.conversation.create({participants: [checkov], comment: '**hi**', html: '<strong>hi</strong>'})
          .then((conversation) => spark.internal.conversation.create({participants: [checkov]})
            .then((conversation2) => {
              assert.equal(conversation2.url, conversation.url);
              assert.lengthOf(conversation.activities.items, 1);
              assert.equal(conversation.activities.items[0].verb, 'post');
              assert.equal(conversation.activities.items[0].object.displayName, '**hi**');
              assert.equal(conversation.activities.items[0].object.content, '<strong>hi</strong>');
            })));
      });

      describe('when {forceGrouped: true} is specified', () => {
        it('creates a grouped conversation @canary', () => spark.internal.conversation.create({participants: [mccoy]}, {forceGrouped: true})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));
      });
    });

    describe('when there is an invalid user in the participants list', () => {
      describe('with allowPartialCreation', () => {
        it('creates a group conversation', () => spark.internal.conversation.create({participants: [mccoy, 'invalidUser']}, {allowPartialCreation: true})
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));

        it('creates a group conversation with invalid uuid', () => testUsers.remove([kirk])
          .then(() => spark.internal.conversation.create({participants: [mccoy.id, kirk.id]}, {allowPartialCreation: true}))
          .then((conversation) => {
            assert.isConversation(conversation);
            assert.isGroupConversation(conversation);
            assert.isNewEncryptedConversation(conversation);

            assert.lengthOf(conversation.participants.items, 2);
            assert.lengthOf(conversation.activities.items, 1);
          }));

        it('fails to create a 1:1 conversation', () => assert.isRejected(spark.internal.conversation.create({participants: ['invalidUser']}, {allowPartialCreation: true}))
          .then((reason) => assert.instanceOf(reason, InvalidUserCreation)));
      });

      describe('without allowPartialCreation', () => {
        it('fails to create a group conversation without allowPartialCreation param', () => assert.isRejected(spark.internal.conversation.create({participants: [mccoy, 'invalidUser']})));
      });
    });

    describe('when {compact: ?} is not specified', () => {
      it('creates a compact conversation', () => spark.internal.conversation.create({participants})
        .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 5}))
        .then((c) => assert.lengthOf(c.activities.items, 1)));
    });

    it('creates a conversation with a name', () => spark.internal.conversation.create({displayName: 'displayName', participants})
      .then((c) => spark.internal.conversation.get(c))
      .then((c) => assert.equal(c.displayName, 'displayName')));

    it('creates a conversation with a comment', () => spark.internal.conversation.create({comment: 'comment', participants})
      .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 2}))
      .then((c) => assert.equal(c.activities.items[1].object.displayName, 'comment')));

    it('creates a conversation with a comment with html', () => spark.internal.conversation.create({comment: '**comment**', html: '<strong>comment</strong>', participants})
      .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 2}))
      .then((c) => {
        assert.equal(c.activities.items[1].object.displayName, '**comment**');
        assert.equal(c.activities.items[1].object.content, '<strong>comment</strong>');
      }));

    it('creates a conversation with a share', () => spark.internal.conversation.create({participants, files: [sampleTextOne]})
      .then((c) => spark.internal.conversation.get(c, {activitiesLimit: 10}))
      .then((c) => {
        assert.equal(last(c.activities.items).verb, 'share');
        return spark.internal.conversation.download(last(c.activities.items).object.files.items[0]);
      })
      .then((file) => fh.isMatchingFile(file, sampleTextOne)));

    it('ensures the current user is in the participants list', () => spark.internal.conversation.create({comment: 'comment', participants: [mccoy, checkov]})
      .then((c) => spark.internal.conversation.get(c, {includeParticipants: true}))
      .then((c) => assert.include(map(c.participants.items, 'id'), spock.id)));

    it('does not allow me to create a conversation with zero participants', () => assert.isRejected(spark.internal.conversation.create({participants: []}, /`params.participants` is required/)));
  });
});
