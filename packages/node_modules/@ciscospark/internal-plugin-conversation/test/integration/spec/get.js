/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-conversation';

import CiscoSpark from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import testUsers from '@ciscospark/test-helper-test-users';
import fh from '@ciscospark/test-helper-file';
import makeLocalUrl from '@ciscospark/test-helper-make-local-url';
import {map} from 'lodash';
import retry from '@ciscospark/test-helper-retry';

describe(`plugin-conversation`, function() {
  this.timeout(120000);

  describe(`when fetching conversations`, () => {

    let kirk, mccoy, participants, scott, spark, spock;

    before(`create tests users and connect one to mercury`, () => testUsers.create({count: 4})
      .then((users) => {
        [spock, mccoy, kirk, scott] = users;
        participants = [spock, mccoy, kirk];

        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        return spark.internal.mercury.connect();
      }));

    after(() => spark && spark.internal.mercury.disconnect());

    describe(`#download()`, () => {
      let sampleImageSmallOnePng = `sample-image-small-one.png`;

      let conversation;
      before(`create conversation`, () => spark.internal.conversation.create({participants})
        .then((c) => {conversation = c;}));

      before(`fetch image fixture`, () => fh.fetch(sampleImageSmallOnePng)
        .then((res) => {sampleImageSmallOnePng = res;}));

      it(`downloads and decrypts an encrypted file`, () => spark.internal.conversation.share(conversation, [sampleImageSmallOnePng])
        .then((activity) => spark.internal.conversation.download(activity.object.files.items[0]))
        .then((f) => assert.eventually.isTrue(fh.isMatchingFile(f, sampleImageSmallOnePng))));

      it(`emits download progress events for encrypted files`, () => spark.internal.conversation.share(conversation, [sampleImageSmallOnePng])
        .then((activity) => {
          const spy = sinon.spy();
          return spark.internal.conversation.download(activity.object.files.items[0])
            .on(`progress`, spy)
            .then(() => assert.called(spy));
        }));

      it(`downloads and decrypts a non-encrypted file`, () => spark.internal.conversation.download({url: makeLocalUrl(`/sample-image-small-one.png`)})
        .then((f) => assert.eventually.isTrue(fh.isMatchingFile(f, sampleImageSmallOnePng))));

      it(`emits download progress events for non-encrypted files`, () => {
        const spy = sinon.spy();
        return spark.internal.conversation.download({url: makeLocalUrl(`/sample-image-small-one.png`)})
          .on(`progress`, spy)
          .then((f) => assert.eventually.isTrue(fh.isMatchingFile(f, sampleImageSmallOnePng)))
          .then(() => assert.called(spy));
      });
    });

    describe(`#get()`, () => {
      let conversation, conversation2;

      before(`create conversations`, () => Promise.all([
        spark.internal.conversation.create({participants: [mccoy.id]})
          .then((c) => {conversation = c;}),
        spark.internal.conversation.create({participants: [scott.id]})
          .then((c) => {conversation2 = c;})
      ]));

      it(`retrieves a single conversation by url`, () => spark.internal.conversation.get({url: conversation.url})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it(`retrieves a single conversation by id`, () => spark.internal.conversation.get({id: conversation.id})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it(`retrieves a 1:1 conversation by userId`, () => spark.internal.conversation.get({user: mccoy})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it(`retrieves a 1:1 conversation with a deleted user`, () => spark.internal.conversation.get({user: scott})
        .then((c) => {
          assert.equal(c.id, conversation2.id);
          assert.equal(c.url, conversation2.url);
        })
        .then(() => testUsers.remove([scott]))
        // add retries to address CI propagation delay
        .then(() => retry(() => assert.isRejected(spark.internal.conversation.get({user: scott}))))
        .then(() => retry(() => spark.internal.conversation.get({user: scott}, {includeConvWithDeletedUserUUID: true})))
        .then((c) => {
          assert.equal(c.id, conversation2.id);
          assert.equal(c.url, conversation2.url);
        }));

      it(`decrypts the contents of activities in the retrieved conversation`, () => spark.internal.conversation.post(conversation, {
        displayName: `Test Message`
      })
        .then(() => spark.internal.conversation.get({url: conversation.url}, {activitiesLimit: 50}))
        .then((c) => {
          const posts = c.activities.items.filter((activity) => activity.verb === `post`);
          assert.lengthOf(posts, 1);
          assert.equal(posts[0].object.displayName, `Test Message`);
        }));
    });

    describe(`#list()`, () => {
      let conversation1, conversation2;

      before(`create conversations`, () => Promise.all([
        spark.internal.conversation.create({
          displayName: `test 1`,
          participants
        })
          .then((c) => {conversation1 = c;}),
        spark.internal.conversation.create({
          displayName: `test 2`,
          participants
        })
          .then((c) => {conversation2 = c;})
      ]));

      it(`retrieves a set of conversations`, () => spark.internal.conversation.list({
        conversationsLimit: 2
      })
        .then((conversations) => {
          assert.include(map(conversations, `url`), conversation1.url);
          assert.include(map(conversations, `url`), conversation2.url);
        }));

      describe(`with deferDecrypt = true`, () => {
        it(`retrieves a non-decrypted set of conversations each with a bound decrypt method`, () => spark.internal.conversation.list({
          conversationsLimit: 2,
          deferDecrypt: true
        })
          .then(([c1, c2]) => {
            assert.lengthOf(c1.displayName.split(`.`), 5, `5 periods implies this is a jwt and not a decrypted string`);
            assert.notInclude([`test 1, test 2`], c1.displayName);

            assert.lengthOf(c2.displayName.split(`.`), 5, `5 periods implies this is a jwt and not a decrypted string`);
            assert.notInclude([`test 1, test 2`], c2.displayName);

            return Promise.all([
              c1.decrypt()
                .then(() => assert.notInclude([`test 1, test 2`], c1.displayName)),
              c2.decrypt()
                .then(() => assert.notInclude([`test 1, test 2`], c2.displayName))
            ]);
          }));
      });
    });

    describe(`#listLeft()`, () => {
      let conversation;
      before(`create conversation`, () => spark.internal.conversation.create({participants})
        .then((c) => {conversation = c;}));

      it(`retrieves the conversations the current user has left`, () => spark.internal.conversation.listLeft()
        .then((c) => {
          assert.lengthOf(c, 0);
          return spark.internal.conversation.leave(conversation);
        })
        .then(() => spark.internal.conversation.listLeft())
        .then((c) => {
          assert.lengthOf(c, 1);
          assert.equal(c[0].url, conversation.url);
        }));
    });

    describe(`#listActivities()`, () => {
      let conversation;
      before(`create conversation with activity`, () => spark.internal.conversation.create({participants})
        .then((c) => {
          conversation = c;
          assert.lengthOf(conversation.participants.items, 3);
          return spark.internal.conversation.post(conversation, {displayName: `first message`});
        }));

      it(`retrieves activities for the specified conversation`, () => spark.internal.conversation.listActivities({conversationId: conversation.id})
        .then((activities) => {
          assert.isArray(activities);
          assert.lengthOf(activities, 2);
        }));
    });

    describe(`#listMentions()`, () => {
      let spark2;

      before(`connect mccoy to mercury`, () => {
        spark2 = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return spark2.internal.mercury.connect();
      });

      after(() => spark2 && spark2.internal.mercury.disconnect());

      let conversation;
      before(`create conversation`, () => spark.internal.conversation.create({participants})
        .then((c) => {
          conversation = c;
          assert.lengthOf(conversation.participants.items, 3);
        }));

      it(`retrieves activities in which the current user was mentioned`, () => spark2.internal.conversation.post(conversation, {
        displayName: `Green blooded hobgloblin`,
        content: `<spark-mention data-object-type="person" data-object-id="${spock.id}">Green blooded hobgloblin</spark-mention>`,
        mentions: {
          items: [{
            id: `${spock.id}`,
            objectType: `person`
          }]
        }
      })
        .then((activity) => spark.internal.conversation.listMentions({sinceDate: Date.parse(activity.published) - 1})
          .then((mentions) => {
            assert.lengthOf(mentions, 1);
            assert.equal(mentions[0].url, activity.url);
          })));
    });
  });

});
