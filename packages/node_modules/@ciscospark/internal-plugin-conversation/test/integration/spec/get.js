/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-conversation';

import CiscoSpark from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import testUsers from '@ciscospark/test-helper-test-users';
import fh from '@ciscospark/test-helper-file';
import makeLocalUrl from '@ciscospark/test-helper-make-local-url';
import {map} from 'lodash';
import retry from '@ciscospark/test-helper-retry';

describe('plugin-conversation', function () {
  this.timeout(120000);

  describe('when fetching conversations', () => {
    let kirk, mccoy, participants, scott, spark, spock;

    before('create tests users and connect one to mercury', () => testUsers.create({count: 4})
      .then((users) => {
        [spock, mccoy, kirk, scott] = users;
        participants = [spock, mccoy, kirk];

        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        return spark.internal.mercury.connect();
      }));

    after(() => spark && spark.internal.mercury.disconnect());

    describe('#download()', () => {
      let sampleImageSmallOnePng = 'sample-image-small-one.png';

      let conversation, conversationRequestSpy;
      before('create conversation', () => spark.internal.conversation.create({participants})
        .then((c) => { conversation = c; }));

      before('fetch image fixture', () => fh.fetch(sampleImageSmallOnePng)
        .then((res) => { sampleImageSmallOnePng = res; }));

      beforeEach(() => {
        conversationRequestSpy = sinon.spy(spark.internal.conversation, 'request');
      });

      afterEach(() => conversationRequestSpy.restore());

      it('downloads and decrypts an encrypted file', () => spark.internal.conversation.share(conversation, [sampleImageSmallOnePng])
        .then((activity) => spark.internal.conversation.download(activity.object.files.items[0]))
        .then((f) => fh.isMatchingFile(f, sampleImageSmallOnePng)
          .then((result) => assert.isTrue(result))));

      it('emits download progress events for encrypted files', () => spark.internal.conversation.share(conversation, [sampleImageSmallOnePng])
        .then((activity) => {
          const spy = sinon.spy();
          return spark.internal.conversation.download(activity.object.files.items[0])
            .on('progress', spy)
            .then(() => assert.called(spy));
        }));

      it('downloads and decrypts a file without a scr key', () => spark.internal.conversation.download({
        scr: {
          loc: makeLocalUrl('/sample-image-small-one.png')
        }
      })
        .then((f) => fh.isMatchingFile(f, sampleImageSmallOnePng)
          .then((result) => assert.isTrue(result)))
        .then(() => conversationRequestSpy.returnValues[0]
          .then((res) => {
            assert.property(res.options.headers, 'cisco-no-http-redirect');
            assert.property(res.options.headers, 'spark-user-agent');
            assert.property(res.options.headers, 'trackingid');
          })));

      it('downloads and decrypts a non-encrypted file', () => spark.internal.conversation.download({url: makeLocalUrl('/sample-image-small-one.png')})
        .then((f) => fh.isMatchingFile(f, sampleImageSmallOnePng)
          .then((result) => assert.isTrue(result)))
        .then(() => conversationRequestSpy.returnValues[0]
          .then((res) => {
            assert.property(res.options.headers, 'cisco-no-http-redirect');
            assert.property(res.options.headers, 'spark-user-agent');
            assert.property(res.options.headers, 'trackingid');
          })));

      it('downloads non-encrypted file with specific options headers', () => spark.internal.conversation.download({url: makeLocalUrl('/sample-image-small-one.png')}, {
        headers: {
          'cisco-no-http-redirect': null,
          'spark-user-agent': null,
          trackingid: null
        }
      })
        .then((f) => fh.isMatchingFile(f, sampleImageSmallOnePng)
          .then((result) => assert.isTrue(result)))
        .then(() => conversationRequestSpy.returnValues[0]
          .then((res) => {
            assert.isUndefined(res.options.headers['cisco-no-http-redirect']);
            assert.isUndefined(res.options.headers['spark-user-agent']);
            assert.isUndefined(res.options.headers.trackingid);
          })));

      it('emits download progress events for non-encrypted files', () => {
        const spy = sinon.spy();
        return spark.internal.conversation.download({url: makeLocalUrl('/sample-image-small-one.png')})
          .on('progress', spy)
          .then((f) => fh.isMatchingFile(f, sampleImageSmallOnePng)
            .then((result) => assert.isTrue(result)))
          .then(() => assert.called(spy));
      });
    });

    describe('#get()', () => {
      let conversation, conversation2;

      before('create conversations', () => Promise.all([
        spark.internal.conversation.create({participants: [mccoy.id]})
          .then((c) => { conversation = c; }),
        spark.internal.conversation.create({participants: [scott.id]})
          .then((c) => { conversation2 = c; })
      ]));

      it('retrieves a single conversation by url', () => spark.internal.conversation.get({url: conversation.url})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it('retrieves a single conversation by id', () => spark.internal.conversation.get({id: conversation.id})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it('retrieves a 1:1 conversation by userId', () => spark.internal.conversation.get({user: mccoy})
        .then((c) => {
          assert.equal(c.id, conversation.id);
          assert.equal(c.url, conversation.url);
        }));

      it('retrieves a 1:1 conversation with a deleted user', () => spark.internal.conversation.get({user: scott})
        .then((c) => {
          assert.equal(c.id, conversation2.id);
          assert.equal(c.url, conversation2.url);
        })
        .then(() => testUsers.remove([scott]))
        // add retries to address CI propagation delay
        .then(() => retry(() => assert.isRejected(spark.internal.conversation.get({user: scott}))))
        .then(() => retry(() => spark.internal.conversation.get({user: scott}, {includeConvWithDeletedUserUUID: true})))
        .then((c) => {
          assert.equal(c.id, conversation2.id);
          assert.equal(c.url, conversation2.url);
        }));

      it('decrypts the contents of activities in the retrieved conversation', () => spark.internal.conversation.post(conversation, {
        displayName: 'Test Message'
      })
        .then(() => spark.internal.conversation.get({url: conversation.url}, {activitiesLimit: 50}))
        .then((c) => {
          const posts = c.activities.items.filter((activity) => activity.verb === 'post');
          assert.lengthOf(posts, 1);
          assert.equal(posts[0].object.displayName, 'Test Message');
        }));
    });

    describe('#list()', () => {
      let conversation1, conversation2;

      before('create conversations', () => Promise.all([
        spark.internal.conversation.create({
          displayName: 'test 1',
          participants
        })
          .then((c) => { conversation1 = c; }),
        spark.internal.conversation.create({
          displayName: 'test 2',
          participants
        })
          .then((c) => { conversation2 = c; })
      ]));

      it('retrieves a set of conversations', () => spark.internal.conversation.list({
        conversationsLimit: 2
      })
        .then((conversations) => {
          assert.include(map(conversations, 'url'), conversation1.url);
          assert.include(map(conversations, 'url'), conversation2.url);
        }));

      describe('with deferDecrypt = true', () => {
        it('retrieves a non-decrypted set of conversations each with a bound decrypt method', () => spark.internal.conversation.list({
          conversationsLimit: 2,
          deferDecrypt: true
        })
          .then(([c1, c2]) => {
            assert.lengthOf(c1.displayName.split('.'), 5, '5 periods implies this is a jwt and not a decrypted string');
            assert.notInclude(['test 1, test 2'], c1.displayName);

            assert.lengthOf(c2.displayName.split('.'), 5, '5 periods implies this is a jwt and not a decrypted string');
            assert.notInclude(['test 1, test 2'], c2.displayName);

            return Promise.all([
              c1.decrypt()
                .then(() => assert.notInclude(['test 1, test 2'], c1.displayName)),
              c2.decrypt()
                .then(() => assert.notInclude(['test 1, test 2'], c2.displayName))
            ]);
          }));
      });
    });

    describe('#listLeft()', () => {
      let conversation;
      before('create conversation', () => spark.internal.conversation.create({participants})
        .then((c) => { conversation = c; }));

      it('retrieves the conversations the current user has left', () => spark.internal.conversation.listLeft()
        .then((c) => {
          assert.lengthOf(c, 0);
          return spark.internal.conversation.leave(conversation);
        })
        .then(() => spark.internal.conversation.listLeft())
        .then((c) => {
          assert.lengthOf(c, 1);
          assert.equal(c[0].url, conversation.url);
        }));
    });

    describe('#listActivities()', () => {
      let conversation;
      before('create conversation with activity', () => spark.internal.conversation.create({participants})
        .then((c) => {
          conversation = c;
          assert.lengthOf(conversation.participants.items, 3);
          return spark.internal.conversation.post(conversation, {displayName: 'first message'});
        }));

      it('retrieves activities for the specified conversation', () => spark.internal.conversation.listActivities({conversationId: conversation.id})
        .then((activities) => {
          assert.isArray(activities);
          assert.lengthOf(activities, 2);
        }));
    });

    describe('#listMentions()', () => {
      let spark2;

      before('connect mccoy to mercury', () => {
        spark2 = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return spark2.internal.mercury.connect();
      });

      after(() => spark2 && spark2.internal.mercury.disconnect());

      let conversation;
      before('create conversation', () => spark.internal.conversation.create({participants})
        .then((c) => {
          conversation = c;
          assert.lengthOf(conversation.participants.items, 3);
        }));

      it('retrieves activities in which the current user was mentioned', () => spark2.internal.conversation.post(conversation, {
        displayName: 'Green blooded hobgloblin',
        content: `<spark-mention data-object-type="person" data-object-id="${spock.id}">Green blooded hobgloblin</spark-mention>`,
        mentions: {
          items: [{
            id: `${spock.id}`,
            objectType: 'person'
          }]
        }
      })
        .then((activity) => spark.internal.conversation.listMentions({sinceDate: Date.parse(activity.published) - 1})
          .then((mentions) => {
            assert.lengthOf(mentions, 1);
            assert.equal(mentions[0].url, activity.url);
          })));
    });
  });
});
