/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-conversation';

import {Defer} from '@ciscospark/common';
import CiscoSpark from '@ciscospark/spark-core';
import fh from '@ciscospark/test-helper-file';
import sinon from '@ciscospark/test-helper-sinon';
import {assert} from '@ciscospark/test-helper-chai';
import testUsers from '@ciscospark/test-helper-test-users';
import {find} from 'lodash';
import uuid from 'uuid';
import {skipInNode} from '@ciscospark/test-helper-mocha';

/**
 * Resolves with the first argument passed in, after applying `fn()` on that
 * argument
 * @param {Function} fn
 * @returns {Promise<mixed>}
 */
function returnFirstArg(fn) {
  return (result) => Promise.resolve(fn(result))
    .then(() => result);
}

describe('plugin-conversation', function () {
  this.timeout(120000);
  describe('share', () => {
    let mccoy, participants, spark, spock;

    before(() => testUsers.create({count: 3})
      .then((users) => {
        participants = users;
        [spock, mccoy] = participants;

        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });

        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        return Promise.all([
          spark.internal.mercury.connect(),
          mccoy.spark.internal.mercury.connect()
        ]);
      }));

    after(() => Promise.all([
      spark && spark.internal.mercury.disconnect(),
      mccoy && mccoy.spark.internal.mercury.disconnect()
    ]));

    let conversation;
    beforeEach(() => {
      if (conversation) {
        return Promise.resolve();
      }

      return spark.internal.conversation.create({participants})
        .then((c) => { conversation = c; });
    });

    let hashTestText = '#test.txt';
    let sampleImageSmallOnePng = 'sample-image-small-one.png';
    let sampleImageSmallTwoPng = 'sample-image-small-two.png';
    let sampleImageLargeJpg = 'sample-image-large.jpg';
    let samplePowerpointTwoPagePpt = 'sample-powerpoint-two-page.ppt';
    let sampleTextOne = 'sample-text-one.txt';
    let sampleTextTwo = 'sample-text-two.txt';

    before(() => Promise.all([
      fh.fetchWithoutMagic(hashTestText),
      fh.fetchWithoutMagic(sampleImageSmallOnePng),
      fh.fetchWithoutMagic(sampleImageSmallTwoPng),
      fh.fetchWithoutMagic(sampleImageLargeJpg),
      fh.fetchWithoutMagic(samplePowerpointTwoPagePpt),
      fh.fetchWithoutMagic(sampleTextOne),
      fh.fetchWithoutMagic(sampleTextTwo)
    ])
      .then((res) => {
        [
          hashTestText,
          sampleImageSmallOnePng,
          sampleImageSmallTwoPng,
          sampleImageLargeJpg,
          samplePowerpointTwoPagePpt,
          sampleTextOne,
          sampleTextTwo
        ] = res;
      }));

    describe('#share()', () => {
      it('shares the specified file to the specified conversation', () => spark.internal.conversation.share(conversation, [sampleTextOne])
        .then((activity) => {
          assert.isActivity(activity);
          assert.isEncryptedActivity(activity);
          assert.isFileItem(activity.object.files.items[0]);
          return spark.internal.conversation.download(activity.object.files.items[0]);
        })
        .then(returnFirstArg((f) => assert.match(f.type, /text\/plain/)))
        .then((f) => fh.isMatchingFile(f, sampleTextOne)
          .then((result) => assert.isTrue(result))));

      it('shares the specified set of files to the specified conversation', () => spark.internal.conversation.share(conversation, [sampleTextOne, sampleTextTwo])
        .then((activity) => {
          assert.isActivity(activity);
          assert.isEncryptedActivity(activity);
          assert.isFileItem(activity.object.files.items[0]);
          assert.isFileItem(activity.object.files.items[1]);
          return Promise.all([
            spark.internal.conversation.download(activity.object.files.items[0])
              .then(returnFirstArg((f) => assert.match(f.type, /text\/plain/))),
            spark.internal.conversation.download(activity.object.files.items[1])
              .then(returnFirstArg((f) => assert.match(f.type, /text\/plain/)))
          ]);
        })
        .then(([file0, file1]) => Promise.all([
          fh.isMatchingFile(file0, sampleTextOne)
            .then((result) => assert.isTrue(result)),
          fh.isMatchingFile(file1, sampleTextTwo)
            .then((result) => assert.isTrue(result))
        ])));

      describe('files with special characters', () => {
        it('shares the specified file to the specified conversation', () => spark.internal.conversation.share(conversation, [hashTestText])
          .then((activity) => {
            assert.isActivity(activity);
            assert.isEncryptedActivity(activity);
            assert.isFileItem(activity.object.files.items[0]);
            return spark.internal.conversation.download(activity.object.files.items[0]);
          })
          // in node, this'll be 'text/plain', in a browser, it'll be
          // 'text/html'. I'm pretty sure it's caused by the # convincing
          // express it's a hashroute and treating it as html. The discrepancy
          // has no bearing on the test's validity. Further, we need to use
          // match rather than equal because some browser append the charset.
          .then(returnFirstArg((f) => assert.match(f.type, hashTestText.type || /text\/plain/)))
          .then((f) => fh.isMatchingFile(f, hashTestText)
            .then((result) => assert.isTrue(result))));
      });

      it('shares the specified image to the specified conversation', () => spark.internal.conversation.share(conversation, [sampleImageLargeJpg])
        .then((activity) => {
          assert.isActivity(activity);
          assert.isEncryptedActivity(activity);

          const fileItem = activity.object.files.items[0];
          assert.isFileItem(fileItem);

          const thumbnailItem = activity.object.files.items[0].image;
          assert.isThumbnailItem(thumbnailItem);
          assert.equal(thumbnailItem.width, 640);
          assert.isAbove(thumbnailItem.height, 358);
          assert.isBelow(thumbnailItem.height, 361);

          return spark.internal.conversation.download(activity.object.files.items[0]);
        })
        .then(returnFirstArg((f) => assert.equal(f.type, 'image/jpeg')))
        .then((f) => fh.isMatchingFile(f, sampleImageLargeJpg)
          .then((result) => assert.isTrue(result))));

      it('shares the specified set of images the specified conversation', () => spark.internal.conversation.share(conversation, [sampleImageSmallOnePng, sampleImageSmallTwoPng])
        .then((activity) => {
          assert.isActivity(activity);
          assert.isEncryptedActivity(activity);
          assert.isFileItem(activity.object.files.items[0]);
          assert.isFileItem(activity.object.files.items[1]);
          assert.isThumbnailItem(activity.object.files.items[0].image);
          assert.isThumbnailItem(activity.object.files.items[1].image);
          return Promise.all([
            spark.internal.conversation.download(activity.object.files.items[0])
              .then(returnFirstArg((f) => assert.equal(f.type, 'image/png'))),
            spark.internal.conversation.download(activity.object.files.items[1])
              .then(returnFirstArg((f) => assert.equal(f.type, 'image/png')))
          ]);
        })
        .then(([file0, file1]) => Promise.all([
          fh.isMatchingFile(file0, sampleImageSmallOnePng)
            .then((result) => assert.isTrue(result)),
          fh.isMatchingFile(file1, sampleImageSmallTwoPng)
            .then((result) => assert.isTrue(result))
        ])));

      describe('when it shares a transcodable file', () => {
        let activities;
        let blockUntilTranscode;
        let clientTempId;
        let objectUrl;

        beforeEach(() => {
          clientTempId = uuid.v4();
          activities = [];
          spark.internal.mercury.on('event:conversation.activity', onMessage);
          blockUntilTranscode = new Defer();
        });

        afterEach(() => spark && spark.internal.mercury.off('event:conversation.activity', onMessage));

        function onMessage(message) {
          activities.push(message.data.activity);

          if (message.data.activity.clientTempId === clientTempId) {
            objectUrl = message.data.activity.object.url;
          }

          if (objectUrl) {
            const updateActivity = find(activities, (activity) => activity.verb === 'update' && activity.object.url === objectUrl);
            if (updateActivity) {
              blockUntilTranscode.resolve(updateActivity);
            }
          }
        }

        it('mercury receives an update', () => spark.internal.conversation.share(conversation, {
          object: {
            files: [samplePowerpointTwoPagePpt]
          },
          clientTempId
        })
          .then((activity) => {
            assert.equal(activity.clientTempId, clientTempId);
            activities.push(activity);

            return spark.internal.conversation.download(activity.object.files.items[0])
              .then((f) => assert.equal(f.type, 'application/vnd.ms-powerpoint'))
              .then(() => blockUntilTranscode.promise)
              .then((updateActivity) => {
                assert.equal(updateActivity.object.url, activity.object.url);
                assert.lengthOf(updateActivity.object.files.items[0].transcodedCollection.items[0].files.items, 2);
                // Prove that the newly transcoded file can be downloaded and
                // decrypted
                const firstItem = updateActivity.object.files.items[0].transcodedCollection.items[0].files.items[0];
                return spark.internal.conversation.download(firstItem);
              });
          }));
      });

      it('shares a whiteboard', () => {
        const activity = spark.internal.conversation.makeShare(conversation);

        activity.add(sampleImageSmallOnePng, {
          actions: [{
            type: 'edit',
            mimeType: 'application/x-cisco-spark-whiteboard',
            url: 'https://boards.example.com/boards/1'
          }]
        });

        return spark.internal.conversation.share(conversation, activity)
          .then((share) => {
            assert.isActivity(share);
            assert.isEncryptedActivity(share);
            assert.isFileItem(share.object.files.items[0]);
            assert.isThumbnailItem(share.object.files.items[0].image);
            assert.equal(share.object.contentCategory, 'documents');
            assert.isArray(share.object.files.items[0].actions);
            assert.equal(share.object.files.items[0].actions[0].type, 'edit');
            assert.equal(share.object.files.items[0].actions[0].mimeType, 'application/x-cisco-spark-whiteboard');
            assert.equal(share.object.files.items[0].actions[0].url, 'https://boards.example.com/boards/1');

            return spark.internal.conversation.download(share.object.files.items[0])
              .then(returnFirstArg((f) => assert.equal(f.type, 'image/png')));
          })
          .then((file0) => fh.isMatchingFile(file0, sampleImageSmallOnePng)
            .then((result) => assert.isTrue(result)));
      });
    });

    describe('#makeShare', () => {
      // http-core doesn't current do upload progress events in node, so this
      // test is browser-only for now
      skipInNode(it)('provides an interface for file upload events', () => {
        const spy = sinon.spy();
        const share = spark.internal.conversation.makeShare(conversation);
        const emitter = share.add(sampleImageSmallOnePng);
        emitter.on('progress', spy);
        return spark.internal.conversation.share(conversation, share)
          .then(() => assert.called(spy));
      });

      it('shares a file with a name', () => {
        const share = spark.internal.conversation.makeShare(conversation);
        share.add(sampleImageSmallOnePng);
        share.object = {
          displayName: 'a name'
        };
        return spark.internal.conversation.share(conversation, share)
          .then((activity) => {
            assert.equal(activity.object.displayName, 'a name');
            return spark.internal.conversation.download(activity.object.files.items[0]);
          })
          .then(returnFirstArg((f) => assert.equal(f.type, 'image/png')))
          .then((file) => fh.isMatchingFile(file, sampleImageSmallOnePng));
      });

      it('allows removal of a file from the share', () => {
        const share = spark.internal.conversation.makeShare(conversation);
        share.add(sampleImageSmallOnePng);
        share.add(sampleImageSmallTwoPng);
        share.remove(sampleImageSmallOnePng);
        share.object = {
          displayName: 'a name'
        };
        return spark.internal.conversation.share(conversation, share)
          .then((activity) => {
            assert.equal(activity.object.displayName, 'a name');
            assert.lengthOf(activity.object.files.items, 1);
            return spark.internal.conversation.download(activity.object.files.items[0]);
          })
          .then(returnFirstArg((f) => assert.equal(f.type, 'image/png')))
          .then((file) => fh.isMatchingFile(file, sampleImageSmallTwoPng));
      });
    });
  });
});
