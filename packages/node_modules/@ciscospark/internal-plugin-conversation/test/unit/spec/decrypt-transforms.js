/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import sinon from 'sinon';
import {assert} from '@ciscospark/test-helper-chai';
import {transforms} from '@ciscospark/internal-plugin-conversation/src/decryption-transforms';

describe('plugin-conversation', () => {
  describe('decryption transforms', () => {
    describe('decryptObject()', () => {
      it('calls the correct method if a recording microappInstance is passed to it', () => {
        const transform = transforms.find((t) => t.name === 'decryptObject');
        const transformStub = sinon.stub();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const activity = {
          objectType: 'microappInstance'
        };

        transform.fn(ctx, key, activity);

        assert.equal(transformStub.lastCall.args[0], 'decryptMicroappinstance');
      });
    });

    describe('decryptMicroappinstance()', () => {
      it('decrypts the model prop inside of decryptMicroappinstance()', () => {
        const transform = transforms.find((t) => t.name === 'decryptMicroappinstance');
        const transformStub = sinon.stub();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const microappInstance = {
          model: 'Longencryptedstring'
        };

        transform.fn(ctx, key, microappInstance);

        assert.equal(transformStub.lastCall.args[0], 'decryptPropModel');
      });
    });

    describe('link activity', () => {
      it('calls the correct method if a content object is passed in', () => {
        const transform = transforms.find((t) => t.name === 'decryptObject');
        const transformStub = sinon.stub();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const activity = {
          objectType: 'content'
        };

        transform.fn(ctx, key, activity);

        assert.equal(transformStub.lastCall.args[0], 'decryptContent');
      });

      it('calls the correct method if a link content category is passed in', () => {
        const transform = transforms.find((t) => t.name === 'decryptContent');
        const transformStub = sinon.stub();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const activity = {
          objectType: 'content',
          contentCategory: 'links'
        };

        transform.fn(ctx, key, activity);

        assert.equal(transformStub.lastCall.args[0], 'decryptContentLinks');
      });

      it('decrypts the link and the comment', () => {
        const transform = transforms.find((t) => t.name === 'decryptContentLinks');
        const transformStub = sinon.spy();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const activity = {
          objectType: 'content',
          contentCategory: 'links',
          links: {
            items: [
              {item1: 'item1'}
            ]
          }
        };

        return transform.fn(ctx, key, activity)
          .then(() => {
            assert.equal(transformStub.callCount, 2);
            assert.equal(transformStub.getCall(0).args[0], 'decryptObject');
            assert.equal(transformStub.getCall(1).args[0], 'decryptComment');
          });
      });

      it('decrypts a link object', () => {
        const transform = transforms.find((t) => t.name === 'decryptLink');
        const transformStub = sinon.spy();

        const ctx = {
          transform: transformStub
        };
        const key = null;
        const activity = {
          objectType: 'content',
          contentCategory: 'links',
          links: {
            items: [
              {item1: 'item1'}
            ]
          }
        };

        return transform.fn(ctx, key, activity)
          .then(() => {
            assert.equal(transformStub.callCount, 2);
            assert.equal(transformStub.getCall(0).args[0], 'decryptPropSslr');
            assert.equal(transformStub.getCall(1).args[0], 'decryptPropDisplayName');
          });
      });

      it('decrypts an sslr', () => {
        const transform = transforms.find((t) => t.name === 'decryptPropSslr');

        const ORIG_SSLR = 'ORIG_SSLR';
        const DECRYPTED_SSLR = 'DECRYPTED_SSLR';
        const transformStub = sinon.spy(() => Promise.resolve(DECRYPTED_SSLR));

        const ctx = {
          spark: {
            internal: {
              encryption: {
                decryptScr: transformStub
              }
            }
          }
        };
        const key = null;
        const activity = {
          objectType: 'content',
          contentCategory: 'links',
          links: {
            items: [
              {item1: 'item1'}
            ]
          },
          sslr: ORIG_SSLR
        };

        return transform.fn(ctx, key, activity)
          .then(() => {
            assert.equal(transformStub.callCount, 1);
            assert.equal(transformStub.getCall(0).args[1], ORIG_SSLR);
            assert.equal(activity.sslr, DECRYPTED_SSLR);
          });
      });
    });
  });
});
