import 'webrtc-adapter';
import {debounce} from 'lodash-decorators';
import {nonenumerable} from 'core-decorators';
import {make as makeTemplateContainer, oneFlight, tap, whileInFlight} from '@ciscospark/common';
import evented from '@ciscospark/common-evented';
import Events from 'ampersand-events';
import {defaults} from 'lodash';
import {
  ensureH264,
  limitBandwith,
  getMediaDirectionFromTracks,
  kindToPropertyFragment
} from './webrtc-helpers';

const DirectionContainer = makeTemplateContainer(WeakMap, Map);
const targetMediaDirection = new DirectionContainer();

/**
 * Wrapper around targetMediaDirection.get which returne `inactive` instead of
 * undefined
 * @param {WebRTCMediaEngine} target
 * @param {string} kind
 * @private
 * @returns {string}
 */
function getTargetMediaDirection(target, kind) {
  return targetMediaDirection.get(target, kind) || `inactive`;
}

/**
 * Interface for doing webrtc things
 * @protected
 */
export default class WebRTCMediaEngine {
  /**
   * Wrapper around navigator.mediaDevices.getUserMedia
   *
   * @param {MediaStreamContraints} constraints
   * @returns {Promise<MediaStream>}
   */
  static getUserMedia(constraints) {
    return navigator.mediaDevices.getUserMedia(defaults({fake: process.env.NODE_ENV === `test`}, constraints));
  }

  logger = console

  /**
   * Represents the local party's outgoing stream. Instantiated when the class
   * is instantiated.
   * @type {MediaStream}
   */
  localMediaStream = new MediaStream();

  /**
   * Represent the remote party's incoming media. Instantiated when the class is
   * instantiated.
   * @type {MediaStream}
   */
  remoteMediaStream = new MediaStream();

  /**
   * Reserved for future use
   * @type {MediaStream}
   */
  localSlideShare = new MediaStream()

  /**
   * Peer Connection
   * @type {RTCPeerConnection}
   */
  pc = new RTCPeerConnection({iceServers: []});

  @evented
  /**
   * The most-recently produced offer
   * @private
   */
  offerSdp = ``;

  @evented
  /**
   * The most-recently accepted answer
   * @private
   */
  answerSdp = ``;

  /**
   * Returns the current audio direction
   * @returns {string}
   */
  get audioDirection() {
    return getMediaDirectionFromTracks(`audio`, this.pc);
  }

  /**
   * Returns the current video direction
   * @returns {string}
   */
  get videoDirection() {
    return getMediaDirectionFromTracks(`video`, this.pc);
  }

  /**
   * Constructor
   * @param {Object} attrs
   * @param {Logger} attrs.logger (optional): defaults to console
   * @returns {WebRTCMediaEngine}
   */
  constructor(attrs = {}) {
    if (attrs.logger) {
      this.logger = attrs.logger;
    }

    this.pc.onnegotiationneeded = () => {
      if (this.answerSdp) {
        this.logger.info(`peer connection emitted negotiationneeded`);
        this.triggerNegotiationNeeded();
      }
    };

    // Note: adapter.js doesn't seem to fully shim the track event.
    // addEventListener doesn't appear to work for it in chrome
    this.pc.ontrack = (event) => {
      this.trigger(`track`);
      event.streams[0]
        .getTracks()
        .forEach((track) => {
          this.remoteMediaStream.addTrack(track);
          track.onended = () => {
            this.remoteMediaStream.removeTrack(track);
            track.onended = undefined;
          };
        });
    };
  }

  /**
   * Creates an offer SDP
   * @returns {Promise<string>}
   */
  createOffer() {
    this.logger.info(`beginning negotiation`);
    let icePromise;

    if (!this.answerSdp) {
      icePromise = new Promise((resolve) => {
        this.logger.info(`configuring ice gathering`);
        this.pc.onicecandidate = (event) => {
          if (!event.candidate) {
            this.logger.info(`ice gathering complete`);
            resolve();
            return;
          }

          this.logger.info(`got ice candidate`);
        };
      });
    }

    const td = getTargetMediaDirection(this, `video`);
    const wantsVideo = td.includes(`send`) || td.includes(`recv`);

    return new Promise((resolve) => {
      if (this.gumming) {
        this.logger.info(`gum in flight, waiting until it completes`);
        this.once(`change:gumming`, resolve);
        return;
      }

      resolve();
    })
      .then(tap(() => this.logger.info(`creating offer`, this.offerOptions)))
      .then(() => {
        // This is a (hopefully temporary) hack to deal with the fact that one
        // out of two browsers removes the remote stream when offerToReceive* is
        // false. We've already made the choice to disable the stream, but we
        // want to make sure we're still willing to receive an answer for it.
        this.offerOptions.offerToReceiveAudio = this.offerOptions.offerToReceiveAudio || !!this.pc.getReceivers().find((r) => r.track.kind === `audio`);
        this.offerOptions.offerToReceiveVideo = this.offerOptions.offerToReceiveVideo || !!this.pc.getReceivers().find((r) => r.track.kind === `video`);
        return this.pc.createOffer(this.offerOptions);
      })
      .then(tap(() => this.logger.info(`setting local description`)))
      .then((offer) => this.pc.setLocalDescription(offer))
      .then(tap(() => this.logger.info(`blocking for ice gathering`)))
      .then(() => icePromise)
      .then(tap(() => this.logger.info(`limiting bandwith`)))
      .then(() => this.pc.localDescription.sdp)
      .then(limitBandwith)
      .then(tap(() => wantsVideo && this.logger.info(`confirm h264 in offer`)))
      .then(ensureH264(wantsVideo))
      .then(tap((sdp) => {
        this.offerSdp = sdp;
      }));
  }

  /**
   * Receives an answer SDP
   * @param {string} sdp
   * @returns {Promise}
   */
  acceptAnswer(sdp) {
    return this.pc.setRemoteDescription(new RTCSessionDescription({
      sdp,
      type: `answer`
    }))
      .then(() => {
        this.answerSdp = sdp;
      });
  }

  @nonenumerable
  /**
   * {@link MediaStreamConstraints} that'll be used for the next call to
   * {@link WebRTCMediaEngine.getUserMedia()}
   * @private
   * @type {MediaStreamConstraints}
   */
  constraints = {};

  @nonenumerable
  /**
   * {@link RTCOfferOptions} that'll be used for the next call to
   * {@link RTCPeerConnection.createOffer}
   * @private
   * @type {RTCOfferOptions}
   */
  offerOptions = {};

  @nonenumerable
  @evented
  /**
   * Indicates whether or not a call to {@link MediaDevices#getUserMedia()} is
   * in flight
   * @private
   * @type {boolean}
   */
  gumming = false

  /**
   * Change media direction without consumer provided tracks or complex
   * constraints
   * @param {string} kind
   * @param {string} direction
   * @private
   * @returns {undefined}
   */
  _setNewMediaDirection(kind, direction) {
    this.logger.info(`setting ${kind} direction to ${direction}`);
    const constraint = direction.includes(`send`);
    this.constraints[kind] = constraint;

    if (constraint) {
      if (!this[`${kind}Direction`].includes(`send`)) {
        this._setNewMediaConstraint(kind, constraint);
      }
    }
    else {
      this.logger.info(`removing any no-longer-needed ${kind} tracks`);
      this.localMediaStream
        .getTracks()
        .filter((t) => t.kind === kind)
        .forEach((t) => {
          this.logger.info(`stopping ${kind} track ${t.id}`);
          t.stop();
          this.logger.info(`removing ${kind} track ${t.id} from localMediaStream`);
          this.localMediaStream.removeTrack(t);
          this.logger.info(`removing ${kind} track ${t.id} from peer connection`);
          this.pc.removeTrack(this.pc.getSenders().find((s) => s.track === t));
        });
    }
  }

  /**
   * Sets or replaces current track for $kind
   * @param {string} kind
   * @param {MediaStreamTrack} track
   * @returns {undefined}
   */
  _setNewMediaTrack(kind, track) {
    this.logger.info(`setting new ${kind} track`);
    this.constraints[kind] = false;
    this.addOrReplaceTrack(track);
  }

  /**
   * Causes track for ${kind} to be set or replaced according to $constraint
   * @param {string} kind
   * @param {Object|boolean} constraint
   * @returns {undefined}
   */
  _setNewMediaConstraint(kind, constraint) {
    this.logger.info(`setting ${kind} with new constraint`);
    this.constraints[kind] = constraint;
    this._getUserMedia();
  }

  // I don't see any further ways to reduce complexity without hurting
  // readability
  /* eslint-disable complexity */
  /**
   * Sets a media direction for a given media type. Almost certainly triggers
   * renegotiation. This is the method to use if you want to replace a track.
   * @param {string} kind audio|video
   * @param {string} direction sendonly|recvonly|sendrecv|inactive
   * @param {MediaStreamTrack|Object} trackOrConstraint
   * @returns {Promise}
   */
  setMedia(kind, direction, trackOrConstraint) {
    if (trackOrConstraint) {
      if (!direction.includes(`send`)) {
        throw new Error(`Cannot set new ${kind} track or constraint if direction does not include send`);
      }

      if (trackOrConstraint instanceof MediaStreamTrack) {
        if (trackOrConstraint.kind !== kind) {
          throw new Error(`track is not a valid ${kind} media stream track`);
        }

        this._setNewMediaTrack(kind, trackOrConstraint);
      }
      else {
        this._setNewMediaConstraint(kind, trackOrConstraint);
      }
    }
    else {
      if (direction === getTargetMediaDirection(this, kind)) {
        this.logger.info(`${kind} already transitioning to ${direction}, not making changes`);
        return;
      }

      if (direction === this[`${kind}Direction`]) {
        this.logger.info(`${kind} already set to ${direction}, not making changes`);
        return;
      }
      this._setNewMediaDirection(kind, direction);
    }

    const shouldRecv = direction.includes(`recv`);

    targetMediaDirection.set(this, kind, direction);

    this.offerOptions[`offerToReceive${kindToPropertyFragment(kind)}`] = shouldRecv;

    if (shouldRecv) {
      if (this.remoteMediaStream.getTracks().find((t) => t.kind === kind)) {
        this.unpauseReceivingMedia(kind);
      }
      else if (this.answerSdp) {
        this.triggerNegotiationNeeded();
      }
    }
    else if (this.remoteMediaStream.getTracks().find((t) => t.kind === kind)) {
      this.pauseReceivingMedia(kind);
    }
  }
  /* eslint-enable complexity */

  @whileInFlight(`gumming`)
  @oneFlight
  /**
   * Wrapper around {@link MediaDevices#getUserMedia()} that delays the call one
   * tick to reduce the number of permissions dialogs presented to the user.
   * @returns {Promise<MediaStream>}
   */
  _getUserMedia() {
    this.logger.info(`enqueing request to get user media`);
    return new Promise((resolve) => process.nextTick(resolve))
      .then(() => {
        if (this.constraints.audio === true && this.pc.getSenders().find((s) => s.track.kind === `audio`)) {
          this.logger.info(`already have a local audio track, removing constraint for a second one`);
          Reflect.deleteProperty(this.constraints, `audio`);
        }

        if (this.constraints.video === true && this.pc.getSenders().find((s) => s.track.kind === `video`)) {
          this.logger.info(`already have a local video track, removing constraint for a second one`);
          Reflect.deleteProperty(this.constraints, `video`);
        }

        return WebRTCMediaEngine.getUserMedia(this.constraints);
      })
      .then((stream) => {
        this.logger.info(`got local media stream with ${stream.getAudioTracks().length} audio tracks and ${stream.getVideoTracks().length} video tracks`);
        stream.getTracks().forEach((t) => this.addOrReplaceTrack(t));
        this.constraints = {};
      });
  }

  /**
   * adds or replaces a local @{link MediaStreamTrack}
   * @private
   * @param {MediaStreamTrack} track
   * @returns {undefined}
   */
  addOrReplaceTrack(track) {
    this.logger.info(`preparing to add ${track.kind} to local media stream`);
    const existing = this.pc.getSenders().find((s) => s.track.kind === track.kind && s.track !== track);
    if (existing) {
      this.logger.info(`removing previous ${track.kind} from local media stream`);
      this.pc.removeTrack(existing);
      this.localMediaStream.removeTrack(existing.track);
      // it may not be appropriate to stop the track if it was supplied by the
      // engine consumer, but I'm inclined not to deal with that unless it
      // becomes a real issue.
      track.stop();
    }

    this.logger.info(`adding ${track.kind} to local media stream`);
    this.localMediaStream.addTrack(track);
    this.logger.info(`adding ${track.kind} to peer connection`);
    this.pc.addTrack(track, this.localMediaStream);
  }

  /**
   * Stops sending useful bits on the identified track, but does not end it (the
   * camera/mic will stay on but the remote party(s) will not see/hear anything).
   * Avoids renegotiation. Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  pauseSendingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const senders = this.pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    if (senders.length === 0) {
      throw new Error(`No ${kind} media senders to pause`);
    }

    senders.forEach((s) => {
      this.logger.info(`pausing ${kind} sender`);
      s.track.enabled = false;
    });
  }

  /**
   * Resumes sending bits on the identified track. Throws if `kind` does not
   * identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  unpauseSendingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const senders = this.pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    if (senders.length === 0) {
      throw new Error(`No ${kind} media senders to unpause`);
    }

    senders.forEach((s) => {
      this.logger.info(`unpausing ${kind} sender`);
      s.track.enabled = true;
    });
  }

  /**
   * Convenience function. Sets a remote track.enabled=false. Does not
   * renegotiate.Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  pauseReceivingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const tracks = this.remoteMediaStream
      .getTracks()
      .filter((t) => t.kind === kind);

    if (tracks.length === 0) {
      throw new Error(`No remote ${kind} media tracks to pause`);
    }


    tracks.forEach((t) => {
      this.logger.info(`pausing remote ${kind} track`);
      t.enabled = false;
    });
  }

  /**
   * Convenience function. Sets a remote track.enabled=true. Does not
   * renegotiate.Throws if `kind` does not identify a track.
   * @param {string} kind
   * @returns {Promise}
   */
  unpauseReceivingMedia(kind) {
    if (!kind) {
      throw new Error(`kind is required`);
    }
    const tracks = this.remoteMediaStream
      .getTracks()
      .filter((t) => t.kind === kind);

    if (tracks.length === 0) {
      throw new Error(`No remote ${kind} media tracks to pause`);
    }

    tracks.forEach((t) => {
      this.logger.info(`unpausing remote ${kind} track`);
      t.enabled = true;
    });
  }

  /**
   * Stops all tracks and streams, closes the peer connection, and removes all
   * listeners
   * @returns {undefined}
   */
  stop() {
    if (this.pc.signalingState !== `closed`) {
      this.pc.getSenders().forEach((s) => s.track.stop());
      this.pc.close();
    }

    this.pc.onnegotiationneeded = undefined;
    this.pc.ontrack = undefined;
    this.pc.onicecandidate = undefined;
    this.off();
  }


  @debounce(500)
  /**
   * Debounced helper for triggering `negotiationneeded`. Only allows firing
   * after the first answer is recieved.
   * @private
   * @returns {undefined}
   */
  // It's not missing, but the decorator is throwing off eslint
  // eslint-disable-next-line require-jsdoc
  triggerNegotiationNeeded() {
    this.trigger(`negotiationneeded`);
  }
}

Object.assign(WebRTCMediaEngine.prototype, Events);
