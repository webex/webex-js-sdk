import 'webrtc-adapter';

import {curry, find} from 'lodash';
import {parse} from 'sdp-transform';

/**
 * Pulls the direction line for the specified media kind from an sdp
 * @param {string} kind
 * @param {string} sdp
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromSDP(kind, sdp) {
  const media = find(parse(sdp).media, {type: kind});
  if (!media) {
    return `inactive`;
  }

  return media.direction;
}

/**
 * Reverses a media direction from offer to answer (e.g. sendonly -> recvonly)
 * @param {string} direction
 * @protected
 * @returns {string}
 */
export function reverseMediaDirection(direction) {
  switch (direction) {
  case `inactive`:
  case `sendrecv`:
    return direction;
  case `sendonly`:
    return `recvonly`;
  case `recvonly`:
    return `sendonly`;
  default:
    throw new Error(`direction "${direction}" is not valid`);
  }
}

/**
 * Checks a given sdp to ensure it contains an offer for the h264 codec
 * @param {boolean} wantsVideo
 * @param {string} offer
 * @protected
 * @returns {string} returns the offer to simplify use in promise chains
 */
export const ensureH264 = curry((wantsVideo, offer) => {
  if (wantsVideo) {
    if (!offer.includes(`m=video`)) {
      throw new Error(`No video section found in offer`);
    }
    if (!/[hH]264/.test(offer)) {
      throw new Error(`Offer does not include h264 codec`);
    }
  }
  return offer;
});

/**
 * Adds a bandwith limit line to the sdp; without this line, calling fails
 * @param {string} sdp SDP
 * @protected
 * @returns {string} The modified SDP
 */
export function limitBandwith(sdp) {
  return sdp.split(`\r\n`).reduce((lines, line) => {
    lines.push(line);
    if (line.startsWith(`m=`)) {
      lines.push(`b=TIAS:${line.includes(`audio`) ? 64000 : 1000000}`);
    }
    return lines;
  }, []).join(`\r\n`);
}

/**
 * Helper for dealing wait capitalization
 * @param {string} kind audio|video
 * @protected
 * @returns {string} Audio|Video
 */
export function kindToPropertyFragment(kind) {
  return kind === `audio` ? `Audio` : `Video`;
}

/**
 * Like get getMediaDirectionFromSDP, but reverses the the result
 * @param {string} kind
 * @param {string} offerSdp
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromSDPForAnswer(kind, offerSdp) {
  return reverseMediaDirection(getMediaDirectionFromSDP(kind, offerSdp));
}


/**
 * Converts a pair of booleans to a SDP direction string
 * @param {boolean} send
 * @param {boolean} recv
 * @protected
 * @returns {string}
 */
export function boolToDirection(send, recv) {
  if (send && recv) {
    return `sendrecv`;
  }

  if (send) {
    return `sendonly`;
  }

  if (recv) {
    return `recvonly`;
  }

  return `inactive`;
}

/**
 * Determines the flow of media for a given kind of media on a peer connection
 * @param {string} kind
 * @param {RTCPeerConnection} pc
 * @protected
 * @returns {string}
 */
export function getMediaDirectionFromTracks(kind, pc) {
  let send = false;
  // removeTrack isn't polyfilled in Chrome, which means getSenders can't be
  // trusted. We'll need to fallback to reading the track.
  if (pc.removeTrack) {
    const senders = pc
      .getSenders()
      .filter((s) => s.track.kind === kind);

    send = senders.length > 0 && senders.reduce((acc, s) => acc && s.track.enabled, true);
  }
  else {
    const localStreams = pc.getLocalStreams();
    send = localStreams.length > 0 && localStreams.reduce((acc1, stream) => {
      const tracks = stream
        .getTracks()
        .filter((t) => t.kind === kind);

      return acc1 && tracks.length > 0 && tracks.reduce((acc, t) => acc && t.enabled, true);
    }, true);
  }

  const remoteStreams = pc.getRemoteStreams();
  const recv = remoteStreams.length > 0 && remoteStreams.reduce((acc1, stream) => {
    const tracks = stream
      .getTracks()
      .filter((t) => t.kind === kind);

    return acc1 && tracks.length > 0 && tracks.reduce((acc, t) => acc && t.enabled, true);
  }, true);

  return boolToDirection(send, recv);
}
