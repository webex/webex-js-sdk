import {
  webrtcHelpers,
  WebRTCMediaEngine
} from '@ciscospark/media-engine-webrtc';
const {
  getMediaDirectionFromSDP,
  reverseMediaDirection
} = webrtcHelpers;
import {assert} from '@ciscospark/test-helper-chai';
import {browserOnly, expectEvent} from '@ciscospark/test-helper-mocha';
import sinon from '@ciscospark/test-helper-sinon';
import {mockAnswer, mockRenegotiate} from '../lib/offer-answer';

function getExpectedMediaDirection(next, previous) {
  if (previous.includes(`recv`)) {
    if (next === `inactive`) {
      return `recvonly`;
    }
    if (next === `sendonly`) {
      return `sendrecv`;
    }
  }

  return next;
}

const backoffPattern = [0, 100, 200, 400, 800];

function retry(fn) {
  return backoffPattern.reduce((promise, delay) => {
    return promise.catch(() => {
      return new Promise((resolve, reject) => {
        setTimeout(() => {
          try {
            resolve(fn());
          }
          catch (err) {
            reject(err);
          }
        }, delay);
      });
    });
  }, Promise.reject());
}

browserOnly(describe)(`media-engine-webrtc`, function() {
  this.timeout(60000);
  describe(`WebRTCMediaEngine`, () => {
    describe(`renegotiation`, () => {
      const audioStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const audioEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      audioStartStates.forEach((audioStart) => {
        audioEndStates.forEach((audioEnd) => {
          videoStartStates.forEach((videoStart) => {
            // all the complexity comes from building the `describe()` block
            // message
            // eslint-disable-next-line complexity
            videoEndStates.forEach((videoEnd) => {
              if (audioStart === `inactive` && videoStart === `inactive`) {
                // not a valid initial state
                return;
              }

              if (audioEnd === `inactive` && videoEnd === `inactive`) {
                return;
              }

              if (audioStart === audioEnd && videoStart === videoEnd) {
                // no changes, therefore nothing to test
                return;
              }

              const expectNewTrack = !audioStart.includes(`recv`) && audioEnd.includes(`recv`) || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);
              const expectToRenegotiate = !audioStart.includes(`send`) && audioEnd.includes(`send`) || !videoStart.includes(`send`) && videoEnd.includes(`send`) || !audioStart.includes(`recv`) && audioEnd.includes(`recv`) || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);

              const message = `when ${[
                audioStart === audioEnd ? `audio is ${audioStart}` : `audio changes from ${audioStart} to ${audioEnd}`,
                videoStart === videoEnd ? `video is ${videoStart}` : `video changes from ${videoStart} to ${videoEnd}`
              ]
                .filter((m) => m)
                .join(` and `)}`;

              describe(message, () => {
                // Note: This describe block is stateful; `it()` statements must
                // execute in order.
                let engine;
                before(() => {
                  engine = new WebRTCMediaEngine();
                });

                after(() => {
                  engine.stop();
                });

                it(`initiates a session with audio=${audioStart} and video=${videoStart}`, () => {
                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  assert.lengthOf(engine.localMediaStream.getTracks(), 0);
                  assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                  return engine.createOffer()
                    .then((offer) => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                      assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      return offer;
                    })
                    .then(mockAnswer)
                    .then((answer) => {
                      assertLocalMedia(engine, audioStart, videoStart);

                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);
                      assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));
                      assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (audioStart.includes(`recv`) || videoStart.includes(`recv`)) && expectEvent(20000, `track`, engine),
                      engine.acceptAnswer(answer)
                    ]))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);

                      assert.equal(engine.audioDirection, audioStart);
                      assert.equal(engine.videoDirection, videoStart);
                    });
                });

                it(`transitions to audio=${audioEnd} and video=${videoEnd}`, () => {
                  engine.setMedia(`audio`, audioEnd);
                  engine.setMedia(`video`, videoEnd);

                  return Promise.all([
                    expectToRenegotiate && expectEvent(20000, `negotiationneeded`, engine)
                      .then(() => retry(() => assertLocalMedia(engine, audioEnd, videoEnd)))
                      .then(() => engine.createOffer())
                      .then((offer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a
                          // remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioEnd, audioStart));
                        }
                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), videoEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoEnd, videoStart));
                        }
                        return offer;
                      })
                      .then(mockRenegotiate)
                      .then((answer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioEnd));

                        }
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        catch (err) {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioEnd, audioStart)));
                        }

                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoEnd));
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoEnd, videoStart)));
                        }
                        return answer;
                      })
                      .then((answer) => engine.acceptAnswer(answer)),
                    expectNewTrack && expectEvent(20000, `track`, engine)
                  ])
                  .then(() => {
                    assertLocalMedia(engine, audioEnd, videoEnd);
                    assertRemoteMedia(engine, audioEnd, videoEnd);
                    assert.equal(engine.audioDirection, audioEnd);
                    assert.equal(engine.videoDirection, videoEnd);
                  });
                });

                it(`returns to audio=${audioStart} and video=${videoStart}`, () => {
                  const needsLocalAudioTrack = audioStart.includes(`send`) && engine.localMediaStream.getAudioTracks().length === 0;
                  const needsLocalVideoTrack = videoStart.includes(`send`) && engine.localMediaStream.getVideoTracks().length === 0;
                  const needsRemoteAudioTrack = audioStart.includes(`recv`) && engine.remoteMediaStream.getAudioTracks().length === 0;
                  const needsRemoteVideoTrack = videoStart.includes(`recv`) && engine.remoteMediaStream.getVideoTracks().length === 0;
                  const expectToRenegotiateOnReturn = needsLocalAudioTrack || needsLocalVideoTrack || needsRemoteAudioTrack || needsRemoteVideoTrack;

                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  return Promise.resolve(expectToRenegotiateOnReturn && expectEvent(20000, `negotiationneeded`, engine)
                    .then(() => engine.createOffer())
                    .then((offer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a
                        // remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioStart, audioEnd));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoStart, videoEnd));
                      }

                      return offer;
                    })
                    .then(mockRenegotiate)
                    .then((answer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));

                      }
                      // Need to fallback since firefox can't remove a remote stream but chrome can
                      catch (err) {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioStart, audioEnd)));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoStart, videoEnd)));
                      }

                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (needsRemoteAudioTrack || needsRemoteVideoTrack) && expectEvent(20000, `track`, engine),
                      engine.acceptAnswer(answer)
                    ])))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);

                      assert.equal(engine.audioDirection, audioStart);
                      assert.equal(engine.videoDirection, videoStart);
                    });
                });
              });
            });
          });
        });
      });
    });

    [
      `audio`,
      `video`
    ]
    .forEach((kind) => {
      describe(`#(un)pauseSendingMedia(${kind})`, () => {
        it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
          const engine = new WebRTCMediaEngine();
          engine.setMedia(`audio`, `sendrecv`);
          engine.setMedia(`video`, `sendrecv`);
          const spy = sinon.spy();

          return engine.createOffer()
            .then(mockAnswer)
            .then((answer) => Promise.all([
              expectEvent(20000, `track`, engine),
              engine.acceptAnswer(answer)
            ]))
            .then(() => {
              assertLocalMedia(engine, `sendrecv`, `sendrecv`);
              assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.pauseSendingMedia(kind);
              assert.isFalse(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
              assert.isFalse(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy))
            .then(() => {
              assertLocalMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);
              assertRemoteMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.unpauseSendingMedia(kind);
              assert.isTrue(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
              assert.isTrue(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy));
        });
      });

      describe(`#(un)pauseReceivingMedia(${kind})`, () => {
        it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
          const engine = new WebRTCMediaEngine();
          engine.setMedia(`audio`, `sendrecv`);
          engine.setMedia(`video`, `sendrecv`);
          const spy = sinon.spy();

          return engine.createOffer()
            .then(mockAnswer)
            .then((answer) => Promise.all([
              expectEvent(20000, `track`, engine),
              engine.acceptAnswer(answer)
            ]))
            .then(() => {
              assertLocalMedia(engine, `sendrecv`, `sendrecv`);
              assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.pauseReceivingMedia(kind);
              assert.isFalse(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
              assert.isFalse(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy))
            .then(() => {
              assertLocalMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);
              assertRemoteMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.unpauseReceivingMedia(kind);
              assert.isTrue(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
              assert.isTrue(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy));
        });
      });

    });

    describe(`custom track`, () => {
      let engine;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
      });

      afterEach(() => {
        engine.stop();
      });


      it(`adds a track without internally calling getusermedia`, () => {
        let track;
        const spy = sinon.spy(engine, `_getUserMedia`);

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assert.notCalled(spy);
            assertLocalMedia(engine, `sendrecv`, `inactive`);
          });
      });

      it(`adds an external track without clobbering it`, () => {
        let track;

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);
            engine.setMedia(`video`, `sendrecv`);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        let track;

        engine.setMedia(`audio`, `inactive`);
        engine.setMedia(`video`, `sendrecv`);

        assert.lengthOf(engine.localMediaStream.getTracks(), 0);
        assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

        return engine.createOffer()
          .then(mockAnswer)
          .then((answer) => Promise.all([
            expectEvent(20000, `track`, engine),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assertLocalMedia(engine, `inactive`, `sendrecv`);
            return WebRTCMediaEngine.getUserMedia({
              audio: true,
              video: false
            });
          })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            assert.isDefined(track);
            engine.setMedia(`audio`, `sendrecv`, track);
            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockRenegotiate)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
          });
      });
    });

    describe(`custom constraints`, () => {
      let engine, spy;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
        spy = sinon.spy(WebRTCMediaEngine, `getUserMedia`);
      });

      afterEach(() => {
        engine.stop();
        spy.restore();
      });


      it(`starts a connection with custom constraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`replaces a track with with new contraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);

            assertLocalMedia(engine, `sendrecv`, `inactive`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return expectEvent(20000, `negotiationneeded`, engine);
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });
    });
  });
});

function assertLocalKind(kind, direction, engine) {
  const tracks = engine.localMediaStream.getTracks().filter((t) => t.kind === kind);
  if (direction.includes(`send`)) {
    assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
    // assert.lengthOf(engine.pc.getSenders().filter((s) => s.track.kind === kind), 1, `local ` + kind + `is ` + direction);
    assert.isTrue(tracks[0].enabled, `the local ${kind} track is enabled`);
    // assert.isTrue(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled. `local ` + kind + `is ` + direction);
  }
  else {
    try {
      assert.lengthOf(tracks, 0, `there are 0 local ${kind} tracks`);
      // assert.lengthOf(engine.pc.getSenders().filter((s) => s.track.kind === kind), 0, `local ` + kind + `is ` + direction);
    }
    catch (err) {
      assert.lengthOf(tracks, 1, `there is 1 local ${kind} track`);
      assert.isFalse(tracks[0].enabled, `the local ${kind} track is not enabled`);
      // assert.isFalse(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled, `local ` + kind + `is ` + direction);
    }
  }
}

function assertRemoteKind(kind, direction, engine) {
  const tracks = engine.remoteMediaStream.getTracks().filter((t) => t.kind === kind);
  if (direction.includes(`recv`)) {

    assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
    // assert.lengthOf(engine.pc.getRemoteStreams()[0].getTracks().filter((t) => t.kind === kind), 1, `local ` + kind + `is ` + direction);
    assert.isTrue(tracks[0].enabled, `the remote ${kind} track is enabled`);
    // assert.isTrue(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled, `local ` + kind + `is ` + direction);
  }
  else {
    if (engine.remoteMediaStream) {
      try {
        assert.lengthOf(tracks, 0, `there are 0 remote ${kind} tracks`);
      }
      catch (err) {
        assert.lengthOf(tracks, 1, `there is 1 remote ${kind} track`);
        assert.isFalse(tracks[0].enabled, `the remote ${kind} track is not enabled`);
      }
    }

    if (engine.pc.getRemoteStreams()[0]) {
      try {
        assert.lengthOf(engine.pc.getRemoteStreams()[0].getTracks().filter((t) => t.kind === kind), 0, `remote ${kind} is ${direction}`);
      }
      catch (err) {
        assert.isFalse(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled, `remote ${kind} is ${direction}`);
      }
    }
  }
}

function assertLocalMedia(engine, targetAudioDirection, targetVideoDirection) {
  assertLocalKind(`audio`, targetAudioDirection, engine);
  assertLocalKind(`video`, targetVideoDirection, engine);
}

function assertRemoteMedia(engine, targetAudioDirection, targetVideoDirection) {
  assertRemoteKind(`audio`, targetAudioDirection, engine);
  assertRemoteKind(`video`, targetVideoDirection, engine);
}
