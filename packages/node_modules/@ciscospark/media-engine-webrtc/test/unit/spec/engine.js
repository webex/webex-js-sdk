import {
  WebRTCMediaEngine
} from '@ciscospark/media-engine-webrtc';
import {assert} from '@ciscospark/test-helper-chai';
import {browserOnly} from '@ciscospark/test-helper-mocha';
import sinon from '@ciscospark/test-helper-sinon';
import {mockAnswer, mockRenegotiate} from '../lib/offer-answer';

import {
  assertLocalMedia,
  assertRemoteMedia
} from '../lib/helpers';

browserOnly(describe)(`media-engine-webrtc`, function() {
  this.timeout(60000);
  describe(`WebRTCMediaEngine`, () => {
    [
      `audio`,
      `video`
    ]
    .forEach((kind) => {
      describe(`#(un)pauseSendingMedia(${kind})`, () => {
        it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
          const engine = new WebRTCMediaEngine();
          engine.setMedia(`audio`, `sendrecv`);
          engine.setMedia(`video`, `sendrecv`);
          const spy = sinon.spy();

          return engine.createOffer()
            .then(mockAnswer)
            .then((answer) => Promise.all([
              new Promise((resolve) => engine.once(`track`, resolve)),
              engine.acceptAnswer(answer)
            ]))
            .then(() => {
              assertLocalMedia(engine, `sendrecv`, `sendrecv`);
              assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.pauseSendingMedia(kind);
              assert.isFalse(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
              assert.isFalse(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy))
            .then(() => {
              assertLocalMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);
              assertRemoteMedia(engine, kind === `audio` ? `recvonly` : `sendrecv`, kind === `video` ? `recvonly` : `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.unpauseSendingMedia(kind);
              assert.isTrue(engine.pc.getSenders().find((s) => s.track.kind === kind).track.enabled);
              assert.isTrue(engine.localMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy));
        });
      });

      describe(`#(un)pauseReceivingMedia(${kind})`, () => {
        it(`pauses the outgoing ${kind} stream but does not trigger renegotiation`, () => {
          const engine = new WebRTCMediaEngine();
          engine.setMedia(`audio`, `sendrecv`);
          engine.setMedia(`video`, `sendrecv`);
          const spy = sinon.spy();

          return engine.createOffer()
            .then(mockAnswer)
            .then((answer) => Promise.all([
              new Promise((resolve) => engine.once(`track`, resolve)),
              engine.acceptAnswer(answer)
            ]))
            .then(() => {
              assertLocalMedia(engine, `sendrecv`, `sendrecv`);
              assertRemoteMedia(engine, `sendrecv`, `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.pauseReceivingMedia(kind);
              assert.isFalse(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
              assert.isFalse(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy))
            .then(() => {
              assertLocalMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);
              assertRemoteMedia(engine, kind === `audio` ? `sendonly` : `sendrecv`, kind === `video` ? `sendonly` : `sendrecv`);

              engine.on(`negotiationneeded`, spy);
              engine.unpauseReceivingMedia(kind);
              assert.isTrue(engine.pc.getRemoteStreams()[0].getTracks().find((t) => t.kind === kind).enabled);
              assert.isTrue(engine.remoteMediaStream.getTracks().find((t) => t.kind === kind).enabled);
              // I don't know a better way to assert an event doesn't fire than
              // to wait a while and assert it didn't fire.
              return new Promise((resolve) => setTimeout(resolve, 500));
            })
            .then(() => assert.notCalled(spy));
        });
      });

    });

    describe(`custom track`, () => {
      let engine;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
      });

      afterEach(() => {
        engine.stop();
      });

      it(`adds a track without internally calling getusermedia`, () => {
        let track;
        const spy = sinon.spy(engine, `_getUserMedia`);

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            new Promise((resolve) => engine.once(`track`, resolve)),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assert.notCalled(spy);
            assertLocalMedia(engine, `sendrecv`, `inactive`);
          });
      });

      it(`adds an external track without clobbering it`, () => {
        let track;

        return WebRTCMediaEngine.getUserMedia({
          audio: true,
          video: false
        })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            engine.setMedia(`audio`, `sendrecv`, track);
            engine.setMedia(`video`, `sendrecv`);

            assert.lengthOf(engine.localMediaStream.getTracks(), 1);
            assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

            return engine.createOffer();
          })
          .then(mockAnswer)
          .then((answer) => Promise.all([
            new Promise((resolve) => engine.once(`track`, resolve)),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        let track;

        engine.setMedia(`audio`, `inactive`);
        engine.setMedia(`video`, `sendrecv`);

        assert.lengthOf(engine.localMediaStream.getTracks(), 0);
        assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

        return engine.createOffer()
          .then(mockAnswer)
          .then((answer) => Promise.all([
            new Promise((resolve) => engine.once(`track`, resolve)),
            engine.acceptAnswer(answer)
          ]))
          .then(() => {
            assertLocalMedia(engine, `inactive`, `sendrecv`);
            return WebRTCMediaEngine.getUserMedia({
              audio: true,
              video: false
            });
          })
          .then((stream) => {
            track = stream.getAudioTracks()[0];
            assert.isDefined(track);
            engine.setMedia(`audio`, `sendrecv`, track);
            return new Promise((resolve) => engine.once(`negotiationneeded`, resolve));
          })
          .then(() => engine.createOffer())
          .then(mockRenegotiate)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            assert.equal(engine.localMediaStream.getAudioTracks()[0].id, track.id);
            assert.equal(engine.localMediaStream.getAudioTracks()[0], track);
          });
      });
    });

    describe(`custom constraints`, () => {
      let engine, spy;
      beforeEach(() => {
        engine = new WebRTCMediaEngine();
        spy = sinon.spy(WebRTCMediaEngine, `getUserMedia`);
      });

      afterEach(() => {
        engine.stop();
        spy.restore();
      });


      it(`starts a connection with custom constraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`replaces a track with with new contraints`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        engine.setMedia(`video`, `sendrecv`, {
          facingMode: {
            ideal: `user`
          }
        });

        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);
            assert.calledWith(spy, {
              audio: true,
              video: {
                facingMode: {
                  ideal: `user`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return new Promise((resolve) => engine.once(`negotiationneeded`, resolve));
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });

      it(`adds a new track to an inprogress connection`, () => {
        assert.notCalled(spy);
        engine.setMedia(`audio`, `sendrecv`);
        return engine.createOffer()
          .then((offer) => {
            return mockAnswer(offer);
          })
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledOnce(spy);

            assertLocalMedia(engine, `sendrecv`, `inactive`);
            engine.setMedia(`video`, `sendrecv`, {
              facingMode: {
                ideal: `environment`
              }
            });

            return new Promise((resolve) => engine.once(`negotiationneeded`, resolve));
          })
          .then(() => engine.createOffer())
          .then(mockAnswer)
          .then((answer) => engine.acceptAnswer(answer))
          .then(() => {
            assert.calledWith(spy, {
              video: {
                facingMode: {
                  ideal: `environment`
                }
              }
            });

            assertLocalMedia(engine, `sendrecv`, `sendrecv`);
          });
      });
    });
  });
});
