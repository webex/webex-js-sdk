import {
  webrtcHelpers,
  WebRTCMediaEngine
} from '@ciscospark/media-engine-webrtc';
const {
  getMediaDirectionFromSDP,
  reverseMediaDirection
} = webrtcHelpers;
import {assert} from '@ciscospark/test-helper-chai';
import {browserOnly} from '@ciscospark/test-helper-mocha';
import {mockAnswer, mockRenegotiate} from '../lib/offer-answer';
import {
  assertLocalMedia,
  assertRemoteMedia,
  retry,
  getExpectedMediaDirection
} from '../lib/helpers';

browserOnly(describe)(`media-engine-webrtc`, function() {
  this.timeout(60000);
  describe(`WebRTCMediaEngine`, () => {
    describe(`renegotiation`, () => {
      const audioStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const audioEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoStartStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      const videoEndStates = [
        `inactive`,
        `recvonly`,
        `sendonly`,
        `sendrecv`
      ];

      audioStartStates.forEach((audioStart) => {
        audioEndStates.forEach((audioEnd) => {
          videoStartStates.forEach((videoStart) => {
            // all the complexity comes from building the `describe()` block
            // message
            // eslint-disable-next-line complexity
            videoEndStates.forEach((videoEnd) => {
              if (audioStart === `inactive` && videoStart === `inactive`) {
                // not a valid initial state
                return;
              }

              if (audioEnd === `inactive` && videoEnd === `inactive`) {
                return;
              }

              if (audioStart === audioEnd && videoStart === videoEnd) {
                // no changes, therefore nothing to test
                return;
              }

              const expectNewTrack = !audioStart.includes(`recv`) && audioEnd.includes(`recv`) || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);
              const expectToRenegotiate = !audioStart.includes(`send`) && audioEnd.includes(`send`) || !videoStart.includes(`send`) && videoEnd.includes(`send`) || !audioStart.includes(`recv`) && audioEnd.includes(`recv`) || !videoStart.includes(`recv`) && videoEnd.includes(`recv`);

              const message = `when ${[
                audioStart === audioEnd ? `audio is ${audioStart}` : `audio changes from ${audioStart} to ${audioEnd}`,
                videoStart === videoEnd ? `video is ${videoStart}` : `video changes from ${videoStart} to ${videoEnd}`
              ]
                .filter((m) => m)
                .join(` and `)}`;

              describe(message, () => {
                // Note: This describe block is stateful; `it()` statements must
                // execute in order.
                let engine;
                before(() => {
                  engine = new WebRTCMediaEngine();
                });

                after(() => {
                  engine.stop();
                });

                it(`initiates a session with audio=${audioStart} and video=${videoStart}`, () => {
                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  assert.lengthOf(engine.localMediaStream.getTracks(), 0);
                  assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                  return engine.createOffer()
                    .then((offer) => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);

                      assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      return offer;
                    })
                    .then(mockAnswer)
                    .then((answer) => {
                      assertLocalMedia(engine, audioStart, videoStart);

                      assert.lengthOf(engine.remoteMediaStream.getTracks(), 0);
                      assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));
                      assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (audioStart.includes(`recv`) || videoStart.includes(`recv`)) && new Promise((resolve) => engine.once(`track`, resolve)),
                      engine.acceptAnswer(answer)
                    ]))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);

                      assert.equal(engine.audioDirection, audioStart);
                      assert.equal(engine.videoDirection, videoStart);
                    });
                });

                it(`transitions to audio=${audioEnd} and video=${videoEnd}`, () => {
                  engine.setMedia(`audio`, audioEnd);
                  engine.setMedia(`video`, videoEnd);

                  return Promise.all([
                    expectToRenegotiate && new Promise((resolve) => engine.once(`negotiationneeded`, resolve))
                      .then(() => retry(() => assertLocalMedia(engine, audioEnd, videoEnd)))
                      .then(() => engine.createOffer())
                      .then((offer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a
                          // remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioEnd, audioStart));
                        }
                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), videoEnd);
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoEnd, videoStart));
                        }
                        return offer;
                      })
                      .then(mockRenegotiate)
                      .then((answer) => {
                        try {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioEnd));

                        }
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        catch (err) {
                          assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioEnd, audioStart)));
                        }

                        try {
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoEnd));
                        }
                        catch (err) {
                          // Need to fallback since firefox can't remove a remote stream but chrome can
                          assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoEnd, videoStart)));
                        }
                        return answer;
                      })
                      .then((answer) => engine.acceptAnswer(answer)),
                    expectNewTrack && Promise.race([
                      new Promise((resolve) => engine.once(`track`, resolve)),
                      new Promise((resolve, reject) => setTimeout(() => reject(new Error(`Expected track not added`)), 40000))
                    ])
                  ])
                  .then(() => {
                    assertLocalMedia(engine, audioEnd, videoEnd);
                    assertRemoteMedia(engine, audioEnd, videoEnd);
                    assert.equal(engine.audioDirection, audioEnd);
                    assert.equal(engine.videoDirection, videoEnd);
                  });
                });

                it(`returns to audio=${audioStart} and video=${videoStart}`, () => {
                  const needsLocalAudioTrack = audioStart.includes(`send`) && engine.localMediaStream.getAudioTracks().length === 0;
                  const needsLocalVideoTrack = videoStart.includes(`send`) && engine.localMediaStream.getVideoTracks().length === 0;
                  const needsRemoteAudioTrack = audioStart.includes(`recv`) && engine.remoteMediaStream.getAudioTracks().length === 0;
                  const needsRemoteVideoTrack = videoStart.includes(`recv`) && engine.remoteMediaStream.getVideoTracks().length === 0;
                  const expectToRenegotiateOnReturn = needsLocalAudioTrack || needsLocalVideoTrack || needsRemoteAudioTrack || needsRemoteVideoTrack;

                  engine.setMedia(`audio`, audioStart);
                  engine.setMedia(`video`, videoStart);

                  return Promise.resolve(expectToRenegotiateOnReturn && new Promise((resolve) => engine.once(`negotiationneeded`, resolve))
                    .then(() => engine.createOffer())
                    .then((offer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), audioStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a
                        // remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`audio`, offer), getExpectedMediaDirection(audioStart, audioEnd));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), videoStart);
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, offer), getExpectedMediaDirection(videoStart, videoEnd));
                      }

                      return offer;
                    })
                    .then(mockRenegotiate)
                    .then((answer) => {
                      try {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(audioStart));

                      }
                      // Need to fallback since firefox can't remove a remote stream but chrome can
                      catch (err) {
                        assert.equal(getMediaDirectionFromSDP(`audio`, answer), reverseMediaDirection(getExpectedMediaDirection(audioStart, audioEnd)));
                      }

                      try {
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(videoStart));
                      }
                      catch (err) {
                        // Need to fallback since firefox can't remove a remote stream but chrome can
                        assert.equal(getMediaDirectionFromSDP(`video`, answer), reverseMediaDirection(getExpectedMediaDirection(videoStart, videoEnd)));
                      }

                      return answer;
                    })
                    .then((answer) => Promise.all([
                      (needsRemoteAudioTrack || needsRemoteVideoTrack) && new Promise((resolve) => engine.once(`track`, resolve)),
                      engine.acceptAnswer(answer)
                    ])))
                    .then(() => {
                      assertLocalMedia(engine, audioStart, videoStart);
                      assertRemoteMedia(engine, audioStart, videoStart);

                      assert.equal(engine.audioDirection, audioStart);
                      assert.equal(engine.videoDirection, videoStart);
                    });
                });
              });
            });
          });
        });
      });
    });
  });
});
