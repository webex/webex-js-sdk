import {assert} from '@ciscospark/test-helper-chai';
import {find} from 'lodash';
import {parse} from 'sdp-transform';

let pc;
export function mockAnswer(offer) {
  if (pc && pc.signalingState !== `closed`) {
    pc.getSenders().forEach((s) => s.track.stop());
    pc.close();
  }
  pc = new RTCPeerConnection();

  return navigator.mediaDevices.getUserMedia({
    audio: true,
    video: true,
    fake: true
  })
    .then((stream) => {
      pc.addStream(stream);
    })
    .then(() => pc.setRemoteDescription({type: `offer`, sdp: offer}))
    .then(() => pc.createAnswer())
    .then((answer) => pc.setLocalDescription(answer)
      .then(() => answer.sdp));
}

export function mockRenegotiate(offer) {
  const sdp = parse(offer);
  const wantsAudio = find(sdp.media, {type: `audio`}) && find(sdp.media, {type: `audio`}).direction.includes(`recv`);
  const wantsVideo = find(sdp.media, {type: `video`}) && find(sdp.media, {type: `video`}).direction.includes(`recv`);

  const hasAudio = !!pc.getLocalStreams()[0].getAudioTracks().length;
  const hasVideo = !!pc.getLocalStreams()[0].getVideoTracks().length;

  if (hasAudio && !wantsAudio) {
    console.info(`removing audio track from mock peer`);
    pc.getLocalStreams()[0].getAudioTracks()[0].stop();
    pc.getLocalStreams()[0].removeTrack(pc.getLocalStreams()[0].getAudioTracks()[0]);
  }

  if (hasVideo && !wantsVideo) {
    console.info(`removing video track from mock peer`);
    pc.getLocalStreams()[0].getVideoTracks()[0].stop();
    pc.getLocalStreams()[0].removeTrack(pc.getLocalStreams()[0].getVideoTracks()[0]);
  }

  let p;
  if (wantsAudio && !hasAudio || wantsVideo && !hasVideo) {
    p = navigator.mediaDevices.getUserMedia({
      audio: wantsAudio && !hasAudio,
      video: wantsVideo && !hasVideo,
      fake: true
    })
      .then((newstream) => {
        newstream.getTracks().forEach((track) => {
          console.info(`adding ${track.kind} track to mock peer`);
          pc.getLocalStreams()[0].addTrack(track);
          console.info(`mock peer now has ${pc.getLocalStreams()[0].getTracks().filter((t) => t.kind === track.kind).length} ${track.kind} tracks`);
        });
      });
  }

  return Promise.resolve(p)
    .then(() => {
      assert.isBelow(pc.getLocalStreams().length, 2, `There is never more than one local stream`);
      if (pc.getLocalStreams().length) {
        assert.isBelow(pc.getLocalStreams()[0].getAudioTracks().length, 2, `there is never more than one local audio track`);
        assert.isBelow(pc.getLocalStreams()[0].getVideoTracks().length, 2, `there is never more than one local video track`);
        console.info(`MOCK TRACKS`);
        console.info(`audio`, pc.getLocalStreams()[0].getAudioTracks().map((track) => track.id));
        console.info(`video`, pc.getLocalStreams()[0].getVideoTracks().map((track) => track.id));
        console.info(`END MOCK TRACKS`);
      }
    })
    .then(() => pc.setRemoteDescription({type: `offer`, sdp: offer}))
    .then(() => pc.createAnswer())
    .then((answer) => pc.setLocalDescription(answer)
      .then(() => answer.sdp));
}
