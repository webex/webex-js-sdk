import {assert} from '@ciscospark/test-helper-chai';
import {find} from 'lodash';
import {parse} from 'sdp-transform';

let pc;
export function mockAnswer(offer) {
  const parsed = parse(offer);

  console.log(`mockAnswering an sdp with ${parsed.media.length} media sections`);
  if (pc && pc.signalingState !== 'closed') {
    pc.getSenders().forEach((s) => s.track && s.track.stop());
    pc.close();
  }
  pc = new RTCPeerConnection();
  return navigator.mediaDevices.getUserMedia({
    audio: true,
    video: true,
    fake: true
  })
    .then((stream) => {
      pc.addStream(stream);
    })
    .then(() => pc.setRemoteDescription({type: 'offer', sdp: offer}))
    .then(() => pc.createAnswer())
    .then((answer) => pc.setLocalDescription(answer)
      .then(() => answer.sdp))
    .then((answer) => {
      const slides = find(parsed.media, {
        content: 'slides',
        type: 'video'
      });
      if (slides) {
        const [a, b] = answer.split(`a=mid:${slides.mid}`);
        answer = [a, `a=mid:${slides.mid}`, '\r\na=content:slides', b].join('');
      }
      console.log(`mockAnswering with ${parsed.media.length} media sections`);
      return answer;
    });
}

export function mockRenegotiate(offer) {
  const sdp = parse(offer);
  console.log(`mockAnswering an sdp with ${sdp.media.length} media sections`);

  const wantsAudio = find(sdp.media, {type: 'audio'}) && find(sdp.media, {type: 'audio'}).direction.includes('recv');
  const wantsVideo = find(sdp.media, {type: 'video'}) && find(sdp.media, {type: 'video'}).direction.includes('recv');

  const hasAudio = !!pc.getLocalStreams()[0].getAudioTracks().length;
  const hasVideo = !!pc.getLocalStreams()[0].getVideoTracks().length;

  if (hasAudio && !wantsAudio) {
    console.info('removing audio track from mock peer');
    pc.getLocalStreams()[0].getAudioTracks()[0].stop();
    pc.getLocalStreams()[0].removeTrack(pc.getLocalStreams()[0].getAudioTracks()[0]);
  }

  if (hasVideo && !wantsVideo) {
    console.info('removing video track from mock peer');
    pc.getLocalStreams()[0].getVideoTracks()[0].stop();
    pc.getLocalStreams()[0].removeTrack(pc.getLocalStreams()[0].getVideoTracks()[0]);
  }

  let p;
  if (wantsAudio && !hasAudio || wantsVideo && !hasVideo) {
    p = navigator.mediaDevices.getUserMedia({
      audio: wantsAudio && !hasAudio,
      video: wantsVideo && !hasVideo,
      fake: true
    })
      .then((newstream) => {
        newstream.getTracks().forEach((track) => {
          console.info(`adding ${track.kind} track to mock peer`);
          pc.getLocalStreams()[0].addTrack(track);
          console.info(`mock peer now has ${pc.getLocalStreams()[0].getTracks().filter((t) => t.kind === track.kind).length} ${track.kind} tracks`);
        });
      });
  }

  return Promise.resolve(p)
    .then(() => {
      assert.isBelow(pc.getLocalStreams().length, 2, 'There is never more than one local stream');
      if (pc.getLocalStreams().length) {
        assert.isBelow(pc.getLocalStreams()[0].getAudioTracks().length, 2, 'there is never more than one local audio track');
        assert.isBelow(pc.getLocalStreams()[0].getVideoTracks().length, 2, 'there is never more than one local video track');
        console.info('MOCK TRACKS');
        console.info('audio', pc.getLocalStreams()[0].getAudioTracks().map((track) => track.id));
        console.info('video', pc.getLocalStreams()[0].getVideoTracks().map((track) => track.id));
        console.info('END MOCK TRACKS');
      }
    })
    .then(() => pc.setRemoteDescription({type: 'offer', sdp: offer}))
    .then(() => pc.createAnswer())
    .then((answer) => pc.setLocalDescription(answer)
      .then(() => answer.sdp))
    .then((answer) => {
      const slides = find(sdp.media, {
        content: 'slides',
        type: 'video'
      });
      if (slides) {
        const [a, b] = answer.split(`a=mid:${slides.mid}`);
        answer = [a, `a=mid:${slides.mid}`, '\r\na=content:slides', b].join('');
      }
      console.log(`mockAnswering with ${sdp.media.length} media sections`);
      return answer;
    });
}
