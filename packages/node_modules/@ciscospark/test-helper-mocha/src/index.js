/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

// This rule only seems to effect lint-staged; `npm run lint` doesn't fail on it
/* eslint-disable no-implicit-globals */

'use strict';

var browser = require('bowser');

function inNode() {
  return typeof window === 'undefined';
}

function inBrowser() {
  return !inNode();
}

function inFirefox() {
  return browser.firefox;
}

function noop() {
  // intentionally empty
}

module.exports = {
  /**
   * Wrap the desired mochaMethod with `flaky` to indicate it's a flaky test and
   * exclude it from the cloudapps pipeline
   * example:
   * `flaky(it)('sometimes passes and sometimes failes')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  flaky: function flaky(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return process.env.SKIP_FLAKY_TESTS ? mochaMethod.skip : mochaMethod;
  },

  inBrowser: inBrowser,

  inNode: inNode,

  /**
   * Wrap the desired mochaMethod with `skipInBrowser` to prevent the
   * corresponding test or group of tests from running in a web browser
   * example:
   * `skipInBrowser(it)('does a thing that only works in node')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInBrowser: function skipInBrowser(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inBrowser() ? mochaMethod.skip : mochaMethod;
  },

  /**
   * Wrap the desired mochaMethod with `skipInNode` to prevent the
   * corresponding test or group of tests from running in node.
   * example:
   * `skipInNode(it)('does a thing that only works in a web browser')`
   * @param {Function} mochaMethod `it` or `describe`
   * @returns {Function} mochaMethod or mochaMethod.skip
   */
  skipInNode: function skipInNode(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inNode() ? mochaMethod.skip : mochaMethod;
  },

  skipInFirefox: function skipInFirefox(mochaMethod) {
    // If mochaMethod doesn't have a skip method, assume that mochaMethod is
    // already either a .skip or a .only
    if (!mochaMethod.skip) {
      return mochaMethod;
    }
    return inFirefox() ? mochaMethod.skip : mochaMethod;
  },

  /**
   * Similar to skipInNode in that it prevents the test from running, but goes a
   * step further to hide it from the list of skipped tests. Should be used when
   * the test will never be valid in NodeJS
   * @param {Function} mochaMethod
   * @returns {Function}
   */
  browserOnly: function browserOnly(mochaMethod) {
    return inBrowser() ? mochaMethod : noop;
  },

  /**
   * Similar to skipInBrowser in that it prevents the test from running, but
   * goes a step further to hide it from the list of skipped tests. Should be
   * used when the test will never be valid in a Browser
   * @param {Function} mochaMethod
   * @returns {Function}
   */
  nodeOnly: function nodeOnly(mochaMethod) {
    return inNode() ? mochaMethod : noop;
  },

  /**
   * A lot of failures get produced by EventEmitters, which makes them difficult to
   * detect in tests (they just look like timeouts). This is a test helper that
   * captures that error and turns it into a rejected promise
   * @param {EventEmitter} emitter
   * @param {Function} fn
   * @returns {Promise}
   */
  handleErrorEvent: function handleErrorEvent(emitter, fn) {
    var r;
    var p = new Promise(function executor(resolve, reject) {
      r = reject;
      emitter.once('error', reject);
    });

    var handler = Promise.race([p, fn(emitter)])
      .then(unbind)
      .catch(function catcher(reason) {
        unbind();
        throw reason;
      });

    // Make it possible to add additional emitters
    handler.add = function add(e) {
      e.once('error', r);
    };

    return handler;

    function unbind() {
      try {
        emitter.off('error', r);
      }
      catch (err) {
        // ignore
      }
    }
  },

  /**
   * Returns a promise that resolves when event is fired count times or rejects
   * when max expires
   * @param {number} max
   * @param {number} count
   * @param {string} event
   * @param {EventEmitter} emitter
   * @returns {Promise}
   */
  expectNEvents: function expectNEvents(max, count, event, emitter) {
    var timer;

    return Promise.race([
      new Promise(function setTimer(resolve, reject) {
        timer = setTimeout(function handler() {
          reject(new Error(event + ' did not fire ' + count + ' times within ' + max + 'ms'));
        }, max);
      }),
      new Promise(function eventEmitter(resolve) {
        var currentCount = 0;

        emitter.on(event, fn);

        function fn() {
          currentCount += 1;
          if (currentCount === count) {
            emitter.off(event, fn);
            clearTimeout(timer);
            resolve();
          }
        }
      })
    ]);
  },

  /**
   * @param {number} max
   * @param {string} event
   * @param {EventEmitter} emitter
   * @param {string} msg
   * @returns {Promise<mixed>} Resolves with the results of the event
   */
  expectEvent: function expectEvent(max, event, emitter, msg) {
    var timer;
    return Promise.race([
      new Promise(function setTimer(resolve, reject) {
        timer = setTimeout(function handler() {
          reject(new Error(msg || event + ' did not fire within ' + max + 'ms'));
        }, max);
      }),
      new Promise(function eventEmitter(resolve) {
        emitter.once(event, function onEvent(result) {
          clearTimeout(timer);
          resolve(result);
        });
      })
    ]);
  },

  maxWaitForEvent: function maxWaitForEvent(max, event, emitter) {
    return Promise.race([
      new Promise(function timer(resolve) {
        setTimeout(resolve, max);
      }),
      new Promise(function eventEmitter(resolve) {
        emitter.once(event, resolve);
      })
    ]);
  },

  maxWaitForPromise: function maxWaitForPromise(timeout, promise) {
    return Promise.race([
      promise,
      new Promise(function executor(resolve, reject) {
        setTimeout(function timer() {
          reject(new Error('Timeout of ' + timeout + ' expired before promise completed'));
        }, timeout);
      })
    ]);
  }
};
