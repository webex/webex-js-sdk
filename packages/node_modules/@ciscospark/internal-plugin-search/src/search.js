/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {get} from 'lodash';
import {oneFlight} from '@ciscospark/common';
import {StatelessSparkPlugin} from '@ciscospark/spark-core';

export default class Search extends StatelessSparkPlugin {
  namespace = 'Search';

  @oneFlight
  bindSearchKey() {
    return this.spark.internal.encryption.kms.createUnboundKeys({count: 1})
      .then(([key]) => this.spark.internal.encryption.kms.createResource({
        key,
        userIds: [this.spark.internal.device.userId]
      })
        .then(() => this.spark.internal.device.set('searchEncryptionKeyUrl', key.uri)));
  }

  people(options) {
    options = options || {};

    if (!options.queryString && options.query) {
      options.queryString = options.query;
      Reflect.deleteProperty(options, 'query');
    }

    if (!options.queryString) {
      return Promise.reject(new Error('`options.query` is required'));
    }

    return this.request({
      api: 'argonaut',
      resource: 'directory',
      method: 'POST',
      body: options
    })
      .then((res) => res.body);
  }

  search(options) {
    /* eslint max-nested-callbacks: [0] */
    options = options || {};

    if (!options.query) {
      return Promise.resolve([]);
    }

    let promise = Promise.resolve();
    if (!this.spark.internal.device.searchEncryptionKeyUrl) {
      promise = this.bindSearchKey();
    }

    return promise
      .then(() => this.spark.request({
        service: 'argonaut',
        resource: 'search',
        method: 'POST',
        body: Object.assign(options, {
          searchEncryptionKeyUrl: this.spark.internal.device.searchEncryptionKeyUrl
        })
      }))
      .then((res) => get(res, 'body.activities.items') || []);
  }
}
