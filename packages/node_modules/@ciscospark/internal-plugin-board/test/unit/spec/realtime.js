/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import MockSocket from '@ciscospark/test-helper-mock-socket';
import {ConnectionError, NotAuthorized} from '@ciscospark/internal-plugin-mercury';
import sinon from '@ciscospark/test-helper-sinon';
import Board, {config} from '@ciscospark/internal-plugin-board';
import uuid from 'uuid';

function delay(timeout) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeout);
  });
}

describe(`plugin-board`, () => {
  describe(`realtime`, () => {
    let spark;
    const encryptedData = `encryptedData`;
    const fakeURL = `fakeURL`;
    const mockSocket = new MockSocket();

    beforeEach(() => {
      spark = new MockSpark({
        children: {
          board: Board
        },
        config: {
          board: config.board
        }
      });
      Object.assign(spark.internal, {
        encryption: {
          encryptText: sinon.stub().returns(Promise.resolve(encryptedData))
        }
      });

      spark.internal.board.realtime.set({
        boardBindings: [`binding`],
        boardWebSocketUrl: fakeURL
      });
      sinon.stub(spark.internal.board.realtime, `_getNewSocket`).returns(mockSocket);
      spark.internal.board.realtime.socket = mockSocket;
    });

    afterEach(() => mockSocket.open.reset());

    describe(`#publish()`, () => {
      const message = {
        payload: {
          data: `fake`
        },
        envelope: {
        }
      };

      const channel = {
        defaultEncryptionKeyUrl: fakeURL
      };

      beforeEach(() => {
        sinon.stub(uuid, `v4`).returns(`stubbedUUIDv4`);
        return spark.internal.board.realtime.publish(channel, message);
      });

      afterEach(() => {
        uuid.v4.restore();
        spark.internal.encryption.encryptText.reset();
      });

      it(`sends encrypted data on the socket`, () => {
        assert.calledOnce(spark.internal.encryption.encryptText);
        assert.calledWith(spark.internal.board.realtime.socket.send, {
          id: uuid.v4(),
          type: `publishRequest`,
          recipients: [{
            alertType: `none`,
            route: `binding`,
            headers: {}
          }],
          data: {
            eventType: `board.activity`,
            payload: `encryptedData`,
            envelope: {
              encryptionKeyUrl: `fakeURL`
            },
            contentType: `STRING`
          }
        });
      });
    });

    describe(`#publishEncrypted()`, () => {

      beforeEach(() => {
        sinon.stub(uuid, `v4`).returns(`stubbedUUIDv4`);
        return spark.internal.board.realtime.publishEncrypted({
          encryptedData: `encryptedData`,
          encryptedKeyUrl: `fakeURL`
        }, `STRING`);
      });

      afterEach(() => {
        spark.internal.board.realtime.boardBindings = [];
        uuid.v4.restore();
        spark.internal.encryption.encryptText.reset();
      });

      it(`sends encrypted data on the socket`, () => {
        assert.notCalled(spark.internal.encryption.encryptText);
        assert.calledWith(spark.internal.board.realtime.socket.send, {
          id: uuid.v4(),
          type: `publishRequest`,
          recipients: [{
            alertType: `none`,
            headers: {},
            route: `binding`
          }],
          data: {
            contentType: `STRING`,
            eventType: `board.activity`,
            envelope: {
              encryptionKeyUrl: `fakeURL`
            },
            payload: `encryptedData`
          }
        });
      });
    });

    describe(`when trying to share mercury connection`, () => {
      let replaceBindingRes;
      let removeBindingRes;
      beforeEach(() => {
        replaceBindingRes = {
          mercuryConnectionServiceClusterUrl: `https://mercury-connection-a5.wbx2.com/v1`,
          binding: `board.a85e2f70-528d-11e6-ad98-bd2acefef905`,
          webSocketUrl: `wss://mercury-connection-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38/messages`,
          sharedWebSocket: true,
          action: `REPLACE`
        };

        removeBindingRes = {
          binding: `board.a85e2f70-528d-11e6-ad98-bd2acefef905`,
          webSocketUrl: `wss://mercury-connection-a.wbx2.com/v1/apps/wx2/registrations/14d6abda-16de-4e02-bf7c-6d2a0e77ec38/messages`,
          sharedWebSocket: false,
          action: `REMOVE`
        };


        sinon.stub(spark.internal.board, `registerToShareMercury`).returns(Promise.resolve(replaceBindingRes));
        sinon.stub(spark.internal.board, `unregisterFromSharedMercury`).returns(Promise.resolve(removeBindingRes));
      });

      afterEach(() => {
        spark.internal.board.registerToShareMercury.restore();
      });

      describe(`#connectToSharedMercury`, () => {
        it(`registers and gets board binding`, () => {
          return spark.internal.board.realtime.connectToSharedMercury()
            .then((res) => {
              assert.isTrue(spark.internal.board.realtime.isSharingMercury);
              assert.deepEqual(res, replaceBindingRes);
            });
        });

        describe(`when connection cannot be shared`, () => {
          it(`opens a second socket with provided webSocketUrl`, () => {
            replaceBindingRes.sharedWebSocket = false;
            return spark.internal.board.realtime.connectToSharedMercury()
              .then((res) => {
                assert.isFalse(spark.internal.board.realtime.isSharingMercury);
                assert.deepEqual(res, replaceBindingRes);
                assert.match(mockSocket.open.args[0][0], new RegExp(replaceBindingRes.webSocketUrl));
                assert.calledWith(mockSocket.open, sinon.match(replaceBindingRes.webSocketUrl), sinon.match.any);
              });
          });
        });
      });

      describe(`#disconnectFromSharedMercury`, () => {
        it(`requests to remove board bindings`, () => {
          return spark.internal.board.realtime.connectToSharedMercury()
            .then(() => {
              assert.isTrue(spark.internal.board.realtime.isSharingMercury);
              return spark.internal.board.realtime.disconnectFromSharedMercury();
            })
            .then((res) => {
              assert.isFalse(spark.internal.board.realtime.isSharingMercury);
              assert.deepEqual(res, removeBindingRes);
            });
        });

        describe(`when a second connection is open`, () => {
          it(`disconnects the second socket`, () => {
            sinon.stub(spark.internal.board.realtime, `disconnect`).returns(Promise.resolve());
            replaceBindingRes.sharedWebSocket = false;
            return spark.internal.board.realtime.connectToSharedMercury()
              .then(() => {
                assert.isFalse(spark.internal.board.realtime.isSharingMercury);
                return spark.internal.board.realtime.disconnectFromSharedMercury();
              })
              .then(() => {
                assert.isFalse(spark.internal.board.realtime.isSharingMercury);
                assert.called(spark.internal.board.realtime.disconnect);
                spark.internal.board.realtime.disconnect.restore();
              });
          });
        });
      });

    });

    describe(`#_boardChannelIdToMercuryBinding`, () => {
      it(`adds board. binding prefix`, () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding(`test`), `board.test`);
      });

      it(`replaces '-' with '.' and '_' with '#'`, () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding(`abc-1234_bcd`), `board.abc.1234#bcd`);
      });

      it(`leaves strings without - and _ alone`, () => {
        assert.equal(spark.internal.board.realtime._boardChannelIdToMercuryBinding(`abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+=`), `board.abcdefghijklmnopqrstuvwxyz0123456789~!@#$%^&*()+=`);
      });
    });

    describe(`#_attemptConnection()`, () => {

      before(() => {
        mockSocket.open.returns(Promise.resolve());
      });

      after(() => {
        mockSocket.open.reset();
      });

      it(`opens socket`, (done) => {
        spark.internal.board.realtime._attemptConnection(() => {
          assert.called(mockSocket.open);
          done();
        });
      });
    });

    describe(`when buffer state event is received`, () => {
      it(`emits the event even before connect promise is resolved`, () => {
        const bufferStateMessage = {
          data: {
            eventType: `mercury.buffer_state`
          }
        };
        const bufferSpy = sinon.spy();
        const onlineSpy = sinon.spy();

        // Buffer state message is emitted after authorization
        spark.credentials.getUserToken = () => Promise.resolve({
          toString() {
            return `Fake Token`;
          }
        })
          .then((token) => {
            assert.notCalled(onlineSpy);
            spark.internal.board.realtime.socket.emit(`message`, {data: bufferStateMessage});
            return token;
          });

        spark.internal.board.realtime.on(`event:mercury.buffer_state`, bufferSpy);
        spark.internal.board.realtime.on(`online`, onlineSpy);

        return assert.isFulfilled(spark.internal.board.realtime.connect())
          .then(() => {
            assert.callCount(onlineSpy, 1);
            assert.callCount(bufferSpy, 1);
            assert.calledWith(bufferSpy, bufferStateMessage);
          });
      });
    });

    describe(`on errors`, () => {

      after(() => {
        mockSocket.open.reset();
        mockSocket.open.returns(Promise.resolve());
        spark.credentials.getUserToken.reset();
      });

      it(`submits connection error to metric`, () => {
        spark.internal.board.config.maxRetries = 1;
        mockSocket.open.returns(Promise.reject(new ConnectionError()));
        return assert.isRejected(spark.internal.board.realtime.connect());
      });

      it(`rejects on AuthorizationError`, () => {
        spark.internal.board.config.maxRetries = 1;
        spark.credentials.getUserToken.returns(Promise.reject(new NotAuthorized()));
        return assert.isRejected(spark.internal.board.realtime.connect());
      });
    });

    describe(`#_onmessage`, () => {
      let fakeEvent;

      beforeEach(() => {
        fakeEvent = {
          id: uuid.v4(),
          data: {
            eventType: `board.activity`,
            actor: {
              id: `actorId`
            },
            conversationId: uuid.v4()
          },
          timestamp: Date.now(),
          trackingId: `suffix_${uuid.v4()}_${Date.now()}`
        };
      });

      it(`emits message`, () => {
        const spy = sinon.spy();
        spark.internal.board.realtime.on(`event:board.activity`, spy);

        return spark.internal.board.realtime.connect()
          .then(() => {
            spark.internal.board.realtime.socket.emit(`message`, {data: fakeEvent});
            return delay(0);
          })
          .then(() => {
            assert.called(spy);
          });
      });

      it(`does not emits when handler not found`, () => {
        fakeEvent.data.eventType = `unhandler`;
        const spy = sinon.spy();
        spark.internal.board.realtime.on(`event:board.activity`, spy);

        return spark.internal.board.realtime._onmessage({data: fakeEvent})
          .then(() => {
            assert.notCalled(spy);
          });
      });
    });
  });
});
