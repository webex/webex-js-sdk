/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import sinon from '@ciscospark/test-helper-sinon';
import Board, {config as boardConfig} from '@ciscospark/internal-plugin-board';

describe(`plugin-board`, () => {
  let spark;
  const encryptedData = `encryptedData`;
  const decryptedText = `decryptedText`;
  const fakeURL = `https://encryption-a.wbx2.com/encryption/api/v1/keys/8a7d3d78-ce75-48aa-a943-2e8acf63fbc9`;
  const file = `dataURL://base64;`;
  const boardServiceUrl = `https://awesome.service.url`;
  const boardId = `boardId`;

  const mockKey = {
    uri: `https://encryption-a.wbx2.com/encryption/api/v1/keys/7ad503ec-854b-4fce-a7f0-182e1997bdb6`
  };

  const image = {
    height: 900,
    width: 1600,
    size: 15000
  };

  const conversation = {
    id: `7c7e69a0-a086-11e6-8670-d7b4b51d7641`,
    defaultActivityEncryptionKeyUrl: fakeURL,
    kmsResourceObjectUrl: `https://encryption-a.wbx2.com/encryption/api/v1/resources/8693f702-2012-40c6-9ec4-f1392f0a620a`,
    aclUrl: `https://acl-a.wbx2.com/acl/api/v1/acls/7ca94a30-a086-11e6-b599-d90deb9846ed`
  };

  const channel = {
    channelUrl: `${boardServiceUrl}/channels/${boardId}`,
    channelId: boardId,
    aclUrlLink: conversation.aclUrl,
    defaultEncryptionKeyUrl: mockKey.uri,
    kmsMessage: {
      method: `create`,
      uri: `/resources`,
      userIds: [conversation.kmsResourceObjectUrl],
      keyUris: []
    }
  };

  const channelRes = {
    channelUrl: `${boardServiceUrl}/channels/${boardId}`,
    channelId: boardId,
    aclUrlLink: conversation.aclUrl,
    defaultEncryptionKeyUrl: mockKey.uri,
    creatorId: `c321e329-28d6-4d52-a9d1-374010411530`,
    kmsMessage: {
      status: 201,
      resource: {
        uri: `https://encryption-a.wbx2.com/encryption/api/v1/resources/2853285c-c46b-4b35-9542-9a81d4e3c87f`,
        keyUris: [`https://encryption-a.wbx2.com/encryption/api/v1/keys/5042787d-510b-46f3-b83c-ea73032de851`],
        authorizationUris: [
          `https://encryption-a.wbx2.com/encryption/api/v1/authorizations/aHR0cHM6Ly9lbmNyeXB0aW9uLWEud2J4Mi5jb20vZW5jcnlwdGlvbi9hcGkvdjEvcmVzb3VyY2VzLzI3OWIyMjgyLWZmYTItNGM3ZC04NGRmLTRkNDVlZmUzYTMzNQBodHRwczovL2VuY3J5cHRpb24tYS53YngyLmNvbS9lbmNyeXB0aW9uL2FwaS92MS9yZXNvdXJjZXMvMjg1MzI4NWMtYzQ2Yi00YjM1LTk1NDItOWE4MWQ0ZTNjODdm`,
          `https://encryption-a.wbx2.com/encryption/api/v1/authorizations/YzMyMWUzMjktMjhkNi00ZDUyLWE5ZDEtMzc0MDEwNDExNTMwAGh0dHBzOi8vZW5jcnlwdGlvbi1hLndieDIuY29tL2VuY3J5cHRpb24vYXBpL3YxL3Jlc291cmNlcy8yODUzMjg1Yy1jNDZiLTRiMzUtOTU0Mi05YTgxZDRlM2M4N2Y`
        ]
      }
    }
  };

  const channelRequestBody = {
    aclUrlLink: channel.aclUrlLink,
    kmsMessage: channel.kmsMessage
  };

  const data1 = {
    contentUrl: `${channel.channelUrl}/contents/data1`,
    contentId: `data1`,
    type: `test`,
    data: `data1`
  };

  const data2 = {
    type: `test`,
    data: `data2`
  };

  before(() => {
    spark = new MockSpark({
      children: {
        board: Board
      },
      request: sinon.stub().returns(Promise.resolve({
        headers: {},
        body: ``
      })),
      upload: sinon.stub().returns(Promise.resolve({body: {downloadUrl: fakeURL}}))
    });

    Object.assign(spark.internal, {
      device: {
        deviceType: `FAKE_DEVICE`,
        getServiceUrl: () => {
          return boardServiceUrl;
        }
      },
      encryption: {
        decryptText: sinon.stub().returns(Promise.resolve(decryptedText)),
        encryptText: sinon.stub().returns(Promise.resolve(encryptedData)),
        encryptBinary: sinon.stub().returns(Promise.resolve({
          scr: {},
          cdata: encryptedData
        })),
        download: sinon.stub().returns(Promise.resolve({
          toArrayBuffer: sinon.stub()
        })),
        decryptScr: sinon.stub().returns(Promise.resolve(`decryptedFoo`)),
        encryptScr: sinon.stub().returns(Promise.resolve(`encryptedFoo`))
      }
    });

    spark.config.board = boardConfig.board;
  });

  describe(`#addContent()`, () => {

    beforeEach(() => {
      spark.request.reset();
    });

    it(`requests POST all contents to contents`, () => {
      return spark.internal.board.addContent(channel, [data1, data2])
        .then(() => {
          assert.calledWith(spark.request, sinon.match({
            method: `POST`,
            uri: `${boardServiceUrl}/channels/${boardId}/contents`,
            body: [{
              device: `FAKE_DEVICE`,
              type: `STRING`,
              encryptionKeyUrl: mockKey.uri,
              payload: `encryptedData`
            }, {
              device: `FAKE_DEVICE`,
              type: `STRING`,
              encryptionKeyUrl: mockKey.uri,
              payload: `encryptedData`
            }]
          }));
        });
    });

    it(`sends large data using multiple requests`, () => {
      const largeData = [];

      for (let i = 0; i < 400; i++) {
        largeData.push({data: i});
      }

      return spark.internal.board.addContent(channel, largeData)
        .then(() => {
          assert.equal(spark.request.callCount, 3);
        });
    });
  });

  describe(`#setSnapshotImage()`, () => {
    beforeEach(() => {
      spark.request.reset();
      sinon.stub(spark.internal.board, `_uploadImageToSparkFiles`).returns(Promise.resolve({
        downloadUrl: fakeURL
      }));
      spark.internal.encryption.encryptScr.reset();
    });

    afterEach(() => {
      spark.internal.board._uploadImageToSparkFiles.restore();
      spark.internal.encryption.encryptScr.reset();
    });

    it(`requests PATCH to board service`, () => {
      return spark.internal.board.setSnapshotImage(channel, image)
        .then(() => {
          assert.calledWith(spark.request, sinon.match({
            method: `PATCH`,
            api: `board`,
            resource: `/channels/${boardId}`,
            body: {
              image: {
                url: fakeURL,
                height: image.height,
                width: image.width,
                mimeType: `image/png`,
                scr: `encryptedFoo`,
                encryptionKeyUrl: channel.defaultEncryptionKeyUrl,
                fileSize: image.size
              }
            }
          }));
        });
    });
  });

  describe(`#createChannel()`, () => {

    before(() => {
      spark.request.reset();
      spark.request.returns(Promise.resolve({statusCode: 200, body: channelRes}));
      return spark.internal.board.createChannel(conversation);
    });

    after(() => {
      // reset request to its original behavior
      spark.request.returns(Promise.resolve({
        headers: {},
        body: ``
      }));
    });

    it(`requests POST to channels service`, () => {
      assert.calledWith(spark.request, sinon.match({
        method: `POST`,
        api: `board`,
        resource: `/channels`,
        body: channelRequestBody
      }));
    });
  });

  describe(`#deleteAllContent()`, () => {

    before(() => {
      spark.request.reset();
      return spark.internal.board.deleteAllContent(channel);
    });

    it(`requests DELETE contents`, () => {
      assert.calledWith(spark.request, sinon.match({
        method: `DELETE`,
        uri: `${boardServiceUrl}/channels/${boardId}/contents`
      }));
    });
  });

  describe(`#_uploadImage()`, () => {

    before(() => {
      sinon.stub(spark.internal.board, `_uploadImageToSparkFiles`).returns(Promise.resolve({
        downloadUrl: fakeURL
      }));
      return spark.internal.board._uploadImage(conversation, file);
    });

    after(() => {
      spark.internal.board._uploadImageToSparkFiles.restore();
    });

    it(`encrypts binary file`, () => {
      assert.calledWith(spark.internal.encryption.encryptBinary, file);
    });

    it(`uploads to spark files`, () => {
      assert.calledWith(spark.internal.board._uploadImageToSparkFiles, conversation, encryptedData);
    });
  });

  describe(`#_uploadImageToSparkFiles()`, () => {

    before(() => {
      sinon.stub(spark.internal.board, `_getSpaceUrl`).returns(Promise.resolve(fakeURL));
      return spark.internal.board._uploadImage(conversation, file);
    });

    after(() => spark.internal.board._getSpaceUrl.restore());

    afterEach(() => {
      spark.upload.reset();
      spark.internal.board._getSpaceUrl.reset();
    });


    it(`uses length for upload filesize`, () => {
      const blob = {
        length: 4444,
        size: 3333,
        byteLength: 2222
      };

      return spark.internal.board._uploadImageToSparkFiles(conversation, blob)
        .then(() => {
          assert.calledWith(spark.upload, sinon.match({
            phases: {
              initialize: {
                fileSize: 4444
              },
              finalize: {
                body: {
                  fileSize: 4444
                }
              }
            }
          }));
        });
    });

    it(`uses size for upload filesize when length is not available`, () => {
      const blob = {
        size: 3333,
        byteLength: 2222
      };

      return spark.internal.board._uploadImageToSparkFiles(conversation, blob)
        .then(() => {
          assert.calledWith(spark.upload, sinon.match({
            phases: {
              initialize: {
                fileSize: 3333
              },
              finalize: {
                body: {
                  fileSize: 3333
                }
              }
            }
          }));
        });
    });

    it(`uses byteLenght for upload filesize when length and size are not available`, () => {
      const blob = {
        byteLength: 2222
      };

      return spark.internal.board._uploadImageToSparkFiles(conversation, blob)
        .then(() => {
          assert.calledWith(spark.upload, sinon.match({
            phases: {
              initialize: {
                fileSize: 2222
              },
              finalize: {
                body: {
                  fileSize: 2222
                }
              }
            }
          }));
        });
    });
  });

  describe(`#children`, () => {

    it(`has a child of realtime`, () => {
      assert.isDefined(spark.internal.board.realtime);
    });
  });

  describe(`#encryptContents`, () => {

    before(() => {
      sinon.stub(spark.internal.board, `encryptSingleContent`).returns(Promise.resolve({
        encryptedData,
        encryptionKeyUrl: fakeURL
      }));
    });

    afterEach(() => {
      spark.internal.board.encryptSingleContent.reset();
    });

    it(`calls encryptSingleContent when type is not image`, () => {

      const curveContents = [{
        type: `curve`
      }];

      return spark.internal.board.encryptContents(fakeURL, curveContents)
        .then(() => {
          assert.calledWith(spark.internal.board.encryptSingleContent, fakeURL, curveContents[0]);
          assert.notCalled(spark.internal.encryption.encryptScr);
        });
    });

    it(`calls encryptText and encryptScr when scr is found in content`, () => {

      const imageContents = [{
        displayName: `FileName`,
        file: {
          scr: {
            loc: fakeURL
          }
        }
      }];

      return spark.internal.board.encryptContents(fakeURL, imageContents)
        .then(() => {
          assert.calledWith(spark.internal.encryption.encryptScr, fakeURL, {loc: fakeURL});
          assert.calledWith(spark.internal.encryption.encryptText, fakeURL, JSON.stringify({displayName: `FileName`}));
        });
    });

    it(`sets the device to config deviceType`, () => {
      const curveContents = [{
        type: `curve`
      }];

      return spark.internal.board.encryptContents(fakeURL, curveContents)
        .then((res) => {
          assert.equal(res[0].device, `FAKE_DEVICE`);
        });
    });
  });

  describe(`#decryptContents`, () => {

    before(() => {
      sinon.stub(spark.internal.board, `decryptSingleContent`, sinon.stub().returns(Promise.resolve({})));
      sinon.spy(spark.internal.board, `decryptSingleFileContent`);
    });

    after(() => {
      spark.internal.board.decryptSingleContent.restore();
      spark.internal.board.decryptSingleFileContent.restore();
    });

    afterEach(() => {
      spark.internal.board.decryptSingleContent.reset();
      spark.internal.board.decryptSingleFileContent.reset();
      spark.internal.encryption.decryptScr.reset();
      spark.internal.encryption.decryptText.reset();
    });

    it(`calls decryptSingleContent when type is not image`, () => {

      const curveContents = {
        items: [{
          type: `STRING`,
          payload: encryptedData,
          encryptionKeyUrl: fakeURL
        }]
      };

      return spark.internal.board.decryptContents(curveContents)
        .then(() => {
          assert.calledWith(spark.internal.board.decryptSingleContent, fakeURL, encryptedData);
          assert.notCalled(spark.internal.encryption.decryptScr);
          assert.notCalled(spark.internal.encryption.decryptText);
        });
    });

    it(`calls decryptSingleFileContent when type is FILE`, () => {
      const imageContents = {
        items: [{
          type: `FILE`,
          payload: JSON.stringify({
            type: `image`,
            displayName: `encryptedDisplayName`
          }),
          file: {
            scr: `encryptedScr`
          },
          encryptionKeyUrl: fakeURL
        }]
      };

      return spark.internal.board.decryptContents(imageContents)
        .then(() => {
          assert.calledOnce(spark.internal.board.decryptSingleFileContent);
          assert.calledWith(spark.internal.encryption.decryptText, fakeURL, JSON.stringify({type: `image`, displayName: `encryptedDisplayName`}));
          assert.calledWith(spark.internal.encryption.decryptScr, fakeURL, `encryptedScr`);
        });
    });

    it(`does not require payload when type is FILE`, () => {
      const imageContents = {
        items: [{
          type: `FILE`,
          file: {
            scr: `encryptedScr`
          },
          encryptionKeyUrl: fakeURL
        }]
      };

      return spark.internal.board.decryptContents(imageContents)
        .then(() => {
          assert.calledOnce(spark.internal.board.decryptSingleFileContent);
          assert.notCalled(spark.internal.encryption.decryptText);
          assert.calledWith(spark.internal.encryption.decryptScr, fakeURL, `encryptedScr`);
        });
    });
  });

  describe(`#getChannel()`, () => {

    before(() => {
      spark.request.reset();
      return spark.internal.board.getChannel(channel);
    });

    it(`requests GET to channels service`, () => {
      assert.calledWith(spark.request, sinon.match({
        method: `GET`,
        uri: `${boardServiceUrl}/channels/${boardId}`
      }));
    });

    it(`requires conversationId`, () => {
      return assert.isRejected(spark.internal.board.getChannels(), `\`conversation\` is required`);
    });

  });


  describe(`#getContents()`, () => {

    beforeEach(() => {
      sinon.stub(spark.internal.board, `decryptContents`).returns([`foo`]);
      spark.request.reset();
    });

    afterEach(() => {
      spark.internal.board.decryptContents.restore();
    });

    it(`requests GET contents with default page size`, () => spark.internal.board.getContents(channel)
      .then(() => assert.calledWith(spark.request, {
        uri: `${boardServiceUrl}/channels/${boardId}/contents`,
        qs: {
          contentsLimit: boardConfig.board.numberContentsPerPageForGet
        }
      })));

    it(`requests GET contents with client defined page size`, () => spark.internal.board.getContents(channel, {contentsLimit: 25})
      .then(() => assert.calledWith(spark.request, {
        uri: `${boardServiceUrl}/channels/${boardId}/contents`,
        qs: {
          contentsLimit: 25
        }
      })));
  });

  describe(`#register()`, () => {

    before(() => {
      spark.request.reset();
      return spark.internal.board.register({data: `data`});
    });

    it(`requests POST data to registration service`, () => {
      assert.calledWith(spark.request, sinon.match({
        method: `POST`,
        api: `board`,
        resource: `/registrations`
      }));
    });
  });

  describe(`#registerToShareMercury()`, () => {

    beforeEach(() => {
      spark.request.reset();
      spark.internal.mercury.localClusterServiceUrls = {
        mercuryApiServiceClusterUrl: `https://mercury-api-a5.wbx2.com/v1`,
        mercuryConnectionServiceClusterUrl: `https://mercury-connection-a5.wbx2.com/v1`
      };
      spark.internal.feature.getFeature.returns(Promise.resolve(true));
    });

    it(`requests POST data to registration service`, () => {
      return spark.internal.board.registerToShareMercury(channel)
        .then(() => {
          assert.calledWith(spark.request, sinon.match({
            method: `POST`,
            uri: `${channel.channelUrl}/register`,
            body: {
              mercuryConnectionServiceClusterUrl: spark.internal.mercury.localClusterServiceUrls.mercuryConnectionServiceClusterUrl,
              webSocketUrl: spark.internal.device.webSocketUrl,
              action: `REPLACE`
            }
          }));
        });
    });

    it(`rejects when localClusterServiceUrls is null`, () => {
      spark.internal.mercury.localClusterServiceUrls = null;
      return assert.isRejected(spark.internal.board.registerToShareMercury(channel));
    });

    it(`rejects when web-shared-mercury is not enabled`, () => {
      spark.internal.feature.getFeature.returns(Promise.resolve(false));
      return assert.isRejected(spark.internal.board.registerToShareMercury(channel));
    });
  });
});
