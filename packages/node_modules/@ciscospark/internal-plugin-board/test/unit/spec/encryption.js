/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import sinon from '@ciscospark/test-helper-sinon';
import Board, {config as boardConfig} from '@ciscospark/internal-plugin-board';

describe('plugin-board', () => {
  let spark;
  const encryptedData = 'encryptedData';
  const decryptedText = 'decryptedText';
  const fakeURL = `${process.env.ENCRYPTION_SERVICE_URL || 'https://encryption-a.wbx2.com'}/encryption/api/v1/keys/8a7d3d78-ce75-48aa-a943-2e8acf63fbc9`;

  before(() => {
    spark = new MockSpark({
      children: {
        board: Board
      }
    });

    Object.assign(spark.internal, {
      device: {
        deviceType: 'FAKE_DEVICE'
      },
      encryption: {
        decryptText: sinon.stub().returns(Promise.resolve(decryptedText)),
        encryptText: sinon.stub().returns(Promise.resolve(encryptedData)),
        encryptBinary: sinon.stub().returns(Promise.resolve({
          scr: {},
          cdata: encryptedData
        })),
        decryptScr: sinon.stub().returns(Promise.resolve('decryptedFoo')),
        encryptScr: sinon.stub().returns(Promise.resolve('encryptedFoo'))
      }
    });

    spark.config.board = boardConfig.board;
  });

  describe('encryption', () => {
    describe('#decryptContents', () => {
      before(() => {
        sinon.stub(spark.internal.board, 'decryptSingleContent').callsFake(sinon.stub().returns(Promise.resolve({})));
        sinon.spy(spark.internal.board, 'decryptSingleFileContent');
      });

      after(() => {
        spark.internal.board.decryptSingleContent.restore();
        spark.internal.board.decryptSingleFileContent.restore();
      });

      afterEach(() => {
        spark.internal.board.decryptSingleFileContent.reset();
        spark.internal.board.decryptSingleContent.resetHistory();
        spark.internal.encryption.decryptScr.resetHistory();
        spark.internal.encryption.decryptText.resetHistory();
      });

      it('calls decryptSingleContent when type is not image', () => {
        const curveContents = {
          items: [{
            type: 'STRING',
            payload: encryptedData,
            encryptionKeyUrl: fakeURL
          }]
        };

        return spark.internal.board.decryptContents(curveContents)
          .then(() => {
            assert.calledWith(spark.internal.board.decryptSingleContent, fakeURL, encryptedData);
            assert.notCalled(spark.internal.encryption.decryptScr);
            assert.notCalled(spark.internal.encryption.decryptText);
          });
      });

      it('calls decryptSingleFileContent when type is FILE', () => {
        const imageContents = {
          items: [{
            type: 'FILE',
            payload: JSON.stringify({
              type: 'image',
              displayName: 'encryptedDisplayName'
            }),
            file: {
              scr: 'encryptedScr'
            },
            encryptionKeyUrl: fakeURL
          }]
        };

        return spark.internal.board.decryptContents(imageContents)
          .then(() => {
            assert.calledOnce(spark.internal.board.decryptSingleFileContent);
            assert.calledWith(spark.internal.encryption.decryptText, fakeURL, JSON.stringify({type: 'image', displayName: 'encryptedDisplayName'}));
            assert.calledWith(spark.internal.encryption.decryptScr, fakeURL, 'encryptedScr');
          });
      });

      it('does not require payload when type is FILE', () => {
        const imageContents = {
          items: [{
            type: 'FILE',
            file: {
              scr: 'encryptedScr'
            },
            encryptionKeyUrl: fakeURL
          }]
        };

        return spark.internal.board.decryptContents(imageContents)
          .then(() => {
            assert.calledOnce(spark.internal.board.decryptSingleFileContent);
            assert.notCalled(spark.internal.encryption.decryptText);
            assert.calledWith(spark.internal.encryption.decryptScr, fakeURL, 'encryptedScr');
          });
      });

      it('decrypts FILE metadata displayName', () => {
        const imageContentsWithMetadata = {
          items: [{
            type: 'FILE',
            payload: JSON.stringify({
              type: 'image',
              displayName: 'encryptedDisplayName'
            }),
            file: {
              scr: 'encryptedScr'
            },
            encryptionKeyUrl: fakeURL
          }]
        };

        spark.internal.encryption.decryptText.onFirstCall().returns(JSON.stringify({displayName: 'decryptedDisplayName'}));

        return spark.internal.board.decryptContents(imageContentsWithMetadata)
          .then((contents) => {
            assert.calledOnce(spark.internal.board.decryptSingleFileContent);
            assert.calledWith(spark.internal.encryption.decryptScr, fakeURL, 'encryptedScr');
            assert.calledWith(spark.internal.encryption.decryptText, fakeURL, JSON.stringify({type: 'image', displayName: 'encryptedDisplayName'}));
            assert.equal(contents[0].metadata.displayName, 'decryptedDisplayName');
          });
      });

      it('assigns FILE payload metadata to decrypted file', () => {
        const imageContentsWithMetadata = {
          items: [{
            type: 'FILE',
            payload: JSON.stringify({
              type: 'image',
              size: 123
            }),
            file: {
              scr: 'encryptedScr'
            },
            encryptionKeyUrl: fakeURL
          }]
        };

        spark.internal.encryption.decryptText.onFirstCall().returns(JSON.stringify({type: 'image', size: 123}));

        return spark.internal.board.decryptContents(imageContentsWithMetadata)
          .then((contents) => {
            assert.calledOnce(spark.internal.board.decryptSingleFileContent);
            assert.deepEqual(contents[0].metadata, {
              type: 'image',
              size: 123
            });
          });
      });
    });

    describe('#encryptContents', () => {
      before(() => {
        sinon.stub(spark.internal.board, 'encryptSingleContent').returns(Promise.resolve({
          encryptedData,
          encryptionKeyUrl: fakeURL
        }));
      });

      afterEach(() => {
        spark.internal.board.encryptSingleContent.resetHistory();
      });

      it('calls encryptSingleContent when type is not image', () => {
        const curveContents = [{
          type: 'curve'
        }];

        return spark.internal.board.encryptContents(fakeURL, curveContents)
          .then(() => {
            assert.calledWith(spark.internal.board.encryptSingleContent, fakeURL, curveContents[0]);
            assert.notCalled(spark.internal.encryption.encryptScr);
          });
      });

      it('calls encryptText and encryptScr when scr is found in content', () => {
        const imageContents = [{
          displayName: 'FileName',
          file: {
            scr: {
              loc: fakeURL
            }
          }
        }];

        return spark.internal.board.encryptContents(fakeURL, imageContents)
          .then(() => {
            assert.calledWith(spark.internal.encryption.encryptScr, fakeURL, {loc: fakeURL});
            assert.calledWith(spark.internal.encryption.encryptText, fakeURL, JSON.stringify({displayName: 'FileName'}));
          });
      });

      it('sets the device to config deviceType', () => {
        const curveContents = [{
          type: 'curve'
        }];

        return spark.internal.board.encryptContents(fakeURL, curveContents)
          .then((res) => {
            assert.equal(res[0].device, 'FAKE_DEVICE');
          });
      });
    });
  });
});
