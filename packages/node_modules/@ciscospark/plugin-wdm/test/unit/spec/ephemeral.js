/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {assert} from '@ciscospark/test-helper-chai';
import MockSpark from '@ciscospark/test-helper-mock-spark';
import sinon from '@ciscospark/test-helper-sinon';
import Device, {config} from '@ciscospark/plugin-wdm';
import {cloneDeep} from 'lodash';
import lolex from 'lolex';
import {skipInBrowser} from '@ciscospark/test-helper-mocha';

function promiseTick(count) {
  let promise = Promise.resolve();
  while (count > 1) {
    promise = promise.then(() => {
      return promiseTick(1);
    });
    count -= 1;
  }
  return promise;
}

describe(`plugin-wdm`, () => {
  describe(`Device`, () => {
    let device, spark;

    beforeEach(() => {
      spark = new MockSpark({
        children: {
          device: Device
        },
        config: cloneDeep(config)
      });

      device = spark.device;

      assert.isFalse(spark.device.config.ephemeral);
      assert.equal(spark.device.config.ephemeralDeviceTTL, config.device.ephemeralDeviceTTL);
    });

    afterEach(() => device.unregister());

    let clock;

    beforeEach(() => {
      clock = lolex.install(Date.now());
    });

    afterEach(() => {
      clock.uninstall();
    });

    describe(`#register()`, () => {
      it(`does not included a ttl`, () => spark.device.register()
        .then(() => {
          const req = spark.request.args[0][0];
          assert.notProperty(req, `uri`, `this request hits a service/resource pair, not a uri`);
          assert.notProperty(req.body, `ttl`);
        }));
    });

    describe(`#refresh()`, () => {
      it(`includes a ttl`, () => {
        spark.device.url = `http://example.com/device/id`;
        return spark.device.refresh()
          .then(() => {
            const req = spark.request.args[0][0];
            assert.equal(req.uri, spark.device.url);
            assert.notProperty(req.body, `ttl`);
          });
      });
    });

    describe(`when ephemeral`, () => {

      beforeEach(() => {
        const cfg = cloneDeep(config);
        cfg.device.ephemeral = true;

        spark = new MockSpark({
          children: {
            device: Device
          },
          config: cfg
        });
        assert.isTrue(spark.device.config.ephemeral);
        assert.equal(spark.device.config.ephemeralDeviceTTL, config.device.ephemeralDeviceTTL);
      });

      describe(`#register()`, () => {
        it(`includes a ttl`, () => spark.device.register()
          .then(() => {
            const body = spark.request.args[0][0].body;
            assert.property(body, `ttl`);
            assert.equal(body.ttl, config.device.ephemeralDeviceTTL);
          }));

        // skipping due to an aparent incompatibility between lolex and all
        // browsers but chrome
        skipInBrowser(it)(`periodically refreshes the device`, () => {
          sinon.spy(spark.device, `refresh`);
          spark.device.register();
          return promiseTick(80)
            .then(() => {
              assert.notCalled(spark.device.refresh);
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.notCalled(spark.device.refresh);
              return promiseTick(80);

            })
            .then(() => {
              clock.tick(60 * 1000);
              return promiseTick(80);
            })
            .then(() => {
              assert.calledOnce(spark.device.refresh);
              return promiseTick(4);
            })
            .then(() => {
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.calledOnce(spark.device.refresh);
              clock.tick(60 * 1000);
              assert.calledTwice(spark.device.refresh);
            });
        });
      });

      describe(`#refresh()`, () => {
        it(`includes a ttl`, () => {
          spark.device.url = `http://example.com/device/id`;
          return spark.device.refresh()
            .then(() => {
              const body = spark.request.args[0][0].body;
              assert.property(body, `ttl`);
              assert.equal(body.ttl, config.device.ephemeralDeviceTTL);
            });
        });
      });

      describe(`#unregister()`, () => {
        // skipping due to an aparent incompatibility between lolex and all
        // browsers but chrome
        skipInBrowser(it)(`stops refreshing the device`, () => {
          sinon.spy(spark.device, `refresh`);
          spark.device.register();
          return promiseTick(8)
            .then(() => {
              spark.device.url = `http://example.com/device/id`;
              assert.notCalled(spark.device.refresh);
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.notCalled(spark.device.refresh);
              clock.tick(60 * 1000);
              assert.calledOnce(spark.device.refresh);
              spark.device.unregister();
              // Reminder: for this to be a valid test, the number of ticks on
              // the next line must be at least as many ticks as are advanced in
              // the refresh test.
              return promiseTick(4);
            })
            .then(() => {
              clock.tick(config.device.ephemeralDeviceTTL / 2 * 1000);
              assert.calledOnce(spark.device.refresh);
              clock.tick(60 * 1000);
              assert.calledOnce(spark.device.refresh);
            });
        });
      });

      it(`does not get persisted to bounded storage`, () => {
        assert.isTrue(spark.device.config.ephemeral);

        spark.device.url = `http://example.com/device/id`;

        // single tick accounts for debounce
        clock.tick(1);
        console.log(spark.boundedStorage.data);
        assert.property(spark.boundedStorage.data, `Device`);
        assert.notProperty(spark.boundedStorage.data.Device, `@`);
      });
    });

    it(`gets persisted to bounded storage`, () => {
      clock.uninstall();
      assert.isFalse(spark.device.config.ephemeral);
      spark.device.url = `http://example.com/device/id`;

      // single tick accounts for debounce
      return new Promise((resolve) => setTimeout(resolve, 1))
        .then(() => {
          assert.property(spark.boundedStorage.data, `Device`);
          assert.property(spark.boundedStorage.data.Device, `@`);
          assert.property(spark.boundedStorage.data.Device[`@`], `url`);
          assert.equal(spark.boundedStorage.data.Device[`@`].url, spark.device.url);
        });
    });

  });
});
