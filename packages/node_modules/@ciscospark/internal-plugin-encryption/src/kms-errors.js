/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {Exception} from '@ciscospark/common';
import {SparkHttpError} from '@ciscospark/spark-core';

/**
 * Error class for KMS errors
 */
export class KmsError extends Exception {
  static defaultMessage = `An error was received while communicating with the KMS`;

  /**
   * @param {HttpResponse} body
   * @returns {string}
   */
  parse(body) {
    body = body.body || body;

    Object.defineProperties(this, {
      body: {
        enumerable: false,
        value: body
      },
      reason: {
        enumerable: false,
        value: body.reason
      },
      requestId: {
        enumerable: false,
        value: body.requestId
      },
      status: {
        enumerable: false,
        value: body.status
      }
    });

    let message = body.reason;
    if (body.status) {
      message += `\nKMS_RESPONSE_STATUS: ${body.status}`;
    }
    if (body.requestId) {
      message += `\nKMS_REQUEST_ID: ${body.requestId}`;
    }

    return message;
  }
}

/**
 * Emitted when a REST request includes an encrypter error
 */
export class DryError extends SparkHttpError {
  static defaultMessage = `An error was received from a service that proxies to the KMS`;

  /**
   * @param {SparkHttpError} reason
   * @returns {string}
   */
  parse(reason) {
    Reflect.apply(SparkHttpError.prototype.parse, this, [reason._res]);
    const body = reason._res.body.message;

    let message = body.reason;
    if (this.options.url) {
      message += `\n${this.options.method} ${this.options.url}`;
    }
    else if (this.options.uri) {
      message += `\n${this.options.method} ${this.options.uri}`;
    }
    else {
      message += `\n${this.options.method} ${this.options.service.toUpperCase()}/${this.options.resource}`;
    }
    message += `\nWEBEX_TRACKING_ID: ${this.options.headers.trackingid}`;

    if (body.status) {
      message += `\nKMS_RESPONSE_STATUS: ${body.status}`;
    }
    if (body.requestId) {
      message += `\nKMS_REQUEST_ID: ${body.requestId}`;
    }

    Object.defineProperties(this, {
      reason: {
        enumerable: false,
        value: body.reason
      },
      requestId: {
        enumerable: false,
        value: body.requestId
      },
      status: {
        enumerable: false,
        value: body.status
      }
    });

    return message;
  }
}
