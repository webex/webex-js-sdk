/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import {safeSetTimeout} from '@ciscospark/common-timers';
import {Batcher} from '@ciscospark/spark-core';

import {KmsError, KmsTimeoutError} from './kms-errors';

export const TIMEOUT_SYMBOL = Symbol('TIMEOUT_SYMBOL');

/**
 * @class
 * @private
 */
const KmsBatcher = Batcher.extend({
  namespace: 'Encryption',

  /**
   * Accepts a kmsMessage event and passes its contents to acceptItem
   * @instance
   * @memberof KmsBatcher
   * @param {Object} event
   * @returns {Promise}
   */
  processKmsMessageEvent(event) {
    this.logger.info('kms-batcher: received kms message');
    return Promise.all(event.encryption.kmsMessages.map((kmsMessage) => new Promise((resolve) => {
      /* istanbul ignore else */
      if (process.env.NODE_ENV !== 'production') {
        this.logger.info('kms-batcher:', kmsMessage.body);
      }

      resolve(this.acceptItem(kmsMessage));
    })));
  },

  /**
   * Attaches a timeout to the given KMS message
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @returns {Promise<Object>}
   */
  prepareItem(item) {
    return this.getDeferredForRequest(item)
      .then((defer) => {
        const timeout = item[TIMEOUT_SYMBOL];

        /* istanbul ignore if */
        if (!timeout) {
          throw new Error('timeout is required');
        }

        const timer = safeSetTimeout(() => {
          this.logger.warn(`kms: request timed out; request id: ${item.requestId}; timeout: ${timeout}`);
          this.handleItemFailure(item, new KmsTimeoutError({
            timeout,
            request: item
          }));
        }, timeout);

        // Reminder: reassign `promise` is not a viable means of inserting into
        // the Promise chain
        defer.promise.then(() => clearTimeout(timer));
        defer.promise.catch(() => clearTimeout(timer));

        return item;
      });
  },

  /**
   * Attaches the final bits of cluster info to the payload
   * @instance
   * @memberof KmsBatcher
   * @param {Array} queue
   * @returns {Promise<Array>}
   */
  prepareRequest(queue) {
    return this.spark.internal.encryption.kms._getKMSCluster()
      .then((cluster) => ({
        destination: cluster,
        kmsMessages: queue.map((req) => req.wrapped)
      }));
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} payload
   * @returns {Promise<HttpResponse>}
   */
  submitHttpRequest(payload) {
    this.logger.info('kms: batched-request-length', payload.kmsMessages.length);
    return this.spark.request({
      method: 'POST',
      service: 'encryption',
      resource: '/kms/messages',
      body: payload
    });
  },

  /**
   * Does nothing; the http response doesn't carry our response data
   * @instance
   * @memberof KmsBatcher
   * @returns {Promise}
   */
  handleHttpSuccess() {
    return Promise.resolve();
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @returns {Promise<boolean>}
   */
  didItemFail(item) {
    return Promise.resolve(item.status >= 400);
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @returns {Promise}
   */
  handleItemSuccess(item) {
    return this.getDeferredForResponse(item)
      .then((defer) => {
        defer.resolve(item.body);
      });
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @param {KmsError} [reason]
   * @returns {Promise}
   */
  handleItemFailure(item, reason) {
    return this.getDeferredForResponse(item)
      .then((defer) => {
        defer.reject(reason || new KmsError(item.body));
      });
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintRequest(item) {
    return Promise.resolve(item.requestId);
  },

  /**
   * @instance
   * @memberof KmsBatcher
   * @param {Object} item
   * @returns {Promise}
   */
  fingerprintResponse(item) {
    return Promise.resolve(item.requestId);
  }
});

export default KmsBatcher;
