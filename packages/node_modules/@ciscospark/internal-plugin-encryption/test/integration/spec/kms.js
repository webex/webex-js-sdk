/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-encryption';

import {assert, expect} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import uuid from 'uuid';

describe('Encryption', function () {
  this.timeout(30000);
  describe('KMS', () => {
    let mccoy, spark, spock;

    before('create test user', () => testUsers.create({count: 2})
      .then((users) => {
        spock = users[0];
        spark = new CiscoSpark({
          credentials: {
            authorization: spock.token
          }
        });
        spock.spark = spark;
        assert.isTrue(spark.canAuthorize);

        mccoy = users[1];
        mccoy.spark = new CiscoSpark({
          credentials: {
            authorization: mccoy.token
          }
        });

        assert.isTrue(mccoy.spark.canAuthorize);
        return mccoy.spark.internal.device.register();
      }));

    after(() => spark && spark.internal.mercury.disconnect());

    describe('#createResource()', () => {
      it('creates a kms resource object', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({
          userIds: [spark.internal.device.userId],
          key
        })
          .then((kro) => {
            assert.property(kro, 'uri');
            assert.property(kro, 'keyUris');
            assert.lengthOf(kro.keyUris, 1);
            assert.include(kro.keyUris, key.uri);
            assert.property(kro, 'authorizationUris');
            assert.lengthOf(kro.authorizationUris, 1);
          })));
    });

    describe('#addAuthorization()', () => {
      let boundedKeyUri, kro, otherKro;
      before('create a resource', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          kro = k;
          boundedKeyUri = kro.keyUris[0];
          assert.lengthOf(kro.authorizationUris, 1);
        }));

      it('authorizes a user to a key', () => spark.internal.encryption.kms.addAuthorization({
        userIds: [mccoy.spark.internal.device.userId],
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.internal.device.userId);
          return mccoy.spark.internal.encryption.kms.fetchKey({uri: boundedKeyUri});
        }));

      it('authorizes a resource to a key', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({key}))
        .then((k) => {
          otherKro = k;
          return spark.internal.encryption.kms.addAuthorization({
            authIds: [otherKro.uri],
            kro
          });
        })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, otherKro.uri);
        }));
    });

    /**
     *Test listAuthorizations function
     *Setup: Create a resource, then authorize a user to a key, then authorize a resource to a key
     *Test:
     *1)Invoke listAuthorizations on the resource, verify that the function returns the array that contains two authorized items
     *2)Remove the authorized user from the resource, then invoke listAuthorizations again, verify that the returned array doesn't have the user.
     *3)Remove the authorized resource from the resource again, then invoke listAuthorizations again, verify that he returned array doesn't have the resource.
     */
    describe('#listAuthorizations()', () => {
      let boundedKeyUri, kro, otherKro;
      let testResourceId;

      before('creates a resource', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          kro = k;
          boundedKeyUri = kro.keyUris[0];
          assert.lengthOf(kro.authorizationUris, 1);
        }));

      before('authorizes a user to a key', () => spark.internal.encryption.kms.addAuthorization({
        userIds: [mccoy.spark.internal.device.userId],
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.internal.device.userId);
          return mccoy.spark.internal.encryption.kms.fetchKey({uri: boundedKeyUri});
        }));

      before('authorizes a resource to a key', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({key}))
        .then((k) => {
          otherKro = k;
          testResourceId = otherKro.uri;
          return spark.internal.encryption.kms.addAuthorization({
            authIds: [testResourceId],
            kro
          });
        })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, otherKro.uri);
        }));

      it('list authorizations', () => spark.internal.encryption.kms.listAuthorizations({kroUri: kro.uri})
        .then((authorizations) => {
          assert.equal(authorizations.length, 3);
          assert.include(authorizations.map((a) => a.authId), mccoy.spark.internal.device.userId);
          assert.include(authorizations.map((a) => a.authId), spock.id);
          assert.include(authorizations.map((a) => a.resourceUri), testResourceId);
          assert.include(authorizations.map((a) => a.resourceUri), kro.uri);
        }));

      it('rejects normally for users that are not authorized', () => testUsers.create({count: 1})
        .then(([user]) => {
          const us = new CiscoSpark({
            credentials: {
              authorization: user.token
            }
          });

          return assert.isRejected(us.internal.encryption.kms.listAuthorizations({kroUri: kro.uri}))
            .then((err) => {
              console.error(err);
              assert.equal(err.status, 403, 'We should get a Not Authorized response from kms');
            })
            .then(() => us.internal.mercury.disconnect());
        }));

      it('remove the user and verify this user is not in the authorization list ', () => spark.internal.encryption.kms.removeAuthorization({
        userId: mccoy.spark.internal.device.userId,
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.internal.device.userId);
          return spark.internal.encryption.kms.listAuthorizations({kro})
            .then((authorizations) => {
              assert.equal(authorizations.length, 2);
              assert.include(authorizations.map((a) => a.authId), spock.id);
              assert.include(authorizations.map((a) => a.resourceUri), testResourceId);
              assert.include(authorizations.map((a) => a.resourceUri), kro.uri);
            });
        }));

      it('remove the resource and verify this resource is not in the authorizaiton list', () => spark.internal.encryption.kms.removeAuthorization({
        userId: testResourceId,
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, testResourceId);
          return spark.internal.encryption.kms.listAuthorizations({kroUri: kro.uri})
            .then((authorizations) => {
              assert.equal(authorizations.length, 1);
              assert.include(authorizations.map((a) => a.authId), spock.id);
              assert.include(authorizations.map((a) => a.resourceUri), kro.uri);
            });
        }));
    });

    describe('#removeAuthorization()', () => {
      let boundedKeyUri, kro, otherKro;
      before('create resource', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          kro = k;
          boundedKeyUri = kro.keyUris[0];
          assert.lengthOf(kro.authorizationUris, 1);
        }));

      before('create another resource', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([key]) => spark.internal.encryption.kms.createResource({
          key
        }))
        .then((k) => {
          otherKro = k;
        }));

      before('add auths to resource', () => spark.internal.encryption.kms.addAuthorization({
        authIds: [otherKro.uri, mccoy.spark.internal.device.userId],
        kro
      })
        .then(([kroAuth, userAuth]) => {
          assert.equal(kroAuth.authId, otherKro.uri);
          assert.equal(userAuth.authId, mccoy.spark.internal.device.userId);
        }));

      it('deauthorizes a user from a key', () => spark.internal.encryption.kms.removeAuthorization({
        userId: mccoy.spark.internal.device.userId,
        kroUri: kro.uri
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, mccoy.spark.internal.device.userId);
          return assert.isRejected(mccoy.spark.internal.encryption.kms.fetchKey({uri: boundedKeyUri}));
        }));

      it('deauthorizes a resource from a key', () => spark.internal.encryption.kms.removeAuthorization({
        authId: otherKro.uri,
        kro
      })
        .then(([auth]) => {
          assert.equal(auth.resourceUri, kro.uri);
          assert.equal(auth.authId, otherKro.uri);
        }));
    });

    describe('#bindKey()', () => {
      let key2, kro;
      it('binds a resource to a key', () => spark.internal.encryption.kms.createUnboundKeys({count: 2})
        .then((keys) => {
          key2 = keys[1];
          return spark.internal.encryption.kms.createResource({
            userIds: [spark.internal.device.userId],
            key: keys[0]
          });
        })
        .then((k) => {
          kro = k;
          return spark.internal.encryption.kms.bindKey({kro, key: key2});
        })
        .then((key) => {
          assert.equal(key.uri, key2.uri);
          assert.property(key, 'bindDate');
          assert.property(key, 'resourceUri');
          assert.equal(key.resourceUri, kro.uri);
        }));
    });

    describe('#createUnboundKeys()', () => {
      it('requests unbound keys from the KMS', () => spark.internal.encryption.kms.createUnboundKeys({count: 2})
        .then((keys) => {
          assert.lengthOf(keys, 2);

          const [key1, key2] = keys;

          assert.property(key1, 'uri');
          assert.property(key1, 'jwk');
          assert.property(key2, 'uri');
          assert.property(key2, 'jwk');
        }));
    });

    describe('#fetchKey()', () => {
      let key;
      it('retrieves a specific key', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          key = k;
          return spark.internal.encryption.kms.fetchKey({uri: key.uri});
        })
        .then((key2) => {
          assert.property(key2, 'uri');
          assert.property(key2, 'jwk');
          assert.notEqual(key2, key);
          assert.equal(key2.uri, key.uri);
        }));
    });

    describe('#fetchKey(onBehalfOf)', () => {
      let jim;

      before('create compliance officer test user', () => testUsers.create({
        count: 1,
        config: {
          roles: [{name: 'spark.kms_orgagent'}]
        }
      })
        .then((users) => {
          jim = users[0];

          jim.spark = new CiscoSpark({
            credentials: {
              authorization: jim.token
            }
          });
          assert.isTrue(jim.spark.canAuthorize);
        }));

      before('connect compliance officer to mercury', () => jim.spark.internal.mercury.connect());

      after(() => jim.spark && jim.spark.internal.mercury.disconnect());

      let key;
      it('retrieve key on behalf of another user', () => spock.spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          key = k;
          // Compliance Officer Jim fetches a key on behalf of Spock
          return jim.spark.internal.encryption.kms.fetchKey({uri: key.uri, onBehalfOf: spock.id});
        })
        .then((key2) => {
          assert.property(key2, 'uri');
          assert.property(key2, 'jwk');
          assert.notEqual(key2, key);
          assert.equal(key2.uri, key.uri);
        }));

      it('error retrieving key, on behalf of another user, without spark.kms_orgagent role',
        () => spock.spark.internal.encryption.kms.createUnboundKeys({count: 1})
          .then(([k]) => {
            key = k;
            // Normal user McCoy fails to fetch a key on behalf of Spock
            return mccoy.spark.internal.encryption.kms.fetchKey({uri: key.uri, onBehalfOf: spock.id});
          })
          .then(() => {
            expect.fail('It should not be possible to retrieve a key on behalf of another user without the spark.kms_orgagent role');
          })
          .catch((error) => {
            // Expect a Forbidden error
            expect(error.body.status).to.equal(403);
          }));

      it('retrieve key on behalf of other users in quick succession', () => {
        let spockKey, mccoyKey;
        return Promise.all([
          spock.spark.internal.encryption.kms.createUnboundKeys({count: 1}),
          mccoy.spark.internal.encryption.kms.createUnboundKeys({count: 1})
        ]).then(([[spockK], [mccoyK]]) => {
          spockKey = spockK;
          mccoyKey = mccoyK;
          // Compliance Officer Jim fetches keys on behalf of users
          return Promise.all([
            jim.spark.internal.encryption.kms.fetchKey({uri: spockKey.uri, onBehalfOf: spock.id}),
            jim.spark.internal.encryption.kms.fetchKey({uri: mccoyKey.uri, onBehalfOf: mccoy.id})
          ]);
        }).then(([spockK, mccoyK]) => {
          assert.property(spockK, 'uri');
          assert.property(spockK, 'jwk');
          assert.notEqual(spockK, spockKey);
          assert.equal(spockK.uri, spockKey.uri);

          assert.property(mccoyK, 'uri');
          assert.property(mccoyK, 'jwk');
          assert.notEqual(mccoyK, mccoyKey);
          assert.equal(mccoyK.uri, mccoyKey.uri);
        });
      });
    });

    describe('#ping()', () => {
      it('sends a ping to the kms', () => spark.internal.encryption.kms.ping()
        .then((res) => {
          assert.property(res, 'status');
          assert.equal(res.status, 200);
          assert.property(res, 'requestId');
        }));
    });

    describe('when ecdhe negotiation times out', () => {
      let originalKmsTimeout, spark2, spy;
      before('create test user', () => testUsers.create({count: 1})
        .then(([u]) => {
          spark2 = new CiscoSpark({
            credentials: {
              authorization: u.token
            }
          });
          assert.isTrue(spark.canAuthorize);
        }));

      after(() => spark2 && spark2.internal.mercury.disconnect());

      beforeEach('alter config', () => {
        originalKmsTimeout = spark2.config.encryption.kmsInitialTimeout;
        spark2.config.encryption.kmsInitialTimeout = 100;
        spy = sinon.spy(spark2.internal.encryption.kms, 'prepareRequest');
      });

      afterEach(() => {
        spark2.config.encryption.kmsInitialTimeout = originalKmsTimeout;
      });

      afterEach(() => spy.restore());

      it('handles late ecdhe responses', () => spark2.internal.encryption.kms.ping()
        .then(() => {
          // callCount should be at least 3:
          // 1 for the initial ping message
          // 1 when the ecdh key gets renegotiated
          // 1 when the pings gets sent again
          assert.isAbove(spy.callCount, 2, 'If this test fails, we\'ve made previously-assumed-to-be-impossible performance gains in cloudapps; please update this test accordingly.');
        }));
    });

    describe('when the kms is in another org', () => {
      let fedSpark;

      before('create test user in other org', () => testUsers.create({
        count: 1,
        config: {
          email: `spark-js-sdk--kms-fed--${uuid.v4()}@wx2.example.com`,
          entitlements: ['webExSquared'],
          orgId: 'kmsFederation'
        }
      })
        .then((users) => {
          const fedUser = users[0];
          assert.equal(fedUser.orgId, '75dcf6c2-247d-4e3d-a32c-ff3ee28398eb');
          assert.notEqual(fedUser.orgId, spock.orgId);

          fedSpark = new CiscoSpark({
            credentials: {
              authorization: fedUser.token
            }
          });
          assert.isTrue(fedSpark.canAuthorize);
        }));

      before('connect federated user to mercury', () => fedSpark.internal.mercury.connect());

      after(() => fedSpark && fedSpark.internal.mercury.disconnect());

      it('responds to pings', () => fedSpark.internal.encryption.kms.ping()
        .then((res) => {
          assert.property(res, 'status');
          assert.equal(res.status, 200);
          assert.property(res, 'requestId');
        }));

      let key;
      it('lets federated users retrieve keys from the main org', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          key = k;
          return spark.internal.encryption.kms.createResource({
            userIds: [
              spark.internal.device.userId,
              fedSpark.internal.device.userId
            ],
            key
          });
        })
        .then(() => fedSpark.internal.encryption.kms.fetchKey({uri: key.uri}))
        .then((fedKey) => assert.equal(fedKey.keyUri, key.keyUri)));

      let fedKey;
      it('lets non-federated users retrieve keys from the federated org', () => fedSpark.internal.encryption.kms.createUnboundKeys({count: 1})
        .then(([k]) => {
          fedKey = k;
          return fedSpark.internal.encryption.kms.createResource({
            userIds: [
              fedSpark.internal.device.userId,
              spark.internal.device.userId
            ],
            key: fedKey
          });
        })
        .then(() => spark.internal.encryption.kms.fetchKey({uri: fedKey.uri}))
        .then((key) => assert.equal(key.keyUri, fedKey.keyUri)));
    });
  });
});
