/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-encryption';

import {assert, expect} from '@ciscospark/test-helper-chai';
import file from '@ciscospark/test-helper-file';
import sinon from '@ciscospark/test-helper-sinon';
import CiscoSpark from '@ciscospark/spark-core';
import testUsers from '@ciscospark/test-helper-test-users';
import makeLocalUrl from '@ciscospark/test-helper-make-local-url';

describe('Encryption', function () {
  this.timeout(30000);

  let key, user, spark;

  const PLAINTEXT = 'Admiral, if we go "by the book". like Lieutenant Saavik, hours could seem like days.';
  let FILE = makeLocalUrl('/sample-image-small-one.png');

  before('create test user', () => testUsers.create({count: 1})
    .then((users) => {
      user = users[0];
      spark = new CiscoSpark({
        credentials: {
          authorization: user.token
        }
      });
      assert.isTrue(spark.isAuthenticated || spark.canAuthorize);
    }));

  before('create unbound key', () => spark.internal.encryption.kms.createUnboundKeys({count: 1})
    .then(([k]) => {
      key = k;
    }));

  before('fetch file fixture', () => spark.request({
    uri: FILE,
    responseType: 'buffer'
  })
    .then((res) => { FILE = res.body; }));

  after(() => spark && spark.internal.mercury.disconnect());

  describe('#decryptBinary()', () => {
    it('decrypts a binary file', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr, cdata}) => {
        scr.loc = 'file:///file.enc';
        return spark.internal.encryption.encryptScr(key, scr)
          .then((cipherScr) => spark.internal.encryption.decryptScr(key, cipherScr))
          .then((decryptedScr) => spark.internal.encryption.decryptBinary(decryptedScr, cdata))
          .then((f) => {
            assert.isTrue(Buffer.isBuffer(f));
            return assert.equal(f.byteLength, FILE.byteLength);
          });
      }));
  });

  describe('#decryptScr()', () => {
    it('decrypts an scr', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr}) => {
        scr.loc = 'file:///file.enc';
        return spark.internal.encryption.encryptScr(key, scr)
          .then((cipherScr) => spark.internal.encryption.decryptScr(key, cipherScr))
          .then((decryptedScr) => assert.deepEqual(decryptedScr, scr));
      }));
  });

  describe('#decryptText()', () => {
    it('decrypts text', () => spark.internal.encryption.encryptText(key, PLAINTEXT)
      .then((ciphertext) => {
        assert.notEqual(ciphertext, PLAINTEXT);
        return spark.internal.encryption.decryptText(key, ciphertext);
      })
      .then((plaintext) => assert.equal(plaintext, PLAINTEXT)));
  });

  describe('#getKey()', () => {
    let fetchKeySpy, otherSpark, otherUser, storageGetSpy;
    before('create test user', () => testUsers.create({count: 1})
      .then((users) => {
        otherUser = users[0];
        otherSpark = new CiscoSpark({
          credentials: {
            authorization: otherUser.token
          }
        });
        assert.isTrue(otherSpark.canAuthorize);
      }));

    before('create kms resource', () => spark.internal.encryption.kms.createResource({
      key,
      userIds: [
        spark.internal.device.userId,
        otherUser.id
      ]
    }));

    after(() => otherSpark && otherSpark.internal.mercury.disconnect());

    beforeEach(() => {
      fetchKeySpy = sinon.spy(otherSpark.internal.encryption.kms, 'fetchKey');
      storageGetSpy = sinon.spy(otherSpark.internal.encryption.unboundedStorage, 'get');
    });

    afterEach(() => {
      fetchKeySpy.restore();
      storageGetSpy.restore();
    });

    it('shortcircuits if it receives a key instead of a keyUri', () => spark.internal.encryption.getKey(key)
      // Reminder: If this starts failing after a node-jose upgrade, it probably
      // implies node-jose stopped shortcircuiting correctly.
      .then((k) => assert.equal(k, key)));

    it('attempts to retrieve the specified key from the local cache', () => otherSpark.internal.encryption.getKey(key.uri)
      .then((k) => assert.calledWith(storageGetSpy, k.uri)));

    it('fetches the key from the kms', () => otherSpark.internal.encryption.unboundedStorage.del(key.uri)
      .then(() => assert.notCalled(fetchKeySpy))
      .then(() => otherSpark.internal.encryption.getKey(key.uri))
      .then(() => assert.calledOnce(fetchKeySpy)));

    it('stores the newly retrieved key', () => otherSpark.internal.encryption.getKey(key.uri)
      .then((k) => otherSpark.internal.encryption.unboundedStorage.get(k.uri))
      .then((str) => JSON.parse(str))
      .then((k2) => {
        assert.property(k2, 'jwk');
        assert.property(k2.jwk, 'k');
        assert.equal(key.jwk.kid, k2.jwk.kid);
      }));
  });

  describe('#download()', () => {
    it('downloads and decrypts an encrypted file', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr, cdata}) => spark.request({
        method: 'POST',
        uri: makeLocalUrl('/files/upload'),
        body: cdata
      })
        .then((res) => {
          scr.loc = makeLocalUrl(res.body.loc, {full: true});
          return spark.internal.encryption.encryptScr(key, scr);
        }))
      .then((cipherScr) => spark.internal.encryption.decryptScr(key, cipherScr))
      .then((scr) => spark.internal.encryption.download(scr))
      .then((f) => file.isMatchingFile(f, FILE)
        .then((result) => assert.deepEqual(result, true))));

    it('emits progress events', () => {
      const spy = sinon.spy();
      return spark.internal.encryption.encryptBinary(FILE)
        .then(({scr, cdata}) => spark.request({
          method: 'POST',
          uri: makeLocalUrl('/files/upload'),
          body: cdata
        })
          .then((res) => {
            scr.loc = makeLocalUrl(res.body.loc, {full: true});
            return spark.internal.encryption.encryptScr(key, scr);
          }))
        .then((cipherScr) => spark.internal.encryption.decryptScr(key, cipherScr))
        .then((scr) => spark.internal.encryption.download(scr)
          .on('progress', spy))
        .then(() => assert.called(spy));
    });
  });

  describe('#encryptBinary()', () => {
    it('encrypts a binary file', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr, cdata}) => {
        assert.property(scr, 'enc');
        assert.property(scr, 'key');
        assert.property(scr, 'iv');
        return assert.isBufferLike(cdata);
      }));

    // browserOnly(it)(`accepts an ArrayBuffer`);
    // browserOnly(it)(`accepts a Blob`);
  });

  describe('#encryptScr()', () => {
    it('encrypts an scr', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr}) => {
        scr.loc = 'file:///file.enc';
        return spark.internal.encryption.encryptScr(key, scr);
      })
      .then((cipherScr) => assert.isString(cipherScr)));
  });

  describe('#encryptText()', () => {
    it('encrypts text', () => spark.internal.encryption.encryptText(key, PLAINTEXT)
      .then((ciphertext) => assert.notEqual(ciphertext, PLAINTEXT)));
  });

  describe('#onBehalfOf', () => {
    let complianceUser;

    before('create compliance officer test user', () => testUsers.create({
      count: 1,
      config: {
        roles: [{name: 'spark.kms_orgagent'}]
      }
    })
      .then((users) => {
        complianceUser = users[0];
        complianceUser.spark = new CiscoSpark({
          credentials: {
            authorization: complianceUser.token
          }
        });
        assert.isTrue(complianceUser.spark.canAuthorize);
      }));

    after(() => complianceUser && complianceUser.spark.internal.mercury.disconnect());

    it('decrypt text', () => spark.internal.encryption.encryptText(key, PLAINTEXT)
      .then((ciphertext) => {
        assert.notEqual(ciphertext, PLAINTEXT);
        return complianceUser.spark.internal.encryption.decryptText(key, ciphertext, {onBehalfOf: user.id});
      })
      .then((plaintext) => assert.equal(plaintext, PLAINTEXT)));

    it('encrypt and decrypt text', () => complianceUser.spark.internal.encryption.encryptText(key, PLAINTEXT, {onBehalfOf: user.id})
      .then((ciphertext) => {
        assert.notEqual(ciphertext, PLAINTEXT);
        return complianceUser.spark.internal.encryption.decryptText(key, ciphertext, {onBehalfOf: user.id});
      })
      .then((plaintext) => assert.equal(plaintext, PLAINTEXT)));

    it('decrypt scr', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr}) => {
        scr.loc = 'file:///file.enc';
        return spark.internal.encryption.encryptScr(key, scr)
          .then((cipherScr) => complianceUser.spark.internal.encryption.decryptScr(key, cipherScr, {onBehalfOf: user.id}))
          .then((decryptedScr) => assert.deepEqual(decryptedScr, scr));
      }));

    it('decrypt scr', () => spark.internal.encryption.encryptBinary(FILE)
      .then(({scr}) => {
        scr.loc = 'file:///file.enc';
        return complianceUser.spark.internal.encryption.encryptScr(key, scr, {onBehalfOf: user.id})
          .then((cipherScr) => complianceUser.spark.internal.encryption.decryptScr(key, cipherScr, {onBehalfOf: user.id}))
          .then((decryptedScr) => assert.deepEqual(decryptedScr, scr));
      }));

    it('getKey', () => complianceUser.spark.internal.encryption.getKey(key.uri, {onBehalfOf: user.id})
      .then((key2) => {
        assert.property(key2, 'uri');
        assert.property(key2, 'jwk');
        assert.notEqual(key2, key);
        assert.equal(key2.uri, key.uri);
      }));

    it('getKey forbidden as compliance officer does not have access', () => complianceUser.spark.internal.encryption.getKey(key.uri)
      .then(
        (value) => expect.fail(`Compliance officer has retrieved key without onBehalfOf: ${value}`),
        (error) => expect(error.body.status).to.equal(403)
      ));

    it('getKey forbidden as user does not have access', () => complianceUser.spark.internal.encryption.getKey(key.uri, {onBehalfOf: '7851fe79-7c87-40cc-ac36-8b77b011b399'})
      .then(
        (value) => expect.fail(`Should not be found as 7851fe79-7c87-40cc-ac36-8b77b011b399 does not have access ${value}`),
        (error) => expect(error.body.status).to.equal(403)
      ));

    it('getKey onBehalfOf and then by compliance officer only', () => complianceUser.spark.internal.encryption.getKey(key.uri, {onBehalfOf: user.id})
      .then((key2) => {
        assert.property(key2, 'uri');
        assert.property(key2, 'jwk');
        assert.notEqual(key2, key);
        assert.equal(key2.uri, key.uri);
      })
      .then(() => complianceUser.spark.internal.encryption.getKey(key.uri))
      .then(
        (value) => expect.fail(`Compliance should no longer be able to retrieve key as onBehalfOf was not set: ${value}`),
        (error) => expect(error.body.status).to.equal(403)
      ));
  });
});
