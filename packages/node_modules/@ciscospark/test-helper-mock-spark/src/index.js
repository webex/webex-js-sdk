/**!
 *
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

'use strict';

/* istanbul ignore next */
if (typeof Promise === 'undefined') {
  // eslint-disable-next-line global-require
  require('es6-promise').polyfill();
}

var _ = require('lodash');
var sinon = require('@ciscospark/test-helper-sinon');
var State = require('ampersand-state');

/**
 * Mock Spark constructor
 * @param {Object} options
 * @returns {MockSpark}
 */
function makeSpark(options) {
  options = options || {};
  var config = options.config;
  if (config) {
    delete options.config;
  }
  config = _.merge({
    credentials: {
      authorizeUrl: 'https://idbroker.webex.com/idb/oauth2/v1/authorize',
      logoutUrl: 'https://idbroker.webex.com/idb/oauth2/v1/logout',
      // eslint-disable-next-line camelcase
      client_id: 'fake',
      // eslint-disable-next-line camelcase
      client_secret: 'fake',
      // eslint-disable-next-line camelcase
      redirect_uri: 'http://example.com',
      // eslint-disable-next-line camelcase
      scope: 'scope:one',
      service: 'spark'
    },
    conversation: {
      allowedTags: {
        'spark-mention': ['data-object-type', 'data-object-id', 'data-object-url']
      }
    },
    avatar: {},
    device: {},
    encryption: {},
    logger: {},
    mercury: {},
    metrics: {},
    support: {},
    user: {}
  }, config || {});

  var requestPromise = Promise.resolve({statusCode: 200, body: {}});
  var uploadPromise = Promise.resolve({});

  requestPromise.on = uploadPromise.on = function on() {
    return requestPromise;
  };

  /**
   * produces a mock storage object
   * @param {Object} data
   * @returns {Storage}
   */
  function makeMockStorage(data) {

    data = data || {};
    return {
      data: data,
      on: sinon.spy(),
      once: sinon.spy(),
      listenTo: sinon.spy(),
      listenToAndRun: sinon.spy(),
      clear: function clear(namespace) {
        this.data = this.data || data;
        this.data[namespace] = {};
      },
      del: function del(namespace, key) {
        this.data = this.data || data;
        this.data[namespace] = this.data[namespace] || {};
        // eslint-disable-next-line prefer-reflect
        delete this.data[namespace][key];
      },
      get: function get(namespace, key) {
        this.data = this.data || data;
        this.data[namespace] = this.data[namespace] || {};
        var ret = this.data[namespace][key];
        if (ret) {

          return Promise.resolve(ret);
        }

        return Promise.reject(new Error('MockNotFoundError'));
      },
      put: function put(namespace, key, value) {
        this.data = this.data || data;
        try {
          // this is the simplest way to to turn ampstate objects into bare
          // objects without actually checking if they're ampstate objects
          value = JSON.parse(JSON.stringify(value));
        }
        catch (err) {
          // ignore
        }
        this.data[namespace] = this.data[namespace] || {};
        this.data[namespace][key] = value;
        return Promise.resolve();
      }
    };
  }

  var request = sinon.stub().returns(requestPromise);
  var upload = sinon.stub().returns(uploadPromise);
  var MockSpark = State.extend(_.defaults(options, {
    extraProperies: 'allow',
    request: request,
    upload: upload,
    refresh: function refresh() {
      return Promise.resolve();
    },
    session: {
      config: 'object'
    },
    initialize: function initialize(attrs) {
      this.boundedStorage = makeMockStorage(attrs && attrs.initialBoundedStorage);
      this.unboundedStorage = makeMockStorage(attrs && attrs.initialUnboundedStorage);
      this.trigger('change:config');
    }
  }));

  var spark = new MockSpark(Object.assign({config: config}, options));

  sinon.spy(spark, 'refresh');
  _.defaults(spark, {
    credentials: {
      authorization: 'Basic NOTATOKEN',
      getUserToken: sinon.stub().returns(Promise.resolve({toString: function toString() {
        return 'Basic NOTATOKEN';
      }}))
    },
    conversation: {},
    avatar: {},
    device: {
      webSocketUrl: 'ws://example.com',
      features: {
        developer: {
          get: sinon.stub()
        },
        entitlement: {
          get: sinon.stub()
        },
        user: {
          get: sinon.stub()
        }
      },
      registered: true,
      register: sinon.stub().returns(Promise.resolve())
    },
    feature: {
      setFeature: sinon.stub().returns(Promise.resolve(false)),
      getFeature: sinon.stub().returns(Promise.resolve(false))
    },
    encryption: {},
    metrics: {
      sendUnstructured: sinon.spy()
    },
    sessionId: 'mock-spark_88888888-4444-4444-4444-aaaaaaaaaaaa',
    support: {},
    user: {},
    mercury: {},
    logger: process.env.MOCK_LOGGER ? console : {
      error: sinon.spy(),
      warn: sinon.spy(),
      log: sinon.spy(),
      info: sinon.spy(),
      debug: sinon.spy()
    }
  });

  return spark;
}

module.exports = makeSpark;
