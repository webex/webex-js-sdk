/*!
 * Copyright (c) 2015-2017 Cisco Systems, Inc. See LICENSE file.
 */

import '@ciscospark/internal-plugin-wdm';
import '@ciscospark/plugin-logger';
import '@ciscospark/plugin-messages';
import '@ciscospark/plugin-rooms';
import CiscoSpark, {SparkHttpError} from '@ciscospark/spark-core';
import {assert} from '@ciscospark/test-helper-chai';
import sinon from '@ciscospark/test-helper-sinon';
import testUsers from '@ciscospark/test-helper-test-users';
import fh from '@ciscospark/test-helper-file';
import {browserOnly, flaky, nodeOnly} from '@ciscospark/test-helper-mocha';

const debug = require('debug')('messages');

const KNOWN_HOSTED_IMAGE_URL = 'https://download.ciscospark.com/test/photo.png';

describe('plugin-messages', function () {
  this.timeout(60000);

  let spark;

  before(() => testUsers.create({count: 1})
    .then(([user]) => {
      spark = new CiscoSpark({credentials: user.token});
    }));

  describe('#messages', () => {
    let room;

    before(() => spark.rooms.create({title: 'Cisco Spark Test Room'})
      .then((r) => {
        room = r;

        return spark.messages.create({
          roomId: room.id,
          text: 'First Message'
        });
      }));

    after(() => {
      if (!room) {
        return Promise.resolve();
      }

      return spark.rooms.remove(room)
        .catch((reason) => {
          console.error('Failed to remove room', reason);
        });
    });

    describe('#create()', () => {
      it('posts a message in a room', () => {
        const text = 'A test message';

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => {
            assert.isDefined(message);
            assert.isMessage(message);
            assert.equal(message.text, text);
          });
      });

      it('posts a file to a room by specifying the file\'s url', () => spark.messages.create({
        roomId: room.id,
        file: KNOWN_HOSTED_IMAGE_URL
      })
        .then((message) => {
          assert.property(message, 'files');
          assert.isDefined(message.files);
          assert.isArray(message.files);
          assert.lengthOf(message.files, 1);
        }));

      let blob, buffer;

      browserOnly(before)(() => fh.fetch('sample-image-small-one.png')
        .then((file) => {
          blob = file;

          return new Promise((resolve) => {
            /* global FileReader */
            const fileReader = new FileReader();

            fileReader.onload = function () {
              buffer = this.result;
              resolve();
            };
            fileReader.readAsArrayBuffer(blob);
          });
        }));

      nodeOnly(before)(() => fh.fetchWithoutMagic('sample-image-small-one.png')
        .then((file) => {
          buffer = file;
        }));

      browserOnly(it)('posts a file to a room by directly supplying its blob', () => spark.messages.create({
        roomId: room.id,
        file: blob
      })
        .then((message) => {
          assert.property(message, 'files');
          assert.isDefined(message.files);
          assert.isArray(message.files);
          assert.lengthOf(message.files, 1);
        }));

      // Disabling it gating pipelines because it failes a lot and we get
      // mostly adequate coverage via blob upload
      flaky(it, process.env.SKIP_FLAKY_TESTS)('posts a file to a room by directly supplying its buffer', () => spark.messages.create({
        roomId: room.id,
        file: buffer
      })
        .then((message) => {
          assert.property(message, 'files');
          assert.isDefined(message.files);
          assert.isArray(message.files);
          assert.lengthOf(message.files, 1);
        }));

      it('posts a file with a message to a room by specifying the file\'s url', () => spark.messages.create({
        roomId: room.id,
        file: KNOWN_HOSTED_IMAGE_URL,
        text: 'A File'
      })
        .then((message) => {
          assert.property(message, 'files');
          assert.isDefined(message.files);
          assert.isArray(message.files);
          assert.lengthOf(message.files, 1);

          assert.property(message, 'text');
        }));
    });

    describe('get()', () => {
      let message;

      before(() => spark.messages.create({
        roomId: room.id,
        text: 'A test message'
      })
        .then((m) => {
          message = m;
        }));

      it('returns a single message', () => spark.messages.get(message)
        .then((m) => {
          assert.isMessage(m);
          assert.deepEqual(m, message);
        }));
    });

    describe('#markAsRead()', () => {
      before(() => spark.internal.mercury.connect());
      after(() => spark.internal.mercury.disconnect());

      it('marks a message as read', () => {
        const text = 'A test message';

        return spark.messages.create({
          roomId: room.id,
          text
        })
          .then((message) => spark.messages.markAsRead(message)
            .then((ack) => {
              assert.isDefined(ack);
              assert.isDefined(ack.id);
              assert.equal(ack.messageId, message.id);
              assert.isDefined(ack.markedAsRead);
            }));
      });
    });

    describe('#list()', () => {
      let room;

      before(() => spark.rooms.create({
        title: 'Room List Test'
      })
        .then((r) => {
          room = r;
        }));

      before(() => [1, 2, 3].reduce((promise, value) => promise.then(() => spark.messages.create({
        roomId: room.id,
        text: `message: ${value}`
      })), Promise.resolve()));

      it('returns all messages for a room', () => spark.messages.list({roomId: room.id})
        .then((messages) => {
          assert.isDefined(messages);
          assert.lengthOf(messages, 3);
          for (const message of messages) {
            assert.isMessage(message);
          }
        }));

      it('returns a bounded set of messages for a room', () => {
        const spy = sinon.spy();

        return spark.messages.list({roomId: room.id, max: 2})
          .then((messages) => {
            assert.lengthOf(messages, 2);

            return (function f(page) {
              for (const message of page) {
                spy(message.id);
              }

              if (page.hasNext()) {
                return page.next().then(f);
              }

              return Promise.resolve();
            }(messages));
          })
          .then(() => {
            assert.calledThrice(spy);
          });
      });
    });

    describe('#remove()', () => {
      let message;

      beforeEach(() => spark.messages.create({
        roomId: room.id,
        text: 'A test message'
      })
        .then((m) => {
          message = m;
        }));

      it('deletes a single message', () => spark.messages.remove(message)
        .then((body) => {
          assert.notOk(body);

          return assert.isRejected(spark.messages.get(message));
        })
        .then((reason) => {
          assert.instanceOf(reason, SparkHttpError.NotFound);
        }));
    });

    describe('events', () => {
      describe('#listen()', () => {
        [
          'post',
          'share'
        ].forEach((verb) => {
          it(`emits a "created" event when a "${verb}" activity arrives`, () => {
            const props = {
              verb
            };
            const event = mockActivityEvent(props);
            const spy = sinon.spy();

            spark.messages.listen()
              .then(() => {
                spark.messages.on('created', spy);
                debug(`create mock activity event: ${JSON.stringify(event)}`);
                spark.internal.mercury._onmessage(event);

                return Promise.resolve()
                  .then(() => {
                    assert.calledOnce(spy);
                  });
              });
          });
        });
      });

      describe('#createMessagesEventData', () => {
        [
          {
            tags: ['ONE_ON_ONE'],
            roomType: 'direct'
          },
          {
            tags: [],
            roomType: 'group'
          }
        ].forEach((input) => {
          it(`creates a messages event for a ${input.roomType} room`, () => {
            const props = {
              target: {
                tags: input.tags
              }
            };
            const activity = mockActivity(props);
            const event = spark.messages.createMessagesEventData(activity);

            debug(`messages event created: ${JSON.stringify(event)}`);

            assert.isDefined(event.id);
            assert.isDefined(event.roomId);
            assert.isTrue(event.roomType === input.roomType);
            assert.isTrue(event.text === activity.object.displayName);
            assert.isDefined(event.personId);
            assert.isDefined(event.personEmail);
            assert.isDefined(event.created);
          });
        });

        it('creates a messages event with files', () => {
          const additionalProps = {
            object: {
              files: {
                items: [
                  {
                    displayName: 'file1.png'
                  },
                  {
                    displayName: 'file2.txt'
                  }
                ]
              }
            }
          };
          const activity = mockActivity(additionalProps);
          const event = spark.messages.createMessagesEventData(activity);

          assert.isArray(event.files);
          assert.isTrue(event.files.length === 2);
          event.files.forEach((file) => {
            assert.isTrue(file.startsWith('https://api.ciscospark.com/v1/contents/'));
          });
        });
      });
    });
  });
});

/**
 * Create a mock activity event.
 * Add and override properties to customize the default activity.
 * @param {Object} props
 * @returns {Object} activity
 */
function mockActivityEvent(props) {
  return {
    data: {
      data: {
        activity: mockActivity(props),
        eventType: 'conversation.activity'
      }
    }
  };
}

/**
 * Create a mock activity.
 * Add and override properties to customize the default activity.
 * @param {Object} props
 * @returns {Object} activity
 */
function mockActivity(props) {
  const activity = {
    id: '88888888-4444-4444-4444-000000000001',
    verb: 'post',
    actor: {
      id: '88888888-4444-4444-4444-000000000002',
      entryEmail: 'alice@email.com'
    },
    object: {
      displayName: 'hi'
    },
    target: {
      tags: [
        'ONE_ON_ONE'
      ]
    },
    published: Date.now()
  };

  return Object.assign(activity, props);
}
